#include <stdio.h>
#include <time.h>

#define RJ 4                 // 0 no debugging, 1 print solutions, 2 print puzzles, 3 print steps, 4 print steps possibilities in grid, 5 print puzzles in grid

#define ERI(A)          (G[I].g[w[A][6]] | G[I].g[w[A][7]]) & (G[I].g[w[A][12]] | G[I].g[w[A][13]]) & \
                        ~(G[I].g[w[A][8]] | G[I].g[w[A][9]] | G[I].g[w[A][10]] | G[I].g[w[A][11]])
#define LN1(A, B, C, D) G[I].g[X = A] & G[I].g[Z = B] & \
                        ~(G[I].g[w[X][W[3][D]]] | G[I].g[w[X][W[4][D]]] | \
                        G[I].g[w[Z][W[3][D]]] | G[I].g[w[Z][W[4][D]]] | \
                        G[I].g[C] | G[I].g[w[C][W[3][D]]] | G[I].g[w[C][W[4][D]]])
#define LN3(A, B, C, D) G[I].g[X = A] & (G[I].g[Z = B] | \
                        G[I].g[w[Z][W[3][D]]] | G[I].g[w[Z][W[4][D]]]) & \
                        ~(G[I].g[w[X][W[3][D]]] | G[I].g[w[X][W[4][D]]] | \
                        G[I].g[C] | G[I].g[w[C][W[3][D]]] | G[I].g[w[C][W[4][D]]])
#define LB3(A, B, C, D) (G[I].g[X = A] | G[I].g[w[X][W[3][D]]] | G[I].g[w[X][W[4][D]]]) & \
                        (G[I].g[Z = B] | G[I].g[w[Z][W[3][D]]] | G[I].g[w[Z][W[4][D]]]) & \
                        ~(G[I].g[C] | G[I].g[w[C][W[3][D]]] | G[I].g[w[C][W[4][D]]])
#define COL(A)          b[(A) & 511]
#if RJ > 2
#define RCB             y < 9 ? "Row" : y < 18 ? "Column" : "Box"
#define LBN(A)          b[(y < 9 ? w[A][20] >> 18 : y < 18 ? w[A][20] : w[A][20] >> 9) & 511]
#define R_C             y ? "Column" : "Row"
#define RCN(A)          b[(y ? w[A][20] : w[A][20] >> 18) & 511]
#define BOX(A)          b[(w[A][20] >> 9) & 511]
#define ROW(A)          b[((A) >> 18) & 511]

static const char *S[81] = {
  "r1c1", "r1c2", "r1c3", "r1c4", "r1c5", "r1c6", "r1c7", "r1c8", "r1c9",
  "r2c1", "r2c2", "r2c3", "r2c4", "r2c5", "r2c6", "r2c7", "r2c8", "r2c9",
  "r3c1", "r3c2", "r3c3", "r3c4", "r3c5", "r3c6", "r3c7", "r3c8", "r3c9",
  "r4c1", "r4c2", "r4c3", "r4c4", "r4c5", "r4c6", "r4c7", "r4c8", "r4c9",
  "r5c1", "r5c2", "r5c3", "r5c4", "r5c5", "r5c6", "r5c7", "r5c8", "r5c9",
  "r6c1", "r6c2", "r6c3", "r6c4", "r6c5", "r6c6", "r6c7", "r6c8", "r6c9",
  "r7c1", "r7c2", "r7c3", "r7c4", "r7c5", "r7c6", "r7c7", "r7c8", "r7c9",
  "r8c1", "r8c2", "r8c3", "r8c4", "r8c5", "r8c6", "r8c7", "r8c8", "r8c9",
  "r9c1", "r9c2", "r9c3", "r9c4", "r9c5", "r9c6", "r9c7", "r9c8", "r9c9"};
#endif

struct
{
  int p,                     // Pointer to current unsolved Cell position
      s[81],                 // Sudoku clues and solved Cell Grid wise
      g[81];                 // Bitwise unsolved Cell values Grid wise
} G[50];

int I,                       // Iteration/Guess Depth
    q = 0,                   // Number of unsolved Cell positions Grid wise
    r[81],                   // Used for sorting and removing each unsolved Cell positions Grid wise
    n[9];                    // Number of Naked singles, Hidden singles, Guesses and Depth Grid wise, solved without guess, maximum guess and depth, number of possibilities

static const int b[512] = {  // Bitwise to digit Cell values
          0,        1,        2,       12,        3,       13,       23,      123,
          4,       14,       24,      124,       34,      134,      234,     1234,
          5,       15,       25,      125,       35,      135,      235,     1235,
         45,      145,      245,     1245,      345,     1345,     2345,    12345,
          6,       16,       26,      126,       36,      136,      236,     1236,
         46,      146,      246,     1246,      346,     1346,     2346,    12346,
         56,      156,      256,     1256,      356,     1356,     2356,    12356,
        456,     1456,     2456,    12456,     3456,    13456,    23456,   123456,
          7,       17,       27,      127,       37,      137,      237,     1237,
         47,      147,      247,     1247,      347,     1347,     2347,    12347,
         57,      157,      257,     1257,      357,     1357,     2357,    12357,
        457,     1457,     2457,    12457,     3457,    13457,    23457,   123457,
         67,      167,      267,     1267,      367,     1367,     2367,    12367,
        467,     1467,     2467,    12467,     3467,    13467,    23467,   123467,
        567,     1567,     2567,    12567,     3567,    13567,    23567,   123567,
       4567,    14567,    24567,   124567,    34567,   134567,   234567,  1234567,
          8,       18,       28,      128,       38,      138,      238,     1238,
         48,      148,      248,     1248,      348,     1348,     2348,    12348,
         58,      158,      258,     1258,      358,     1358,     2358,    12358,
        458,     1458,     2458,    12458,     3458,    13458,    23458,   123458,
         68,      168,      268,     1268,      368,     1368,     2368,    12368,
        468,     1468,     2468,    12468,     3468,    13468,    23468,   123468,
        568,     1568,     2568,    12568,     3568,    13568,    23568,   123568,
       4568,    14568,    24568,   124568,    34568,   134568,   234568,  1234568,
         78,      178,      278,     1278,      378,     1378,     2378,    12378,
        478,     1478,     2478,    12478,     3478,    13478,    23478,   123478,
        578,     1578,     2578,    12578,     3578,    13578,    23578,   123578,
       4578,    14578,    24578,   124578,    34578,   134578,   234578,  1234578,
        678,     1678,     2678,    12678,     3678,    13678,    23678,   123678,
       4678,    14678,    24678,   124678,    34678,   134678,   234678,  1234678,
       5678,    15678,    25678,   125678,    35678,   135678,   235678,  1235678,
      45678,   145678,   245678,  1245678,   345678,  1345678,  2345678, 12345678,
          9,       19,       29,      129,       39,      139,      239,     1239,
         49,      149,      249,     1249,      349,     1349,     2349,    12349,
         59,      159,      259,     1259,      359,     1359,     2359,    12359,
        459,     1459,     2459,    12459,     3459,    13459,    23459,   123459,
         69,      169,      269,     1269,      369,     1369,     2369,    12369,
        469,     1469,     2469,    12469,     3469,    13469,    23469,   123469,
        569,     1569,     2569,    12569,     3569,    13569,    23569,   123569,
       4569,    14569,    24569,   124569,    34569,   134569,   234569,  1234569,
         79,      179,      279,     1279,      379,     1379,     2379,    12379,
        479,     1479,     2479,    12479,     3479,    13479,    23479,   123479,
        579,     1579,     2579,    12579,     3579,    13579,    23579,   123579,
       4579,    14579,    24579,   124579,    34579,   134579,   234579,  1234579,
        679,     1679,     2679,    12679,     3679,    13679,    23679,   123679,
       4679,    14679,    24679,   124679,    34679,   134679,   234679,  1234679,
       5679,    15679,    25679,   125679,    35679,   135679,   235679,  1235679,
      45679,   145679,   245679,  1245679,   345679,  1345679,  2345679, 12345679,
         89,      189,      289,     1289,      389,     1389,     2389,    12389,
        489,     1489,     2489,    12489,     3489,    13489,    23489,   123489,
        589,     1589,     2589,    12589,     3589,    13589,    23589,   123589,
       4589,    14589,    24589,   124589,    34589,   134589,   234589,  1234589,
        689,     1689,     2689,    12689,     3689,    13689,    23689,   123689,
       4689,    14689,    24689,   124689,    34689,   134689,   234689,  1234689,
       5689,    15689,    25689,   125689,    35689,   135689,   235689,  1235689,
      45689,   145689,   245689,  1245689,   345689,  1345689,  2345689, 12345689,
        789,     1789,     2789,    12789,     3789,    13789,    23789,   123789,
       4789,    14789,    24789,   124789,    34789,   134789,   234789,  1234789,
       5789,    15789,    25789,   125789,    35789,   135789,   235789,  1235789,
      45789,   145789,   245789,  1245789,   345789,  1345789,  2345789, 12345789,
       6789,    16789,    26789,   126789,    36789,   136789,   236789,  1236789,
      46789,   146789,   246789,  1246789,   346789,  1346789,  2346789, 12346789,
      56789,   156789,   256789,  1256789,   356789,  1356789,  2356789, 12356789,
     456789,  1456789,  2456789, 12456789,  3456789, 13456789, 23456789,123456789},
           B[513] = {        // Count bitwise Cell values
   0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
   4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
   5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9,10},
           w[81][21] = {     // 20 peer Cell positions; and Band, Stack, Row, Box and Column for 81 Cell positions
  { 3, 4, 5, 6, 7, 8, 1, 2,10,11,19,20, 9,18,27,36,45,54,63,72,    262657},
  { 3, 4, 5, 6, 7, 8, 0, 2, 9,11,18,20,10,19,28,37,46,55,64,73,    262658},
  { 3, 4, 5, 6, 7, 8, 0, 1, 9,10,18,19,11,20,29,38,47,56,65,74,    262660},
  { 0, 1, 2, 6, 7, 8, 4, 5,13,14,22,23,12,21,30,39,48,57,66,75, 134480904},
  { 0, 1, 2, 6, 7, 8, 3, 5,12,14,21,23,13,22,31,40,49,58,67,76, 134480912},
  { 0, 1, 2, 6, 7, 8, 3, 4,12,13,21,22,14,23,32,41,50,59,68,77, 134480928},
  { 0, 1, 2, 3, 4, 5, 7, 8,16,17,25,26,15,24,33,42,51,60,69,78, 268699712},
  { 0, 1, 2, 3, 4, 5, 6, 8,15,17,24,26,16,25,34,43,52,61,70,79, 268699776},
  { 0, 1, 2, 3, 4, 5, 6, 7,15,16,24,25,17,26,35,44,53,62,71,80, 268699904},
  {12,13,14,15,16,17,10,11, 1, 2,19,20, 0,18,27,36,45,54,63,72,    524801},
  {12,13,14,15,16,17, 9,11, 0, 2,18,20, 1,19,28,37,46,55,64,73,    524802},
  {12,13,14,15,16,17, 9,10, 0, 1,18,19, 2,20,29,38,47,56,65,74,    524804},
  { 9,10,11,15,16,17,13,14, 4, 5,22,23, 3,21,30,39,48,57,66,75, 134743048},
  { 9,10,11,15,16,17,12,14, 3, 5,21,23, 4,22,31,40,49,58,67,76, 134743056},
  { 9,10,11,15,16,17,12,13, 3, 4,21,22, 5,23,32,41,50,59,68,77, 134743072},
  { 9,10,11,12,13,14,16,17, 7, 8,25,26, 6,24,33,42,51,60,69,78, 268961856},
  { 9,10,11,12,13,14,15,17, 6, 8,24,26, 7,25,34,43,52,61,70,79, 268961920},
  { 9,10,11,12,13,14,15,16, 6, 7,24,25, 8,26,35,44,53,62,71,80, 268962048},
  {21,22,23,24,25,26,19,20, 1, 2,10,11, 0, 9,27,36,45,54,63,72,   1049089},
  {21,22,23,24,25,26,18,20, 0, 2, 9,11, 1,10,28,37,46,55,64,73,   1049090},
  {21,22,23,24,25,26,18,19, 0, 1, 9,10, 2,11,29,38,47,56,65,74,   1049092},
  {18,19,20,24,25,26,22,23, 4, 5,13,14, 3,12,30,39,48,57,66,75, 135267336},
  {18,19,20,24,25,26,21,23, 3, 5,12,14, 4,13,31,40,49,58,67,76, 135267344},
  {18,19,20,24,25,26,21,22, 3, 4,12,13, 5,14,32,41,50,59,68,77, 135267360},
  {18,19,20,21,22,23,25,26, 7, 8,16,17, 6,15,33,42,51,60,69,78, 269486144},
  {18,19,20,21,22,23,24,26, 6, 8,15,17, 7,16,34,43,52,61,70,79, 269486208},
  {18,19,20,21,22,23,24,25, 6, 7,15,16, 8,17,35,44,53,62,71,80, 269486336},
  {30,31,32,33,34,35,28,29,37,38,46,47,36,45, 0, 9,18,54,63,72, 538972161},
  {30,31,32,33,34,35,27,29,36,38,45,47,37,46, 1,10,19,55,64,73, 538972162},
  {30,31,32,33,34,35,27,28,36,37,45,46,38,47, 2,11,20,56,65,74, 538972164},
  {27,28,29,33,34,35,31,32,40,41,49,50,39,48, 3,12,21,57,66,75, 673193992},
  {27,28,29,33,34,35,30,32,39,41,48,50,40,49, 4,13,22,58,67,76, 673194000},
  {27,28,29,33,34,35,30,31,39,40,48,49,41,50, 5,14,23,59,68,77, 673194016},
  {27,28,29,30,31,32,34,35,43,44,52,53,42,51, 6,15,24,60,69,78, 807419968},
  {27,28,29,30,31,32,33,35,42,44,51,53,43,52, 7,16,25,61,70,79, 807420032},
  {27,28,29,30,31,32,33,34,42,43,51,52,44,53, 8,17,26,62,71,80, 807420160},
  {39,40,41,42,43,44,37,38,28,29,46,47,27,45, 0, 9,18,54,63,72, 541069313},
  {39,40,41,42,43,44,36,38,27,29,45,47,28,46, 1,10,19,55,64,73, 541069314},
  {39,40,41,42,43,44,36,37,27,28,45,46,29,47, 2,11,20,56,65,74, 541069316},
  {36,37,38,42,43,44,40,41,31,32,49,50,30,48, 3,12,21,57,66,75, 675291144},
  {36,37,38,42,43,44,39,41,30,32,48,50,31,49, 4,13,22,58,67,76, 675291152},
  {36,37,38,42,43,44,39,40,30,31,48,49,32,50, 5,14,23,59,68,77, 675291168},
  {36,37,38,39,40,41,43,44,34,35,52,53,33,51, 6,15,24,60,69,78, 809517120},
  {36,37,38,39,40,41,42,44,33,35,51,53,34,52, 7,16,25,61,70,79, 809517184},
  {36,37,38,39,40,41,42,43,33,34,51,52,35,53, 8,17,26,62,71,80, 809517312},
  {48,49,50,51,52,53,46,47,28,29,37,38,27,36, 0, 9,18,54,63,72, 545263617},
  {48,49,50,51,52,53,45,47,27,29,36,38,28,37, 1,10,19,55,64,73, 545263618},
  {48,49,50,51,52,53,45,46,27,28,36,37,29,38, 2,11,20,56,65,74, 545263620},
  {45,46,47,51,52,53,49,50,31,32,40,41,30,39, 3,12,21,57,66,75, 679485448},
  {45,46,47,51,52,53,48,50,30,32,39,41,31,40, 4,13,22,58,67,76, 679485456},
  {45,46,47,51,52,53,48,49,30,31,39,40,32,41, 5,14,23,59,68,77, 679485472},
  {45,46,47,48,49,50,52,53,34,35,43,44,33,42, 6,15,24,60,69,78, 813711424},
  {45,46,47,48,49,50,51,53,33,35,42,44,34,43, 7,16,25,61,70,79, 813711488},
  {45,46,47,48,49,50,51,52,33,34,42,43,35,44, 8,17,26,62,71,80, 813711616},
  {57,58,59,60,61,62,55,56,64,65,73,74,63,72, 0, 9,18,27,36,45,1090551809},
  {57,58,59,60,61,62,54,56,63,65,72,74,64,73, 1,10,19,28,37,46,1090551810},
  {57,58,59,60,61,62,54,55,63,64,72,73,65,74, 2,11,20,29,38,47,1090551812},
  {54,55,56,60,61,62,58,59,67,68,76,77,66,75, 3,12,21,30,39,48,1224802312},
  {54,55,56,60,61,62,57,59,66,68,75,77,67,76, 4,13,22,31,40,49,1224802320},
  {54,55,56,60,61,62,57,58,66,67,75,76,68,77, 5,14,23,32,41,50,1224802336},
  {54,55,56,57,58,59,61,62,70,71,79,80,69,78, 6,15,24,33,42,51,1359085632},
  {54,55,56,57,58,59,60,62,69,71,78,80,70,79, 7,16,25,34,43,52,1359085696},
  {54,55,56,57,58,59,60,61,69,70,78,79,71,80, 8,17,26,35,44,53,1359085824},
  {66,67,68,69,70,71,64,65,55,56,73,74,54,72, 0, 9,18,27,36,45,1107329025},
  {66,67,68,69,70,71,63,65,54,56,72,74,55,73, 1,10,19,28,37,46,1107329026},
  {66,67,68,69,70,71,63,64,54,55,72,73,56,74, 2,11,20,29,38,47,1107329028},
  {63,64,65,69,70,71,67,68,58,59,76,77,57,75, 3,12,21,30,39,48,1241579528},
  {63,64,65,69,70,71,66,68,57,59,75,77,58,76, 4,13,22,31,40,49,1241579536},
  {63,64,65,69,70,71,66,67,57,58,75,76,59,77, 5,14,23,32,41,50,1241579552},
  {63,64,65,66,67,68,70,71,61,62,79,80,60,78, 6,15,24,33,42,51,1375862848},
  {63,64,65,66,67,68,69,71,60,62,78,80,61,79, 7,16,25,34,43,52,1375862912},
  {63,64,65,66,67,68,69,70,60,61,78,79,62,80, 8,17,26,35,44,53,1375863040},
  {75,76,77,78,79,80,73,74,55,56,64,65,54,63, 0, 9,18,27,36,45,1140883457},
  {75,76,77,78,79,80,72,74,54,56,63,65,55,64, 1,10,19,28,37,46,1140883458},
  {75,76,77,78,79,80,72,73,54,55,63,64,56,65, 2,11,20,29,38,47,1140883460},
  {72,73,74,78,79,80,76,77,58,59,67,68,57,66, 3,12,21,30,39,48,1275133960},
  {72,73,74,78,79,80,75,77,57,59,66,68,58,67, 4,13,22,31,40,49,1275133968},
  {72,73,74,78,79,80,75,76,57,58,66,67,59,68, 5,14,23,32,41,50,1275133984},
  {72,73,74,75,76,77,79,80,61,62,70,71,60,69, 6,15,24,33,42,51,1409417280},
  {72,73,74,75,76,77,78,80,60,62,69,71,61,70, 7,16,25,34,43,52,1409417344},
  {72,73,74,75,76,77,78,79,60,61,69,70,62,71, 8,17,26,35,44,53,1409417472}},
           l[27][9] = {      // 9 Cell positions for 27 Units
  { 0, 1, 2, 3, 4, 5, 6, 7, 8}, { 9,10,11,12,13,14,15,16,17}, {18,19,20,21,22,23,24,25,26},
  {27,28,29,30,31,32,33,34,35}, {36,37,38,39,40,41,42,43,44}, {45,46,47,48,49,50,51,52,53},
  {54,55,56,57,58,59,60,61,62}, {63,64,65,66,67,68,69,70,71}, {72,73,74,75,76,77,78,79,80},
  { 0, 9,18,27,36,45,54,63,72}, { 1,10,19,28,37,46,55,64,73}, { 2,11,20,29,38,47,56,65,74},
  { 3,12,21,30,39,48,57,66,75}, { 4,13,22,31,40,49,58,67,76}, { 5,14,23,32,41,50,59,68,77},
  { 6,15,24,33,42,51,60,69,78}, { 7,16,25,34,43,52,61,70,79}, { 8,17,26,35,44,53,62,71,80},
  { 0, 1, 2, 9,10,11,18,19,20}, { 3, 4, 5,12,13,14,21,22,23}, { 6, 7, 8,15,16,17,24,25,26},
  {27,28,29,36,37,38,45,46,47}, {30,31,32,39,40,41,48,49,50}, {33,34,35,42,43,44,51,52,53},
  {54,55,56,63,64,65,72,73,74}, {57,58,59,66,67,68,75,76,77}, {60,61,62,69,70,71,78,79,80}},
           h[246][9] = {     // 36 pairs/84 triplets/126 quads and other Cell positions Unit wise
  { 0, 1, 2, 3, 4, 5, 6, 7, 8}, { 0, 2, 1, 3, 4, 5, 6, 7, 8}, { 0, 3, 1, 2, 4, 5, 6, 7, 8},
  { 0, 4, 1, 2, 3, 5, 6, 7, 8}, { 0, 5, 1, 2, 3, 4, 6, 7, 8}, { 0, 6, 1, 2, 3, 4, 5, 7, 8},
  { 0, 7, 1, 2, 3, 4, 5, 6, 8}, { 0, 8, 1, 2, 3, 4, 5, 6, 7}, { 1, 2, 0, 3, 4, 5, 6, 7, 8},
  { 1, 3, 0, 2, 4, 5, 6, 7, 8}, { 1, 4, 0, 2, 3, 5, 6, 7, 8}, { 1, 5, 0, 2, 3, 4, 6, 7, 8},
  { 1, 6, 0, 2, 3, 4, 5, 7, 8}, { 1, 7, 0, 2, 3, 4, 5, 6, 8}, { 1, 8, 0, 2, 3, 4, 5, 6, 7},
  { 2, 3, 0, 1, 4, 5, 6, 7, 8}, { 2, 4, 0, 1, 3, 5, 6, 7, 8}, { 2, 5, 0, 1, 3, 4, 6, 7, 8},
  { 2, 6, 0, 1, 3, 4, 5, 7, 8}, { 2, 7, 0, 1, 3, 4, 5, 6, 8}, { 2, 8, 0, 1, 3, 4, 5, 6, 7},
  { 3, 4, 0, 1, 2, 5, 6, 7, 8}, { 3, 5, 0, 1, 2, 4, 6, 7, 8}, { 3, 6, 0, 1, 2, 4, 5, 7, 8},
  { 3, 7, 0, 1, 2, 4, 5, 6, 8}, { 3, 8, 0, 1, 2, 4, 5, 6, 7}, { 4, 5, 0, 1, 2, 3, 6, 7, 8},
  { 4, 6, 0, 1, 2, 3, 5, 7, 8}, { 4, 7, 0, 1, 2, 3, 5, 6, 8}, { 4, 8, 0, 1, 2, 3, 5, 6, 7},
  { 5, 6, 0, 1, 2, 3, 4, 7, 8}, { 5, 7, 0, 1, 2, 3, 4, 6, 8}, { 5, 8, 0, 1, 2, 3, 4, 6, 7},
  { 6, 7, 0, 1, 2, 3, 4, 5, 8}, { 6, 8, 0, 1, 2, 3, 4, 5, 7}, { 7, 8, 0, 1, 2, 3, 4, 5, 6},
  { 0, 1, 2, 3, 4, 5, 6, 7, 8}, { 0, 1, 3, 2, 4, 5, 6, 7, 8}, { 0, 1, 4, 2, 3, 5, 6, 7, 8},
  { 0, 1, 5, 2, 3, 4, 6, 7, 8}, { 0, 1, 6, 2, 3, 4, 5, 7, 8}, { 0, 1, 7, 2, 3, 4, 5, 6, 8},
  { 0, 1, 8, 2, 3, 4, 5, 6, 7}, { 0, 2, 3, 1, 4, 5, 6, 7, 8}, { 0, 2, 4, 1, 3, 5, 6, 7, 8},
  { 0, 2, 5, 1, 3, 4, 6, 7, 8}, { 0, 2, 6, 1, 3, 4, 5, 7, 8}, { 0, 2, 7, 1, 3, 4, 5, 6, 8},
  { 0, 2, 8, 1, 3, 4, 5, 6, 7}, { 0, 3, 4, 1, 2, 5, 6, 7, 8}, { 0, 3, 5, 1, 2, 4, 6, 7, 8},
  { 0, 3, 6, 1, 2, 4, 5, 7, 8}, { 0, 3, 7, 1, 2, 4, 5, 6, 8}, { 0, 3, 8, 1, 2, 4, 5, 6, 7},
  { 0, 4, 5, 1, 2, 3, 6, 7, 8}, { 0, 4, 6, 1, 2, 3, 5, 7, 8}, { 0, 4, 7, 1, 2, 3, 5, 6, 8},
  { 0, 4, 8, 1, 2, 3, 5, 6, 7}, { 0, 5, 6, 1, 2, 3, 4, 7, 8}, { 0, 5, 7, 1, 2, 3, 4, 6, 8},
  { 0, 5, 8, 1, 2, 3, 4, 6, 7}, { 0, 6, 7, 1, 2, 3, 4, 5, 8}, { 0, 6, 8, 1, 2, 3, 4, 5, 7},
  { 0, 7, 8, 1, 2, 3, 4, 5, 6}, { 1, 2, 3, 0, 4, 5, 6, 7, 8}, { 1, 2, 4, 0, 3, 5, 6, 7, 8},
  { 1, 2, 5, 0, 3, 4, 6, 7, 8}, { 1, 2, 6, 0, 3, 4, 5, 7, 8}, { 1, 2, 7, 0, 3, 4, 5, 6, 8},
  { 1, 2, 8, 0, 3, 4, 5, 6, 7}, { 1, 3, 4, 0, 2, 5, 6, 7, 8}, { 1, 3, 5, 0, 2, 4, 6, 7, 8},
  { 1, 3, 6, 0, 2, 4, 5, 7, 8}, { 1, 3, 7, 0, 2, 4, 5, 6, 8}, { 1, 3, 8, 0, 2, 4, 5, 6, 7},
  { 1, 4, 5, 0, 2, 3, 6, 7, 8}, { 1, 4, 6, 0, 2, 3, 5, 7, 8}, { 1, 4, 7, 0, 2, 3, 5, 6, 8},
  { 1, 4, 8, 0, 2, 3, 5, 6, 7}, { 1, 5, 6, 0, 2, 3, 4, 7, 8}, { 1, 5, 7, 0, 2, 3, 4, 6, 8},
  { 1, 5, 8, 0, 2, 3, 4, 6, 7}, { 1, 6, 7, 0, 2, 3, 4, 5, 8}, { 1, 6, 8, 0, 2, 3, 4, 5, 7},
  { 1, 7, 8, 0, 2, 3, 4, 5, 6}, { 2, 3, 4, 0, 1, 5, 6, 7, 8}, { 2, 3, 5, 0, 1, 4, 6, 7, 8},
  { 2, 3, 6, 0, 1, 4, 5, 7, 8}, { 2, 3, 7, 0, 1, 4, 5, 6, 8}, { 2, 3, 8, 0, 1, 4, 5, 6, 7},
  { 2, 4, 5, 0, 1, 3, 6, 7, 8}, { 2, 4, 6, 0, 1, 3, 5, 7, 8}, { 2, 4, 7, 0, 1, 3, 5, 6, 8},
  { 2, 4, 8, 0, 1, 3, 5, 6, 7}, { 2, 5, 6, 0, 1, 3, 4, 7, 8}, { 2, 5, 7, 0, 1, 3, 4, 6, 8},
  { 2, 5, 8, 0, 1, 3, 4, 6, 7}, { 2, 6, 7, 0, 1, 3, 4, 5, 8}, { 2, 6, 8, 0, 1, 3, 4, 5, 7},
  { 2, 7, 8, 0, 1, 3, 4, 5, 6}, { 3, 4, 5, 0, 1, 2, 6, 7, 8}, { 3, 4, 6, 0, 1, 2, 5, 7, 8},
  { 3, 4, 7, 0, 1, 2, 5, 6, 8}, { 3, 4, 8, 0, 1, 2, 5, 6, 7}, { 3, 5, 6, 0, 1, 2, 4, 7, 8},
  { 3, 5, 7, 0, 1, 2, 4, 6, 8}, { 3, 5, 8, 0, 1, 2, 4, 6, 7}, { 3, 6, 7, 0, 1, 2, 4, 5, 8},
  { 3, 6, 8, 0, 1, 2, 4, 5, 7}, { 3, 7, 8, 0, 1, 2, 4, 5, 6}, { 4, 5, 6, 0, 1, 2, 3, 7, 8},
  { 4, 5, 7, 0, 1, 2, 3, 6, 8}, { 4, 5, 8, 0, 1, 2, 3, 6, 7}, { 4, 6, 7, 0, 1, 2, 3, 5, 8},
  { 4, 6, 8, 0, 1, 2, 3, 5, 7}, { 4, 7, 8, 0, 1, 2, 3, 5, 6}, { 5, 6, 7, 0, 1, 2, 3, 4, 8},
  { 5, 6, 8, 0, 1, 2, 3, 4, 7}, { 5, 7, 8, 0, 1, 2, 3, 4, 6}, { 6, 7, 8, 0, 1, 2, 3, 4, 5},
  { 0, 1, 2, 3, 4, 5, 6, 7, 8}, { 0, 1, 2, 4, 3, 5, 6, 7, 8}, { 0, 1, 2, 5, 3, 4, 6, 7, 8},
  { 0, 1, 2, 6, 3, 4, 5, 7, 8}, { 0, 1, 2, 7, 3, 4, 5, 6, 8}, { 0, 1, 2, 8, 3, 4, 5, 6, 7},
  { 0, 1, 3, 4, 2, 5, 6, 7, 8}, { 0, 1, 3, 5, 2, 4, 6, 7, 8}, { 0, 1, 3, 6, 2, 4, 5, 7, 8},
  { 0, 1, 3, 7, 2, 4, 5, 6, 8}, { 0, 1, 3, 8, 2, 4, 5, 6, 7}, { 0, 1, 4, 5, 2, 3, 6, 7, 8},
  { 0, 1, 4, 6, 2, 3, 5, 7, 8}, { 0, 1, 4, 7, 2, 3, 5, 6, 8}, { 0, 1, 4, 8, 2, 3, 5, 6, 7},
  { 0, 1, 5, 6, 2, 3, 4, 7, 8}, { 0, 1, 5, 7, 2, 3, 4, 6, 8}, { 0, 1, 5, 8, 2, 3, 4, 6, 7},
  { 0, 1, 6, 7, 2, 3, 4, 5, 8}, { 0, 1, 6, 8, 2, 3, 4, 5, 7}, { 0, 1, 7, 8, 2, 3, 4, 5, 6},
  { 0, 2, 3, 4, 1, 5, 6, 7, 8}, { 0, 2, 3, 5, 1, 4, 6, 7, 8}, { 0, 2, 3, 6, 1, 4, 5, 7, 8},
  { 0, 2, 3, 7, 1, 4, 5, 6, 8}, { 0, 2, 3, 8, 1, 4, 5, 6, 7}, { 0, 2, 4, 5, 1, 3, 6, 7, 8},
  { 0, 2, 4, 6, 1, 3, 5, 7, 8}, { 0, 2, 4, 7, 1, 3, 5, 6, 8}, { 0, 2, 4, 8, 1, 3, 5, 6, 7},
  { 0, 2, 5, 6, 1, 3, 4, 7, 8}, { 0, 2, 5, 7, 1, 3, 4, 6, 8}, { 0, 2, 5, 8, 1, 3, 4, 6, 7},
  { 0, 2, 6, 7, 1, 3, 4, 5, 8}, { 0, 2, 6, 8, 1, 3, 4, 5, 7}, { 0, 2, 7, 8, 1, 3, 4, 5, 6},
  { 0, 3, 4, 5, 1, 2, 6, 7, 8}, { 0, 3, 4, 6, 1, 2, 5, 7, 8}, { 0, 3, 4, 7, 1, 2, 5, 6, 8},
  { 0, 3, 4, 8, 1, 2, 5, 6, 7}, { 0, 3, 5, 6, 1, 2, 4, 7, 8}, { 0, 3, 5, 7, 1, 2, 4, 6, 8},
  { 0, 3, 5, 8, 1, 2, 4, 6, 7}, { 0, 3, 6, 7, 1, 2, 4, 5, 8}, { 0, 3, 6, 8, 1, 2, 4, 5, 7},
  { 0, 3, 7, 8, 1, 2, 4, 5, 6}, { 0, 4, 5, 6, 1, 2, 3, 7, 8}, { 0, 4, 5, 7, 1, 2, 3, 6, 8},
  { 0, 4, 5, 8, 1, 2, 3, 6, 7}, { 0, 4, 6, 7, 1, 2, 3, 5, 8}, { 0, 4, 6, 8, 1, 2, 3, 5, 7},
  { 0, 4, 7, 8, 1, 2, 3, 5, 6}, { 0, 5, 6, 7, 1, 2, 3, 4, 8}, { 0, 5, 6, 8, 1, 2, 3, 4, 7},
  { 0, 5, 7, 8, 1, 2, 3, 4, 6}, { 0, 6, 7, 8, 1, 2, 3, 4, 5}, { 1, 2, 3, 4, 0, 5, 6, 7, 8},
  { 1, 2, 3, 5, 0, 4, 6, 7, 8}, { 1, 2, 3, 6, 0, 4, 5, 7, 8}, { 1, 2, 3, 7, 0, 4, 5, 6, 8},
  { 1, 2, 3, 8, 0, 4, 5, 6, 7}, { 1, 2, 4, 5, 0, 3, 6, 7, 8}, { 1, 2, 4, 6, 0, 3, 5, 7, 8},
  { 1, 2, 4, 7, 0, 3, 5, 6, 8}, { 1, 2, 4, 8, 0, 3, 5, 6, 7}, { 1, 2, 5, 6, 0, 3, 4, 7, 8},
  { 1, 2, 5, 7, 0, 3, 4, 6, 8}, { 1, 2, 5, 8, 0, 3, 4, 6, 7}, { 1, 2, 6, 7, 0, 3, 4, 5, 8},
  { 1, 2, 6, 8, 0, 3, 4, 5, 7}, { 1, 2, 7, 8, 0, 3, 4, 5, 6}, { 1, 3, 4, 5, 0, 2, 6, 7, 8},
  { 1, 3, 4, 6, 0, 2, 5, 7, 8}, { 1, 3, 4, 7, 0, 2, 5, 6, 8}, { 1, 3, 4, 8, 0, 2, 5, 6, 7},
  { 1, 3, 5, 6, 0, 2, 4, 7, 8}, { 1, 3, 5, 7, 0, 2, 4, 6, 8}, { 1, 3, 5, 8, 0, 2, 4, 6, 7},
  { 1, 3, 6, 7, 0, 2, 4, 5, 8}, { 1, 3, 6, 8, 0, 2, 4, 5, 7}, { 1, 3, 7, 8, 0, 2, 4, 5, 6},
  { 1, 4, 5, 6, 0, 2, 3, 7, 8}, { 1, 4, 5, 7, 0, 2, 3, 6, 8}, { 1, 4, 5, 8, 0, 2, 3, 6, 7},
  { 1, 4, 6, 7, 0, 2, 3, 5, 8}, { 1, 4, 6, 8, 0, 2, 3, 5, 7}, { 1, 4, 7, 8, 0, 2, 3, 5, 6},
  { 1, 5, 6, 7, 0, 2, 3, 4, 8}, { 1, 5, 6, 8, 0, 2, 3, 4, 7}, { 1, 5, 7, 8, 0, 2, 3, 4, 6},
  { 1, 6, 7, 8, 0, 2, 3, 4, 5}, { 2, 3, 4, 5, 0, 1, 6, 7, 8}, { 2, 3, 4, 6, 0, 1, 5, 7, 8},
  { 2, 3, 4, 7, 0, 1, 5, 6, 8}, { 2, 3, 4, 8, 0, 1, 5, 6, 7}, { 2, 3, 5, 6, 0, 1, 4, 7, 8},
  { 2, 3, 5, 7, 0, 1, 4, 6, 8}, { 2, 3, 5, 8, 0, 1, 4, 6, 7}, { 2, 3, 6, 7, 0, 1, 4, 5, 8},
  { 2, 3, 6, 8, 0, 1, 4, 5, 7}, { 2, 3, 7, 8, 0, 1, 4, 5, 6}, { 2, 4, 5, 6, 0, 1, 3, 7, 8},
  { 2, 4, 5, 7, 0, 1, 3, 6, 8}, { 2, 4, 5, 8, 0, 1, 3, 6, 7}, { 2, 4, 6, 7, 0, 1, 3, 5, 8},
  { 2, 4, 6, 8, 0, 1, 3, 5, 7}, { 2, 4, 7, 8, 0, 1, 3, 5, 6}, { 2, 5, 6, 7, 0, 1, 3, 4, 8},
  { 2, 5, 6, 8, 0, 1, 3, 4, 7}, { 2, 5, 7, 8, 0, 1, 3, 4, 6}, { 2, 6, 7, 8, 0, 1, 3, 4, 5},
  { 3, 4, 5, 6, 0, 1, 2, 7, 8}, { 3, 4, 5, 7, 0, 1, 2, 6, 8}, { 3, 4, 5, 8, 0, 1, 2, 6, 7},
  { 3, 4, 6, 7, 0, 1, 2, 5, 8}, { 3, 4, 6, 8, 0, 1, 2, 5, 7}, { 3, 4, 7, 8, 0, 1, 2, 5, 6},
  { 3, 5, 6, 7, 0, 1, 2, 4, 8}, { 3, 5, 6, 8, 0, 1, 2, 4, 7}, { 3, 5, 7, 8, 0, 1, 2, 4, 6},
  { 3, 6, 7, 8, 0, 1, 2, 4, 5}, { 4, 5, 6, 7, 0, 1, 2, 3, 8}, { 4, 5, 6, 8, 0, 1, 2, 3, 7},
  { 4, 5, 7, 8, 0, 1, 2, 3, 6}, { 4, 6, 7, 8, 0, 1, 2, 3, 5}, { 5, 6, 7, 8, 0, 1, 2, 3, 4}},
           j[54][15] = {     // 3 Locked candidate Cell positions and 6 Line + 6 Box Cell peer positions for 54 mini-Lines
  { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,18,19,20},
  { 3, 4, 5, 0, 1, 2, 6, 7, 8,12,13,14,21,22,23},
  { 6, 7, 8, 0, 1, 2, 3, 4, 5,15,16,17,24,25,26},
  { 9,10,11,12,13,14,15,16,17, 0, 1, 2,18,19,20},
  {12,13,14, 9,10,11,15,16,17, 3, 4, 5,21,22,23},
  {15,16,17, 9,10,11,12,13,14, 6, 7, 8,24,25,26},
  {18,19,20,21,22,23,24,25,26, 0, 1, 2, 9,10,11},
  {21,22,23,18,19,20,24,25,26, 3, 4, 5,12,13,14},
  {24,25,26,18,19,20,21,22,23, 6, 7, 8,15,16,17},
  {27,28,29,30,31,32,33,34,35,36,37,38,45,46,47},
  {30,31,32,27,28,29,33,34,35,39,40,41,48,49,50},
  {33,34,35,27,28,29,30,31,32,42,43,44,51,52,53},
  {36,37,38,39,40,41,42,43,44,27,28,29,45,46,47},
  {39,40,41,36,37,38,42,43,44,30,31,32,48,49,50},
  {42,43,44,36,37,38,39,40,41,33,34,35,51,52,53},
  {45,46,47,48,49,50,51,52,53,27,28,29,36,37,38},
  {48,49,50,45,46,47,51,52,53,30,31,32,39,40,41},
  {51,52,53,45,46,47,48,49,50,33,34,35,42,43,44},
  {54,55,56,57,58,59,60,61,62,63,64,65,72,73,74},
  {57,58,59,54,55,56,60,61,62,66,67,68,75,76,77},
  {60,61,62,54,55,56,57,58,59,69,70,71,78,79,80},
  {63,64,65,66,67,68,69,70,71,54,55,56,72,73,74},
  {66,67,68,63,64,65,69,70,71,57,58,59,75,76,77},
  {69,70,71,63,64,65,66,67,68,60,61,62,78,79,80},
  {72,73,74,75,76,77,78,79,80,54,55,56,63,64,65},
  {75,76,77,72,73,74,78,79,80,57,58,59,66,67,68},
  {78,79,80,72,73,74,75,76,77,60,61,62,69,70,71},
  { 0, 9,18,27,36,45,54,63,72, 1, 2,10,11,19,20},
  {27,36,45, 0, 9,18,54,63,72,28,29,37,38,46,47},
  {54,63,72, 0, 9,18,27,36,45,55,56,64,65,73,74},
  { 1,10,19,28,37,46,55,64,73, 0, 2, 9,11,18,20},
  {28,37,46, 1,10,19,55,64,73,27,29,36,38,45,47},
  {55,64,73, 1,10,19,28,37,46,54,56,63,65,72,74},
  { 2,11,20,29,38,47,56,65,74, 0, 1, 9,10,18,19},
  {29,38,47, 2,11,20,56,65,74,27,28,36,37,45,46},
  {56,65,74, 2,11,20,29,38,47,54,55,63,64,72,73},
  { 3,12,21,30,39,48,57,66,75, 4, 5,13,14,22,23},
  {30,39,48, 3,12,21,57,66,75,31,32,40,41,49,50},
  {57,66,75, 3,12,21,30,39,48,58,59,67,68,76,77},
  { 4,13,22,31,40,49,58,67,76, 3, 5,12,14,21,23},
  {31,40,49, 4,13,22,58,67,76,30,32,39,41,48,50},
  {58,67,76, 4,13,22,31,40,49,57,59,66,68,75,77},
  { 5,14,23,32,41,50,59,68,77, 3, 4,12,13,21,22},
  {32,41,50, 5,14,23,59,68,77,30,31,39,40,48,49},
  {59,68,77, 5,14,23,32,41,50,57,58,66,67,75,76},
  { 6,15,24,33,42,51,60,69,78, 7, 8,16,17,25,26},
  {33,42,51, 6,15,24,60,69,78,34,35,43,44,52,53},
  {60,69,78, 6,15,24,33,42,51,61,62,70,71,79,80},
  { 7,16,25,34,43,52,61,70,79, 6, 8,15,17,24,26},
  {34,43,52, 7,16,25,61,70,79,33,35,42,44,51,53},
  {61,70,79, 7,16,25,34,43,52,60,62,69,71,78,80},
  { 8,17,26,35,44,53,62,71,80, 6, 7,15,16,24,25},
  {35,44,53, 8,17,26,62,71,80,33,34,42,43,51,52},
  {62,71,80, 8,17,26,35,44,53,60,61,69,70,78,79}},
           W[33][2] = {      // References used for Basics, Hybrid and Transport Wings
  {14,12}, { 0,14}, { 6,20}, { 6,12}, { 7,13}, { 3,17},
  { 8, 6}, { 9, 8}, {12,10}, {10, 7}, {11, 9}, {13,11},
  { 8, 9}, {10,11}, { 1, 3}, {511,133955584}, { 0, 4},
  { 0,12}, { 1,15}, { 2,16}, { 3,17}, { 4,18}, { 5,19},
  { 0, 8}, {12,20}, {402653184,1610612736}, { 3, 9},
  { 4,10}, { 5,11}, { 6,12}, { 7,13}, { 8,14}, { 9,15}};

#if RJ > 3
void prn (void)
{
  int a = 0,
      k[9] = {1, 1, 1, 1, 1, 1, 1, 1, 1};

  for (; a < 81; ++a)
    if (k[a % 9] < B[G[I].g[a]])
      k[a % 9] = B[G[I].g[a]];
  printf (" +%.*s+%.*s+%.*s+\n",
    k[0] + k[1] + k[2] + 6, "---------------------------------",
    k[3] + k[4] + k[5] + 6, "---------------------------------",
    k[6] + k[7] + k[8] + 6, "---------------------------------");
  for (a = 0; a < 81; ++a)
  {
    printf ("%s%-*d", a % 3 ? "  " : " | ", k[a % 9], b[G[I].g[a] | G[I].s[a]]);
    if ((a % 9) & 8)
    {
      printf (" |\n");
      if (a % 27 == 26)
        printf (" +%.*s+%.*s+%.*s+\n",
          k[0] + k[1] + k[2] + 6, "---------------------------------",
          k[3] + k[4] + k[5] + 6, "---------------------------------",
          k[6] + k[7] + k[8] + 6, "---------------------------------");
    }
  }
}
#endif

int solve ()
{
  int a,
      X,
      Y,
      Z,
      x,                     // Unsolved Cell position for least Cell values checking
      y = 0,                 // 0 = Naked single, 1 = Hidden Single and 2 = Trial & Error
      z = 0;

  while (1)
  {
START:
#if RJ > 3
    prn ();
#endif
    for (; y < 27; ++y)      // Check zero state Unit wise
    {
      if (511 ^ (G[I].s[l[y][0]] | G[I].s[l[y][1]] | G[I].s[l[y][2]] |
        G[I].s[l[y][3]] | G[I].s[l[y][4]] | G[I].s[l[y][5]] | G[I].s[l[y][6]] |
        G[I].s[l[y][7]] | G[I].s[l[y][8]] | G[I].g[l[y][0]] | G[I].g[l[y][1]] |
        G[I].g[l[y][2]] | G[I].g[l[y][3]] | G[I].g[l[y][4]] | G[I].g[l[y][5]] |
        G[I].g[l[y][6]] | G[I].g[l[y][7]] | G[I].g[l[y][8]]) ||
        !(G[I].s[l[y][0]] | G[I].g[l[y][0]]) || !(G[I].s[l[y][1]] | G[I].g[l[y][1]]) ||
        !(G[I].s[l[y][2]] | G[I].g[l[y][2]]) || !(G[I].s[l[y][3]] | G[I].g[l[y][3]]) ||
        !(G[I].s[l[y][4]] | G[I].g[l[y][4]]) || !(G[I].s[l[y][5]] | G[I].g[l[y][5]]) ||
        !(G[I].s[l[y][6]] | G[I].g[l[y][6]]) || !(G[I].s[l[y][7]] | G[I].g[l[y][7]]) ||
        !(G[I].s[l[y][8]] | G[I].g[l[y][8]]))
      {
#if RJ > 2
        printf ("%d) Zero state: %d @ %s %d\n", G[I].p,
          b[511 - (G[I].s[l[y][0]] | G[I].s[l[y][1]] | G[I].s[l[y][2]] |
          G[I].s[l[y][3]] | G[I].s[l[y][4]] | G[I].s[l[y][5]] |
          G[I].s[l[y][6]] | G[I].s[l[y][7]] | G[I].s[l[y][8]] |
          G[I].g[l[y][0]] | G[I].g[l[y][1]] | G[I].g[l[y][2]] |
          G[I].g[l[y][3]] | G[I].g[l[y][4]] | G[I].g[l[y][5]] |
          G[I].g[l[y][6]] | G[I].g[l[y][7]] | G[I].g[l[y][8]])], RCB, y % 9 + 1);
#endif
        if (I)
        {
          --I;
          --n[3];
#if RJ > 2
          printf ("%d%s) Undo Trial & Error: -%d @ %s from values %d\n",
            G[I].p + 1, G[I].p != 10 && !(G[I].p % 10) ? "st" :
            (G[I].p != 11 && G[I].p % 10 == 1 ? "nd" :
            (G[I].p != 12 && G[I].p % 10 == 2 ? "rd" : "th")),
            b[G[I + 1].s[r[G[I].p]]], S[r[G[I].p]], b[G[I].g[r[G[I].p]]]);
#endif
          G[I].g[r[G[I].p]] -= G[I + 1].s[r[G[I].p]];
#if RJ > 3
          prn ();
#endif
        }
        else
          return 0;          // Return for number of unsolved Cell positions not equal to number of unsolved Cell values
      }
      for (Y = 1; Y < 257; Y <<= 1)
                             // Check Zero state digit wise
        if (Z = B[a = (G[I].g[l[y][0]] & Y ? 1 : 0) | (G[I].g[l[y][1]] & Y ? 2 : 0) |
          (G[I].g[l[y][2]] & Y ? 4 : 0) | (G[I].g[l[y][3]] & Y ? 8 : 0) |
          (G[I].g[l[y][4]] & Y ? 16 : 0) | (G[I].g[l[y][5]] & Y ? 32 : 0) |
          (G[I].g[l[y][6]] & Y ? 64 : 0) | (G[I].g[l[y][7]] & Y ? 128 : 0) |
          (G[I].g[l[y][8]] & Y ? 256 : 0)])
        {
          int A[9];

          for (X = 0; x = a & -a; ++X, a -= x)
          {
            A[X] = l[y][b[x] - 1];
            z |= G[I].g[A[X]];
          }
          if (Z > B[z])
          {
#if RJ > 2
            printf ("%d) Zero state: %d @", G[I].p, b[z]);
            while (X)
              printf (" %s", S[A[--X]]);
            printf (" in %s %d\n", RCB, y % 9 + 1);
#endif
            if (I)
            {
              --I;
              --n[3];
#if RJ > 2
              printf ("%d%s) Undo Trial & Error: -%d @ %s from values %d\n",
                G[I].p + 1, G[I].p != 10 && !(G[I].p % 10) ? "st" :
                (G[I].p != 11 && G[I].p % 10 == 1 ? "nd" :
                (G[I].p != 12 && G[I].p % 10 == 2 ? "rd" : "th")),
                b[G[I + 1].s[r[G[I].p]]], S[r[G[I].p]], b[G[I].g[r[G[I].p]]]);
#endif
              G[I].g[r[G[I].p]] -= G[I + 1].s[r[G[I].p]];
#if RJ > 3
              prn ();
#endif
            }
            else
              return 0;      // Return for number of unsolved Cell positions > total unsolved Cell values
          }
        }
    }
    for (a = G[I].p; a < q; ++a)
                             // Search Hidden single Cell value unsolved Cell positions wise
      if (Y = (((G[I].g[w[r[a]][0]] | G[I].g[w[r[a]][1]] | G[I].g[w[r[a]][2]] |
        G[I].g[w[r[a]][3]] | G[I].g[w[r[a]][4]] | G[I].g[w[r[a]][5]] |
        G[I].g[w[r[a]][6]] | G[I].g[w[r[a]][7]]) ^ G[I].g[r[a]]) |
        ((G[I].g[w[r[a]][6]] | G[I].g[w[r[a]][7]] | G[I].g[w[r[a]][8]] |
        G[I].g[w[r[a]][9]] | G[I].g[w[r[a]][10]] | G[I].g[w[r[a]][11]] |
        G[I].g[w[r[a]][12]] | G[I].g[w[r[a]][13]]) ^ G[I].g[r[a]]) |
        ((G[I].g[w[r[a]][12]] | G[I].g[w[r[a]][13]] | G[I].g[w[r[a]][14]] |
        G[I].g[w[r[a]][15]] | G[I].g[w[r[a]][16]] | G[I].g[w[r[a]][17]] |
        G[I].g[w[r[a]][18]] | G[I].g[w[r[a]][19]]) ^ G[I].g[r[a]])) & G[I].g[r[a]])
      {                      // Check for Hidden single Cell value found in unsolved Cell position
        x = a;               // Assign Hidden single Cell position
        z = Y;               // Assign Hidden single Cell value
        y = B[G[I].g[r[a]]] > 1;
        goto NHSCF;          // 1 Represent Hidden single Cell position
      }
    for (y = 0, z = 512, a = G[I].p; a < q; ++a)
                             // Search Naked single Cell value or Guess minimum Cell values unsolved Cell positions wise
      if (B[z] > B[G[I].g[r[a]]])
                             // Check least Cell values in current unsolved Cell position
        if (B[z = G[I].g[r[x = a]]] < 2)
          goto NHSCF;        // Naked single Cell value found in current unsolved Cell position
    for (a = 0; a < 54; ++a) // Search Locked candidate for 54 mini-Lines 3 Cell positions wise
      for (X = G[I].g[j[a][0]] | G[I].g[j[a][1]] | G[I].g[j[a][2]]; Y = X & -X; X -= Y)
                             // Search Box-Line 3 Cell positions Locked candidate wise
        if ((Z = (G[I].g[j[a][3]] | G[I].g[j[a][4]] | G[I].g[j[a][5]] |
          G[I].g[j[a][6]] | G[I].g[j[a][7]] | G[I].g[j[a][8]]) & Y) !=
                             // Check Locked candidate in either Line other Cell positions; or
          ((G[I].g[j[a][9]] | G[I].g[j[a][10]] | G[I].g[j[a][11]] |
          G[I].g[j[a][12]] | G[I].g[j[a][13]] | G[I].g[j[a][14]]) & Y))
        {                    // Locked candidate in Box other Cell positions
                             // Drop Locked candidate from Line/Box other Cell positions
          G[I].g[j[a][Z ? 3 : 9]] &= ~Y;
          G[I].g[j[a][Z ? 4 : 10]] &= ~Y;
          G[I].g[j[a][Z ? 5 : 11]] &= ~Y;
          G[I].g[j[a][Z ? 6 : 12]] &= ~Y;
          G[I].g[j[a][Z ? 7 : 13]] &= ~Y;
          G[I].g[j[a][Z ? 8 : 14]] &= ~Y;
#if RJ > 2
          printf ("%d) Locked candidate Type %sing): %d @ r%dc%d => -%d @ r%dc%d\n",
            G[I].p, Z ? "1 (Point" : "2 (Claim", b[Y],
            ROW (w[j[a][0]][20] | w[j[a][1]][20] | w[j[a][2]][20]),
            COL (w[j[a][0]][20] | w[j[a][1]][20] | w[j[a][2]][20]), b[Y],
            ROW (w[j[a][Z ? 3 : 9]][20] | w[j[a][Z ? 4 : 10]][20] | w[j[a][Z ? 5 : 11]][20] |
            w[j[a][Z ? 6 : 12]][20] | w[j[a][Z ? 7 : 13]][20] | w[j[a][Z ? 8 : 14]][20]),
            COL (w[j[a][Z ? 3 : 9]][20] | w[j[a][Z ? 4 : 10]][20] | w[j[a][Z ? 5 : 11]][20] |
            w[j[a][Z ? 6 : 12]][20] | w[j[a][Z ? 7 : 13]][20] | w[j[a][Z ? 8 : 14]][20]));
#endif
          goto START;
        }
    for (a = 0; a < 54; ++a) // Search Locked pair and Locked triplet for 54 mini-Lines 3 Cell positions wise
    {
      if (((G[I].g[j[a][1]] && G[I].g[j[a][2]] &&
        B[Y = G[I].g[j[a][1]] | G[I].g[j[a][2]]] == 2 && !(X = 0)) ||
        (G[I].g[j[a][0]] && G[I].g[j[a][2]] &&
        B[Y = G[I].g[j[a][0]] | G[I].g[j[a][2]]] == 2 && (X = 1)) ||
        (G[I].g[j[a][0]] && G[I].g[j[a][1]] &&
        B[Y = G[I].g[j[a][0]] | G[I].g[j[a][1]]] == 2 && (X = 2))) &&
        ((G[I].g[j[a][X]] | G[I].g[j[a][3]] | G[I].g[j[a][4]] |
        G[I].g[j[a][5]] | G[I].g[j[a][6]] | G[I].g[j[a][7]] | G[I].g[j[a][8]]) &
        (G[I].g[j[a][9]] | G[I].g[j[a][10]] | G[I].g[j[a][11]] |
        G[I].g[j[a][12]] | G[I].g[j[a][13]] | G[I].g[j[a][14]]) & Y))
      {                      // Locked pair found
        int k[13] = {G[I].g[j[a][X]], G[I].g[j[a][3]], G[I].g[j[a][4]],
                    G[I].g[j[a][5]], G[I].g[j[a][6]], G[I].g[j[a][7]], G[I].g[j[a][8]],
                    G[I].g[j[a][9]], G[I].g[j[a][10]], G[I].g[j[a][11]],
                    G[I].g[j[a][12]], G[I].g[j[a][13]], G[I].g[j[a][14]]};
                             // Backup and drop Locked pair Cell values from Units other Cell positions
        G[I].g[j[a][X]] &= ~Y;
        G[I].g[j[a][3]] &= ~Y;
        G[I].g[j[a][4]] &= ~Y;
        G[I].g[j[a][5]] &= ~Y;
        G[I].g[j[a][6]] &= ~Y;
        G[I].g[j[a][7]] &= ~Y;
        G[I].g[j[a][8]] &= ~Y;
        G[I].g[j[a][9]] &= ~Y;
        G[I].g[j[a][10]] &= ~Y;
        G[I].g[j[a][11]] &= ~Y;
        G[I].g[j[a][12]] &= ~Y;
        G[I].g[j[a][13]] &= ~Y;
        G[I].g[j[a][14]] &= ~Y;
#if RJ > 2
        printf ("%d) Locked pair: %d @ r%dc%d => -%d @ r%dc%d r%dc%d\n",
          G[I].p, b[Y], ROW (w[j[a][!X]][20] | w[j[a][X ? 3 - X : 2]][20]),
          COL (w[j[a][!X]][20] | w[j[a][X ? 3 - X : 2]][20]), b[Y],
          ROW (w[j[a][X]][20] | w[j[a][3]][20] | w[j[a][4]][20] |
          w[j[a][5]][20] | w[j[a][6]][20] | w[j[a][7]][20] | w[j[a][8]][20]),
          COL (w[j[a][X]][20] | w[j[a][3]][20] | w[j[a][4]][20] |
          w[j[a][5]][20] | w[j[a][6]][20] | w[j[a][7]][20] | w[j[a][8]][20]),
          ROW (w[j[a][9]][20] | w[j[a][10]][20] | w[j[a][11]][20] |
          w[j[a][12]][20] | w[j[a][13]][20] | w[j[a][14]][20]),
          COL (w[j[a][9]][20] | w[j[a][10]][20] | w[j[a][11]][20] |
          w[j[a][12]][20] | w[j[a][13]][20] | w[j[a][14]][20]));
#endif
        goto START;
      }
      if (G[I].g[j[a][0]] && G[I].g[j[a][1]] && G[I].g[j[a][2]] &&
        B[Y = G[I].g[j[a][0]] | G[I].g[j[a][1]] | G[I].g[j[a][2]]] == 3 &&
        ((G[I].g[j[a][3]] | G[I].g[j[a][4]] | G[I].g[j[a][5]] |
        G[I].g[j[a][6]] | G[I].g[j[a][7]] | G[I].g[j[a][8]]) &
        (G[I].g[j[a][9]] | G[I].g[j[a][10]] | G[I].g[j[a][11]] |
        G[I].g[j[a][12]] | G[I].g[j[a][13]] | G[I].g[j[a][14]]) & Y))
      {                      // Locked triplet found
        int k[12] = {G[I].g[j[a][3]], G[I].g[j[a][4]], G[I].g[j[a][5]], G[I].g[j[a][6]],
                    G[I].g[j[a][7]], G[I].g[j[a][8]], G[I].g[j[a][9]], G[I].g[j[a][10]],
                    G[I].g[j[a][11]], G[I].g[j[a][12]], G[I].g[j[a][13]], G[I].g[j[a][14]]};
                             // Backup and drop Locked triplet Cell values from Units other Cell positions
        G[I].g[j[a][3]] &= ~Y;
        G[I].g[j[a][4]] &= ~Y;
        G[I].g[j[a][5]] &= ~Y;
        G[I].g[j[a][6]] &= ~Y;
        G[I].g[j[a][7]] &= ~Y;
        G[I].g[j[a][8]] &= ~Y;
        G[I].g[j[a][9]] &= ~Y;
        G[I].g[j[a][10]] &= ~Y;
        G[I].g[j[a][11]] &= ~Y;
        G[I].g[j[a][12]] &= ~Y;
        G[I].g[j[a][13]] &= ~Y;
        G[I].g[j[a][14]] &= ~Y;
#if RJ > 2
        printf ("%d) Locked triplet: %d @ r%dc%d => -%d @ r%dc%d r%dc%d\n",
          G[I].p, b[Y], ROW (w[j[a][0]][20] | w[j[a][1]][20] | w[j[a][2]][20]),
          COL (w[j[a][0]][20] | w[j[a][1]][20] | w[j[a][2]][20]), b[Y],
          ROW (w[j[a][3]][20] | w[j[a][4]][20] | w[j[a][5]][20] |
          w[j[a][6]][20] | w[j[a][7]][20] | w[j[a][8]][20]),
          COL (w[j[a][3]][20] | w[j[a][4]][20] | w[j[a][5]][20] |
          w[j[a][6]][20] | w[j[a][7]][20] | w[j[a][8]][20]),
          ROW (w[j[a][9]][20] | w[j[a][10]][20] | w[j[a][11]][20] |
          w[j[a][12]][20] | w[j[a][13]][20] | w[j[a][14]][20]),
          COL (w[j[a][9]][20] | w[j[a][10]][20] | w[j[a][11]][20] |
          w[j[a][12]][20] | w[j[a][13]][20] | w[j[a][14]][20]));
#endif
        goto START;
      }
    }
    for (; y < 27; ++y)      // Search Naked/Hidden Tuples Cell values Unit wise
    {
      if ((Y = !G[I].g[l[y][0]] + !G[I].g[l[y][1]] + !G[I].g[l[y][2]] + !G[I].g[l[y][3]] +
        !G[I].g[l[y][4]] + !G[I].g[l[y][5]] + !G[I].g[l[y][6]] + !G[I].g[l[y][7]] + !G[I].g[l[y][8]]) > 6)
        continue;            // Skip Unit for no unsolved Cell positions > six
      for (a = 0; a < 36; ++a)
      {                      // Search Naked/Hidden pair Cell values Unit 36 pair Cell positions wise
        if (!G[I].g[l[y][h[a][0]]] || !G[I].g[l[y][h[a][1]]])
        {                    // Skip for no unsolved Cell positions found
          if (!G[I].g[l[y][h[a][0]]])
            a += 7 - h[a][0];
          continue;
        }
        int K[2] = {G[I].g[l[y][h[a][0]]] | G[I].g[l[y][h[a][1]]], G[I].g[l[y][h[a][2]]] |
                   G[I].g[l[y][h[a][3]]] | G[I].g[l[y][h[a][4]]] | G[I].g[l[y][h[a][5]]] |
                   G[I].g[l[y][h[a][6]]] | G[I].g[l[y][h[a][7]]] | G[I].g[l[y][h[a][8]]]};
                             // Assign Cell values in Unit pair Cell positions and Unit other Cell positions
        if (B[K[0]] == 2)    // Check Naked pair Cell values in Unit pair Cell positions
        {
          if (!(K[0] & K[1]))
            continue;        // Skip for no Naked pair Cell values found in Unit other Cell positions
                             // Drop Naked pair Cell values from Unit other Cell positions
          G[I].g[l[y][h[a][2]]] &= ~K[0];
          G[I].g[l[y][h[a][3]]] &= ~K[0];
          G[I].g[l[y][h[a][4]]] &= ~K[0];
          G[I].g[l[y][h[a][5]]] &= ~K[0];
          G[I].g[l[y][h[a][6]]] &= ~K[0];
          G[I].g[l[y][h[a][7]]] &= ~K[0];
          G[I].g[l[y][h[a][8]]] &= ~K[0];
#if RJ > 2
          printf ("%d) Naked pair: %s %d %d @ %s %s => -%d @ %s %s %s %s %s %s %s\n",
            G[I].p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]],
            b[K[0]], S[l[y][h[a][2]]], S[l[y][h[a][3]]], S[l[y][h[a][4]]],
            S[l[y][h[a][5]]], S[l[y][h[a][6]]], S[l[y][h[a][7]]], S[l[y][h[a][8]]]);
#endif
          goto START;
        }
        if (B[K[0] &= K[0] ^ K[1]] != 2)
          continue;          // Skip for no Hidden pair Cell values found in Unit pair Cell positions
#if RJ > 2
        printf ("%d) Hidden pair: %s %d %d @ %s %s =>",
          G[I].p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]]);
        if (G[I].g[l[y][h[a][0]]] ^ (G[I].g[l[y][h[a][0]]] & K[0]))
          printf (" -%d @ %s",
            b[G[I].g[l[y][h[a][0]]] ^ (G[I].g[l[y][h[a][0]]] & K[0])], S[l[y][h[a][0]]]);
        if (G[I].g[l[y][h[a][1]]] ^ (G[I].g[l[y][h[a][1]]] & K[0]))
          printf (" -%d @ %s",
            b[G[I].g[l[y][h[a][1]]] ^ (G[I].g[l[y][h[a][1]]] & K[0])], S[l[y][h[a][1]]]);
        printf ("\n");
#endif
                             // Drop other than Hidden pair Cell values from Unit pair Cell positions
        G[I].g[l[y][h[a][0]]] &= K[0];
        G[I].g[l[y][h[a][1]]] &= K[0];
        goto START;
      }
      if (Y > 4)
        continue;            // Skip Unit for no unsolved Cell positions > four
      for (; a < 120; ++a)   // Search Naked/Hidden triplet Cell values Unit 84 triplet Cell positions wise
      {
        if (!G[I].g[l[y][h[a][0]]] || !G[I].g[l[y][h[a][1]]] || !G[I].g[l[y][h[a][2]]])
        {                    // Skip for no unsolved Cell positions found
          if (!G[I].g[l[y][h[a][0]]])
          {
            int A[7] = {27,20,14, 9, 5, 2, 0};

            a += A[h[a][0]];
          }
          else if (!G[I].g[l[y][h[a][1]]])
            a += 7 - h[a][1];
          continue;
        }
        int K[2] = {G[I].g[l[y][h[a][0]]] | G[I].g[l[y][h[a][1]]] | G[I].g[l[y][h[a][2]]],
                   G[I].g[l[y][h[a][3]]] | G[I].g[l[y][h[a][4]]] | G[I].g[l[y][h[a][5]]] |
                   G[I].g[l[y][h[a][6]]] | G[I].g[l[y][h[a][7]]] | G[I].g[l[y][h[a][8]]]};
                             // Assign Cell values in Unit triplet Cell positions and Unit other Cell positions
        if (B[K[0]] == 3)    // Check Naked triplet Cell values in Unit triplet Cell positions
        {
          if (!(K[0] & K[1]))
            continue;        // Skip for no Naked triplet Cell values found in Unit other Cell positions
                             // Drop Naked triplet Cell values from Unit other Cell positions
          G[I].g[l[y][h[a][3]]] &= ~K[0];
          G[I].g[l[y][h[a][4]]] &= ~K[0];
          G[I].g[l[y][h[a][5]]] &= ~K[0];
          G[I].g[l[y][h[a][6]]] &= ~K[0];
          G[I].g[l[y][h[a][7]]] &= ~K[0];
          G[I].g[l[y][h[a][8]]] &= ~K[0];
#if RJ > 2
          printf ("%d) Naked triplet: %s %d %d @ %s %s %s => -%d @ %s %s %s %s %s %s\n",
            G[I].p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]],
            S[l[y][h[a][2]]], b[K[0]], S[l[y][h[a][3]]], S[l[y][h[a][4]]],
            S[l[y][h[a][5]]], S[l[y][h[a][6]]], S[l[y][h[a][7]]], S[l[y][h[a][8]]]);
#endif
          goto START;
        }
        if (B[K[0] &= K[0] ^ K[1]] != 3)
          continue;          // Skip for no Hidden triplet Cell values found in Unit triplet Cell positions
#if RJ > 2
        printf ("%d) Hidden triplet: %s %d %d @ %s %s %s =>",
          G[I].p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]], S[l[y][h[a][2]]]);
        if (G[I].g[l[y][h[a][0]]] ^ (G[I].g[l[y][h[a][0]]] & K[0]))
          printf (" -%d @ %s",
            b[G[I].g[l[y][h[a][0]]] ^ (G[I].g[l[y][h[a][0]]] & K[0])], S[l[y][h[a][0]]]);
        if (G[I].g[l[y][h[a][1]]] ^ (G[I].g[l[y][h[a][1]]] & K[0]))
          printf (" -%d @ %s",
            b[G[I].g[l[y][h[a][1]]] ^ (G[I].g[l[y][h[a][1]]] & K[0])], S[l[y][h[a][1]]]);
        if (G[I].g[l[y][h[a][2]]] ^ (G[I].g[l[y][h[a][2]]] & K[0]))
          printf (" -%d @ %s",
            b[G[I].g[l[y][h[a][2]]] ^ (G[I].g[l[y][h[a][2]]] & K[0])], S[l[y][h[a][2]]]);
        printf ("\n");
#endif
                             // Drop other than Hidden triplet Cell values from Unit triplet Cell positions
        G[I].g[l[y][h[a][0]]] &= K[0];
        G[I].g[l[y][h[a][1]]] &= K[0];
        G[I].g[l[y][h[a][2]]] &= K[0];
        goto START;
      }
      if (Y > 2)
        continue;            // Skip Unit for not unsolved Cell positions > 2
      for (; a < 246; ++a)   // Search Naked/Hidden quad Cell values Unit 126 quad Cell positions wise
      {
        if (!G[I].g[l[y][h[a][0]]] || !G[I].g[l[y][h[a][1]]] ||
          !G[I].g[l[y][h[a][2]]] || !G[I].g[l[y][h[a][3]]])
        {                    // Skip for no unsolved Cell positions found
          if (!G[I].g[l[y][h[a][0]]])
          {
            int A[6] = {55,34,19, 9, 3, 0};

            a += A[h[a][0]];
          }
          else if (!G[I].g[l[y][h[a][1]]])
          {
            int A[7] = {27,20,14, 9, 5, 2, 0};

            a += A[h[a][1]];
          }
          else if (!G[I].g[l[y][h[a][2]]])
            a += 7 - h[a][2];
          continue;
        }
        int K[2] = {G[I].g[l[y][h[a][0]]] | G[I].g[l[y][h[a][1]]] | G[I].g[l[y][h[a][2]]] |
                   G[I].g[l[y][h[a][3]]], G[I].g[l[y][h[a][4]]] | G[I].g[l[y][h[a][5]]] |
                   G[I].g[l[y][h[a][6]]] | G[I].g[l[y][h[a][7]]] | G[I].g[l[y][h[a][8]]]};
                             // Assign Cell values in Unit quad Cell positions and Unit other Cell positions
        if (B[K[0]] == 4)    // Check Naked quad Cell values in Unit quad Cell positions
        {
          if (!(K[0] & K[1]))
            continue;        // Skip for no Naked quad Cell values found in Unit other Cell positions
                             // Drop Naked quad Cell values from Unit other Cell positions
          G[I].g[l[y][h[a][4]]] &= ~K[0];
          G[I].g[l[y][h[a][5]]] &= ~K[0];
          G[I].g[l[y][h[a][6]]] &= ~K[0];
          G[I].g[l[y][h[a][7]]] &= ~K[0];
          G[I].g[l[y][h[a][8]]] &= ~K[0];
#if RJ > 2
          printf ("%d) Naked quad: %s %d %d @ %s %s %s %s => -%d @ %s %s %s %s %s\n",
            G[I].p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]],
            S[l[y][h[a][2]]], S[l[y][h[a][3]]], b[K[0]], S[l[y][h[a][4]]], S[l[y][h[a][5]]],
            S[l[y][h[a][6]]], S[l[y][h[a][7]]], S[l[y][h[a][8]]]);
#endif
          goto START;
        }
        if (B[K[0] &= K[0] ^ K[1]] != 4)
          continue;          // Skip for no Hidden quad Cell values found in Unit quad Cell positions
#if RJ > 2
        printf ("%d) Hidden quad: %s %d %d @ %s %s %s %s =>",
          G[I].p, RCB, LBN (l[y][h[a][0]]), b[K[0]], S[l[y][h[a][0]]], S[l[y][h[a][1]]], S[l[y][h[a][2]]], S[l[y][h[a][3]]]);
        if (G[I].g[l[y][h[a][0]]] ^ (G[I].g[l[y][h[a][0]]] & K[0]))
          printf (" -%d @ %s",
            b[G[I].g[l[y][h[a][0]]] ^ (G[I].g[l[y][h[a][0]]] & K[0])], S[l[y][h[a][0]]]);
        if (G[I].g[l[y][h[a][1]]] ^ (G[I].g[l[y][h[a][1]]] & K[0]))
          printf (" -%d @ %s",
            b[G[I].g[l[y][h[a][1]]] ^ (G[I].g[l[y][h[a][1]]] & K[0])], S[l[y][h[a][1]]]);
        if (G[I].g[l[y][h[a][2]]] ^ (G[I].g[l[y][h[a][2]]] & K[0]))
          printf (" -%d @ %s",
            b[G[I].g[l[y][h[a][2]]] ^ (G[I].g[l[y][h[a][2]]] & K[0])], S[l[y][h[a][2]]]);
        if (G[I].g[l[y][h[a][3]]] ^ (G[I].g[l[y][h[a][3]]] & K[0]))
          printf (" -%d @ %s",
            b[G[I].g[l[y][h[a][3]]] ^ (G[I].g[l[y][h[a][3]]] & K[0])], S[l[y][h[a][3]]]);
        printf ("\n");
#endif
                             // Drop other than Hidden quad Cell values from Unit quad Cell positions
        G[I].g[l[y][h[a][0]]] &= K[0];
        G[I].g[l[y][h[a][1]]] &= K[0];
        G[I].g[l[y][h[a][2]]] &= K[0];
        G[I].g[l[y][h[a][3]]] &= K[0];
        goto START;
      }
    }
    for (a = 0; a < 54; ++a) // Search Almost Locked Pair, Triple and Quad 54 mini-Lines 3 Cell positions wise
    {
      if (!(G[I].g[j[a][0]] | G[I].g[j[a][1]] | G[I].g[j[a][2]]))
        continue;            // Skip for no unsolved Cell position found in mini-Line
      int A,
          L,
          M,
          N,
          K[5];

      for (y = 0; y < 2; ++y)// Search either away Line or away Box 6 Cell positions wise
      {
        for (A = W[26][y]; A < W[32][y]; ++A)
        {                    // Search Almost Locked Pair 54 mini-Lines away Line/Box 6 Cell positions wise
          if (!G[I].g[j[a][A]] || B[Y = G[I].g[j[a][A]] & ~(G[I].g[j[a][W[26][y] +
            (A < W[27][y])]] | G[I].g[j[a][W[27][y] + (A < W[28][y])]] |
            G[I].g[j[a][W[28][y] + (A < W[29][y])]] | G[I].g[j[a][W[29][y] +
            (A < W[30][y])]] | G[I].g[j[a][W[30][y] + (A < W[31][y])]])] != 2 ||
                             // Skip for either 1st Cell position not unsolved; or 1st Cell values not two digits; or
            (G[I].g[j[a][Z = W[26][!y]]] != Y && G[I].g[j[a][Z = W[27][!y]]] != Y &&
            G[I].g[j[a][Z = W[28][!y]]] != Y && G[I].g[j[a][Z = W[29][!y]]] != Y &&
            G[I].g[j[a][Z = W[30][!y]]] != Y && G[I].g[j[a][Z = W[31][!y]]] != Y) ||
                             // 2nd Cell values not 1st Cell values; or
            (!((G[I].g[K[0] = j[a][W[26][!y] + (Z < W[27][!y])]] |
            G[I].g[K[1] = j[a][W[27][!y] + (Z < W[28][!y])]] |
            G[I].g[K[2] = j[a][W[28][!y] + (Z < W[29][!y])]] |
            G[I].g[K[3] = j[a][W[29][!y] + (Z < W[30][!y])]] |
            G[I].g[K[4] = j[a][W[30][!y] + (Z < W[31][!y])]]) & Y) &&
            B[G[I].g[j[a][A]]] < 3))
            continue;        // No Almost Locked Pair values found in removal Cell positions
#if RJ > 2
          printf ("%d) Almost Locked Pair: Box %d %s %d wise %d @ r%dc%d %s %s\n=> -%d @ ",
            G[I].p, BOX (j[a][y ? A : Z]), a < 27 ? "Row" : "Column",
            a < 27 ? ROW (w[j[a][y ? Z : A]][20]) : COL (w[j[a][y ? Z : A]][20]),
            b[Y], ROW (w[j[a][0]][20] | w[j[a][1]][20] | w[j[a][2]][20]),
            COL (w[j[a][0]][20] | w[j[a][1]][20] | w[j[a][2]][20]),
            S[j[a][y ? Z : A]], S[j[a][y ? A : Z]], b[Y]);
          if (y)
            printf ("r%dc%d",
              ROW (w[K[0]][20] | w[K[1]][20] | w[K[2]][20] | w[K[3]][20] | w[K[4]][20]),
              COL (w[K[0]][20] | w[K[1]][20] | w[K[2]][20] | w[K[3]][20] | w[K[4]][20]));
          else
            printf ("r%dc%d r%dc%d", ROW (w[K[0]][20] | w[K[2]][20] | w[K[4]][20]),
              COL (w[K[0]][20] | w[K[2]][20] | w[K[4]][20]),
              ROW (w[K[1]][20] | w[K[3]][20]), COL (w[K[1]][20] | w[K[3]][20]));
          if (G[I].g[j[a][A]] ^ Y)
            printf (" => -%d @ %s", b[G[I].g[j[a][A]] ^ Y], S[j[a][A]]);
          printf ("\n");
#endif
                             // Drop Almost Locked Pair values from removal Cell positions
          G[I].g[j[a][A]] &= Y;
          G[I].g[K[0]] &= ~Y;
          G[I].g[K[1]] &= ~Y;
          G[I].g[K[2]] &= ~Y;
          G[I].g[K[3]] &= ~Y;
          G[I].g[K[4]] &= ~Y;
          goto START;
        }
        if (!G[I].g[j[a][0]] + !G[I].g[j[a][1]] + !G[I].g[j[a][2]] > 1)
          continue;          // Skip Almost Locked Triple for no unsolved Cell position > 1 in mini-Line
        for (A = W[26][y]; A < W[31][y]; ++A)
        {                    // Search 1st Cell position 54 mini-Lines away Line/Box wise
          if (!G[I].g[j[a][A]])
            continue;        // Skip for 1st Cell position not unsolved
          for (L = A + 1; L < W[32][y]; ++L)
          {                  // Search 2nd Cell position 54 mini-Lines away Line/Box wise
            if (!G[I].g[j[a][L]] || B[Y = (G[I].g[j[a][A]] | G[I].g[j[a][L]]) &
              ~(G[I].g[j[a][W[26][y] + (A < W[27][y]) + (L < W[28][y])]] |
              G[I].g[j[a][W[27][y] + (A < W[28][y]) + (L < W[29][y])]] |
              G[I].g[j[a][W[28][y] + (A < W[29][y]) + (L < W[30][y])]] |
              G[I].g[j[a][W[29][y] + (A < W[30][y]) + (L < W[31][y])]])] != 3)
              continue;      // Skip for either 2nd Cell position not unsolved; or 1st and 2nd Cells values not three digits
            for (M = W[26][!y]; M < W[31][!y]; ++M)
            {                // Search 3rd Cell position 54 mini-Lines away Box/Line wise
              if (!G[I].g[j[a][M]] || B[G[I].g[j[a][M]]] > 3)
                continue;    // Skip for either 3rd Cell position not unsolved; or 3rd Cell values > three digits
              for (N = M + 1; N < W[32][!y]; ++N)
              {              // Search 4th Cell position 54 mini-Lines away Box/Line wise
                if (!G[I].g[j[a][N]] || (G[I].g[j[a][M]] | G[I].g[j[a][N]]) != Y ||
                             // Skip for either 4th Cell position not unsolved; or 3rd and 4th Cell values not 1st and 2nd Cell values; or
                  (!((G[I].g[K[0] = j[a][W[26][!y] + (M < W[27][!y]) + (N < W[28][!y])]] |
                  G[I].g[K[1] = j[a][W[27][!y] + (M < W[28][!y]) + (N < W[29][!y])]] |
                  G[I].g[K[2] = j[a][W[28][!y] + (M < W[29][!y]) + (N < W[30][!y])]] |
                  G[I].g[K[3] = j[a][W[29][!y] + (M < W[30][!y]) + (N < W[31][!y])]]) & Y) &&
                  B[G[I].g[j[a][A]] | G[I].g[j[a][L]]] < 4))
                  continue;  // No Almost Locked Triple values found in removal Cell positions
#if RJ > 2
                printf ("%d) Almost Locked Triple: Box %d %s %d wise %d @ r%dc%d r%dc%d %s %s\n=> -%d @ ",
                  G[I].p, BOX (j[a][y ? A : M]), a < 27 ? "Row" : "Column",
                  a < 27 ? ROW (w[j[a][y ? M : A]][20]) : COL (w[j[a][y ? M : A]][20]),
                  b[Y], ROW (w[j[a][0]][20] | w[j[a][1]][20] | w[j[a][2]][20]),
                  COL (w[j[a][0]][20] | w[j[a][1]][20] | w[j[a][2]][20]),
                  ROW (w[j[a][y ? M : A]][20] | w[j[a][y ? N : L]][20]),
                  COL (w[j[a][y ? M : A]][20] | w[j[a][y ? N : L]][20]),
                  S[j[a][y ? A : M]], S[j[a][y ? L : N]], b[Y]);
                if (y)
                  printf ("r%dc%d",
                    ROW (w[K[0]][20] | w[K[1]][20] | w[K[2]][20] | w[K[3]][20]),
                    COL (w[K[0]][20] | w[K[1]][20] | w[K[2]][20] | w[K[3]][20]));
                else
                  printf ("%s %s %s %s", S[K[0]], S[K[1]], S[K[2]], S[K[3]]);
                if (G[I].g[j[a][A]] ^ (G[I].g[j[a][A]] & Y))
                  printf (" => -%d @ %s",
                    b[G[I].g[j[a][A]] ^ (G[I].g[j[a][A]] & Y)], S[j[a][A]]);
                if (G[I].g[j[a][L]] ^ (G[I].g[j[a][L]] & Y))
                  printf (" => -%d @ %s",
                    b[G[I].g[j[a][L]] ^ (G[I].g[j[a][L]] & Y)], S[j[a][L]]);
                printf ("\n");
#endif
                             // Drop Almost Locked Triple values from removal Cell positions
                G[I].g[j[a][A]] &= Y;
                G[I].g[j[a][L]] &= Y;
                G[I].g[K[0]] &= ~Y;
                G[I].g[K[1]] &= ~Y;
                G[I].g[K[2]] &= ~Y;
                G[I].g[K[3]] &= ~Y;
                goto START;
              }
            }
          }
        }
        if (!G[I].g[j[a][3]] + !G[I].g[j[a][4]] + !G[I].g[j[a][5]] +
          !G[I].g[j[a][6]] + !G[I].g[j[a][7]] + !G[I].g[j[a][8]] > 3 ||
          !G[I].g[j[a][9]] + !G[I].g[j[a][10]] + !G[I].g[j[a][11]] +
          !G[I].g[j[a][12]] + !G[I].g[j[a][13]] + !G[I].g[j[a][14]] > 3)
          continue;          // Skip Almost Locked Quad for mini-Line away Line not unsolved Cell positions > three; or mini-Line away Box not unsolved Cell positions > three
        for (A = W[26][y]; A < W[30][y]; ++A)
        {                    // Search 1st Cell position 54 mini-Lines away Line/Box wise
          if (!G[I].g[j[a][A]])
            continue;        // Skip for 1st Cell position not unsolved
          for (L = A + 1; L < W[31][y]; ++L)
          {                  // Search 2nd Cell position 54 mini-Lines away Line/Box wise
            if (!G[I].g[j[a][L]])
              continue;      // Skip for 2nd Cell position not unsolved
            for (M = L + 1; M < W[32][y]; ++M)
            {                // Search 3rd Cell position 54 mini-Lines away Line/Box wise
              if (!G[I].g[j[a][M]] || B[Y = (G[I].g[j[a][A]] | G[I].g[j[a][L]] | G[I].g[j[a][M]]) &
                ~(G[I].g[j[a][W[26][y] + (A < W[27][y]) + (L < W[28][y]) + (M < W[29][y])]] |
                G[I].g[j[a][W[27][y] + (A < W[28][y]) + (L < W[29][y]) + (M < W[30][y])]] |
                G[I].g[j[a][W[28][y] + (A < W[29][y]) + (L < W[30][y]) + (M < W[31][y])]])] != 4 ||
                             // Skip for either 3rd Cell position not unsolved; or 1st, 2nd and 3rd Cells values not four digits; or
                !(G[I].g[j[a][A]] & Y) || !(G[I].g[j[a][L]] & Y) || !(G[I].g[j[a][M]] & Y))
                continue;    // No Almost Locked Quad values in either 1st or 2nd or 3rd Cells positions
              for (N = W[26][!y]; N < W[30][!y]; ++N)
              {              // Search 4th Cell position 54 mini-Lines away Box/Line wise
                if (!G[I].g[j[a][N]] || B[G[I].g[j[a][N]]] > 4)
                  continue;  // Skip for either 4th Cell position not unsolved; or 4th Cell values > four digits
                for (X = N + 1; X < W[31][!y]; ++X)
                {            // Search 5th Cell position 54 mini-Lines away Box/Line wise
                  if (!G[I].g[j[a][X]] || B[G[I].g[j[a][X]]] > 4)
                    continue;// Skip for either 5th Cell position not unsolved; or 5th Cell values > four digits
                  for (Z = X + 1; Z < W[32][!y]; ++Z)
                  {          // Search 6th Cell position 54 mini-Lines away Box/Line wise
                    if (!G[I].g[j[a][Z]] || (G[I].g[j[a][N]] | G[I].g[j[a][X]] | G[I].g[j[a][Z]]) != Y ||
                             // Skip for either 6th Cell position unsolved; or 4th, 5th and 6th Cells values is 1st, 2nd and 3rd Cells values; or
                      (!((G[I].g[K[0] = j[a][W[26][!y] + (N < W[27][!y]) + (X < W[28][!y]) + (Z < W[29][!y])]] |
                      G[I].g[K[1] = j[a][W[27][!y] + (N < W[28][!y]) + (X < W[29][!y]) + (Z < W[30][!y])]] |
                      G[I].g[K[2] = j[a][W[28][!y] + (N < W[29][!y]) + (X < W[30][!y]) + (Z < W[31][!y])]]) & Y) &&
                      B[G[I].g[j[a][A]] | G[I].g[j[a][L]] | G[I].g[j[a][M]]] < 5))
                             // No Almost Locked Quad values found in removal Cell positions
                      continue;
#if RJ > 2
                    printf ("%d) Almost Locked Quad: Box %d %s %d wise %d @ r%dc%d r%dc%d %s %s %s\n=> -%d @ ",
                      G[I].p, BOX (j[a][y ? A : N]), a < 27 ? "Row" : "Column",
                      a < 27 ? ROW (w[j[a][y ? N : A]][20]) : COL (w[j[a][y ? N : A]][20]),
                      b[Y], ROW (w[j[a][0]][20] | w[j[a][1]][20] | w[j[a][2]][20]),
                      COL (w[j[a][0]][20] | w[j[a][1]][20] | w[j[a][2]][20]),
                      ROW (w[j[a][y ? N : A]][20] | w[j[a][y ? X : L]][20] | w[j[a][y ? Z : M]][20]),
                      COL (w[j[a][y ? N : A]][20] | w[j[a][y ? X : L]][20] | w[j[a][y ? Z : M]][20]),
                      S[j[a][y ? A : N]], S[j[a][y ? L : X]], S[j[a][y ? M : Z]], b[Y]);
                    if (y)
                      printf ("r%dc%d", ROW (w[K[0]][20] | w[K[1]][20] | w[K[2]][20]),
                        COL (w[K[0]][20] | w[K[1]][20] | w[K[2]][20]));
                    else
                      printf ("%s %s %s", S[K[0]], S[K[1]], S[K[2]]);
                    if (G[I].g[j[a][A]] ^ (G[I].g[j[a][A]] & Y))
                      printf (" => -%d @ %s",
                        b[G[I].g[j[a][A]] ^ (G[I].g[j[a][A]] & Y)], S[j[a][A]]);
                    if (G[I].g[j[a][L]] ^ (G[I].g[j[a][L]] & Y))
                      printf (" => -%d @ %s",
                        b[G[I].g[j[a][L]] ^ (G[I].g[j[a][L]] & Y)], S[j[a][L]]);
                    if (G[I].g[j[a][M]] ^ (G[I].g[j[a][M]] & Y))
                      printf (" => -%d @ %s",
                        b[G[I].g[j[a][M]] ^ (G[I].g[j[a][M]] & Y)], S[j[a][M]]);
                    printf ("\n");
#endif
                             // Drop Almost Locked Quad values from removal Cell positions
                    G[I].g[j[a][A]] &= Y;
                    G[I].g[j[a][L]] &= Y;
                    G[I].g[j[a][M]] &= Y;
                    G[I].g[K[0]] &= ~Y;
                    G[I].g[K[1]] &= ~Y;
                    G[I].g[K[2]] &= ~Y;
                    goto START;
                  }
                }
              }
            }
          }
        }
      }
    }
    for (y = 0; y < 10; y += 9)
                             // Search Basic Fishes Line wise
      for (Y = 1; Y < 257; Y <<= 1)
      {                      // Search Basic Fishes digit wise
        int k[9],            // Backup Basic Fish value Line Cell positions wise
            K[4];

        for (a = y; a < y + 9; ++a)
          k[a - y] = (G[I].g[l[a][0]] & Y ? 1 : 0) | (G[I].g[l[a][1]] & Y ? 2 : 0) |
            (G[I].g[l[a][2]] & Y ? 4 : 0) | (G[I].g[l[a][3]] & Y ? 8 : 0) |
            (G[I].g[l[a][4]] & Y ? 16 : 0) | (G[I].g[l[a][5]] & Y ? 32 : 0) |
            (G[I].g[l[a][6]] & Y ? 64 : 0) | (G[I].g[l[a][7]] & Y ? 128 : 0) |
            (G[I].g[l[a][8]] & Y ? 256 : 0);
        for (a = 0; a < 36; ++a)
        {                    // Search X-Wing value for Line 36 pair Cell positions
          if (B[X = k[h[a][0]]] != 2 || X != k[h[a][1]])
          {                  // Skip for no X-Wing value found in Lines pair Cell positions
            if (B[X] != 2)
              a += 7 - h[a][0];
            continue;
          }
          int A[2] = {-1,-1};

          for (Z = -1; K[++Z] = X & -X; X -= K[Z])
          {                  // Search opposite Line other Cell positions for X-Wing value
            if (~(k[h[a][2]] | k[h[a][3]] | k[h[a][4]] | k[h[a][5]] | k[h[a][6]] |
              k[h[a][7]] | k[h[a][8]]) & K[Z])
              continue;      // Skip for no X-Wing value found in opposite Line other Cell positions
            A[Z] = b[K[Z]] - y + 8;
            G[I].g[l[A[Z]][h[a][2]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][3]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][4]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][5]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][6]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][7]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][8]]] &= ~Y;
          }                  // Drop X-Wing value from opposite Line other Cell positions
          if ((A[0] & A[1]) < 0)
            continue;        // Skip for no X-Wing value found in opposite Lines other Cell positions
#if RJ > 2
          printf ("%d) %s wise X-Wing: %d @ r%d%dc%d%d\n",
            G[I].p, RCB, b[Y], y ? b[K[0]] : h[a][0] + 1, y ? b[K[1]] : h[a][1] + 1,
            y ? h[a][0] + 1 : b[K[0]], y ? h[a][1] + 1 : b[K[1]]);
#endif
          goto START;
        }
        for (; a < 120; ++a) // Search Sword Fish value in Line 84 triplet Cell positions
        {
          if (!k[h[a][0]] || !k[h[a][1]] || !k[h[a][2]] ||
            B[X = k[h[a][0]] | k[h[a][1]] | k[h[a][2]]] != 3)
          {                  // Skip for either no unsolved Cell positions; or no Sord Fish value found in Lines triplet Cell positions
            if (!k[h[a][0]] || B[k[h[a][0]]] > 3)
            {
              int A[7] = {27,20,14, 9, 5, 2, 0};

              a += A[h[a][0]];
            }
            else if (!k[h[a][1]] || B[k[h[a][1]]] > 3)
              a += 7 - h[a][1];
            continue;
          }
          int A[3] = {-1,-1,-1};

          for (Z = -1; K[++Z] = X & -X; X -= K[Z])
          {                  // Search opposite Line other Cell positions for Sword Fish value
            if (~(k[h[a][3]] | k[h[a][4]] | k[h[a][5]] | k[h[a][6]] | k[h[a][7]] |
              k[h[a][8]]) & K[Z])
              continue;      // Skip for no Sword Fish value found in opposite Line other Cell positions
            A[Z] = b[K[Z]] - y + 8;
            G[I].g[l[A[Z]][h[a][3]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][4]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][5]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][6]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][7]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][8]]] &= ~Y;
          }                  // Drop Sword Fish value from opposite Line other Cell positions
          if ((A[0] & A[1] & A[2]) < 0)
            continue;        // Skip for no Sword Fish value found in opposite Lines other Cell positions
#if RJ > 2
          printf ("%d) %s wise Sword Fish: %d @ r%d%d%dc%d%d%d\n",
            G[I].p, RCB, b[Y], y ? b[K[0]] : h[a][0] + 1, y ? b[K[1]] : h[a][1] + 1,
            y ? b[K[2]] : h[a][2] + 1, y ? h[a][0] + 1 : b[K[0]],
            y ? h[a][1] + 1 : b[K[1]], y ? h[a][2] + 1 : b[K[2]]);
#endif
          goto START;
        }
        for (; a < 246; ++a) // Search Jelly Fish value in Line 126 quad Cell positions
        {
          if (!k[h[a][0]] || !k[h[a][1]] || !k[h[a][2]] || !k[h[a][3]] ||
            B[X = k[h[a][0]] | k[h[a][1]] | k[h[a][2]] | k[h[a][3]]] != 4)
          {                  // Skip for either no unsolved Cell positions; or no Jelly Fish value found in Line quad Cell positions
            if (!k[h[a][0]] || B[k[h[a][0]]] > 4)
            {
              int A[6] = {55,34,19, 9, 3, 0};

              a += A[h[a][0]];
            }
            else if (!k[h[a][1]] || B[k[h[a][1]]] > 4)
            {
              int A[7] = {27,20,14, 9, 5, 2, 0};

              a += A[h[a][1]];
            }
            else if (!k[h[a][2]] || B[k[h[a][2]]] > 4)
              a += 7 - h[a][2];
            continue;
          }
          int A[4] = {-1,-1,-1,-1};

          for (Z = -1; K[++Z] = X & -X; X -= K[Z])
          {                  // Search opposite Line other Cell positions for Jelly Fish value
            if (~(k[h[a][4]] | k[h[a][5]] | k[h[a][6]] | k[h[a][7]] | k[h[a][8]]) & K[Z])
              continue;      // Skip for no Jelly Fish value found in opposite Line other Cell positions
            A[Z] = b[K[Z]] - y + 8;
            G[I].g[l[A[Z]][h[a][4]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][5]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][6]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][7]]] &= ~Y;
            G[I].g[l[A[Z]][h[a][8]]] &= ~Y;
          }                  // Drop Jelly Fish value from opposite Line other Cell positions
          if ((A[0] & A[1] & A[2] & A[3]) < 0)
            continue;        // Skip for no Jelly Fish value found in opposite Lines other Cell positions
#if RJ > 2
          printf ("%d) %s wise Jelly Fish: %d @ r%d%d%d%dc%d%d%d%d\n",
            G[I].p, RCB, b[Y], y ? b[K[0]] : h[a][0] + 1, y ? b[K[1]] : h[a][1] + 1,
            y ? b[K[2]] : h[a][2] + 1, y ? b[K[3]] : h[a][3] + 1, y ? h[a][0] + 1 : b[K[0]],
            y ? h[a][1] + 1 : b[K[1]], y ? h[a][2] + 1 : b[K[2]], y ? h[a][3] + 1 : b[K[3]]);
#endif
          goto START;
        }
      }
    for (y = 0; y < 10; y += 9)
                             // Search Skyscraper and Grouped Skyscraper Line wise
      for (Y = 1; Y < 257; Y <<= 1)
                             // Search Skyscraper and Grouped Skyscraper digit wise
        for (a = y; a < y + 6; ++a)
        {                    // Search 1st SL within 1st and 2nd Chutes
          int A[7] = {0};    // 1st and 2nd SL Base and Cover Cell positions; and check for Grouped Cover Cell positions

          if ((A[6] = !(G[I].g[l[a][0]] & Y) + !(G[I].g[l[a][1]] & Y) + !(G[I].g[l[a][2]] & Y)) == 2)
            A[0] = 1;        // Found 1st SL one Base Cell position
          else if (A[6] < 2)
            A[0] = A[2] = 1; // Found 1st SL Grouped Cover Cell positions
        if ((A[6] = !(G[I].g[l[a][3]] & Y) + !(G[I].g[l[a][4]] & Y) + !(G[I].g[l[a][5]] & Y)) == 2)
            A[A[0]] = 2;     // Found 1st SL either one Cover or Base Cell position
          else if (A[6] < 2)
          {                  // Found 1st SL Grouped Cover Cell positions
            if (A[2])
              continue;      // Skip for Grouped Cover Cell positions already found
            A[A[0]] = A[2] = 2;
          }
          if (!A[0])
            continue;        // Skip for no 1st SL Cell positions found
          if ((A[6] = !(G[I].g[l[a][6]] & Y) + !(G[I].g[l[a][7]] & Y) + !(G[I].g[l[a][8]] & Y)) == 2)
          {                  // Found 1st SL one Cover Cell position
            if (A[1])
              continue;      // Skip for 1st SL Base and Cover Cell positions already found
            A[1] = 4;
          }
          else if (A[6] < 2)
          {                  // Found 1st SL Grouped Cover Cell positions
            if (A[1] || A[2])
              continue;      // Skip for either 1st SL Base and Cover Cell positions already found; or Grouped Cover Cell positions already found
            A[1] = A[2] = 4;
          }
          if (!A[1])
            continue;        // Skip for no 1st SL Base and Cover Cell positions found
          for (Z = y + (a < y + 3 ? 3 : 6); Z < y + 9; ++Z)
          {                  // Search 2nd SL within 2nd and 3rd Chutes
            A[3] = A[4] = 0;
            A[5] = A[2];
            if ((A[6] = !(G[I].g[l[Z][0]] & Y) + !(G[I].g[l[Z][1]] & Y) + !(G[I].g[l[Z][2]] & Y)) == 2)
            {                // Found 2nd SL Base Cell position
              if (~A[0] & 1)
                continue;    // Skip for no 1st SL Cell positions found in 1st mini-Line
              A[3] = 1;
            }
            else if (A[6] < 2)
            {                // Found 2nd SL Grouped Cover Cell positions
              if (A[5] || ~A[0] & 1)
                continue;    // Skip for either Grouped SL Cell positions already found; or no 1st SL Cell position found in 1st mini-Line
              A[3] = A[5] = 1;
            }
            if ((A[6] = !(G[I].g[l[Z][3]] & Y) + !(G[I].g[l[Z][4]] & Y) + !(G[I].g[l[Z][5]] & Y)) == 2)
            {                // Found 2nd SL either one Cover or Base Cell position
              if (~(A[0] | A[1]) & 2)
                continue;    // Skip for no 1st SL Cell positions found in 2nd mini-Line
              A[3 + A[3]] = 2;
            }
            else if (A[6] < 2)
            {                // Found 2nd SL Grouped Cover Cell positions
              if (A[5] || ~(A[0] | A[1]) & 2)
                continue;    // Skip for either Grouped Cover Cell positions already found; or no 1st SL Cell positions found in 2nd mini-Line
              A[3 + A[3]] = A[5] = 2;
            }
            if (!A[3])
              continue;      // Skip for no 2nd SL Cell positions found
            if ((A[6] = !(G[I].g[l[Z][6]] & Y) + !(G[I].g[l[Z][7]] & Y) + !(G[I].g[l[Z][8]] & Y)) == 2)
            {                // Found 2nd SL either one Cover or Base Cell position
              if (A[4] || ~A[1] & 4)
                continue;    // Skip for either 2nd SL Base and Cover Cell positions already found; or no 1st SL Cover Cell positions found in 3rd mini-Line
              A[4] = 4;
            }
            else if (A[6] < 2)
            {                // Found 2nd SL Grouped Cover Cell positions
              if (A[4] || A[5] || ~(A[0] | A[1]) & 4)
                continue;    // Skip for either 2nd SL Base and Cover Cell positions already found; or Grouped Cover Cell positions already found; or no 1st SL Cover Cell positions found in 3rd mini-Line
              A[4] = A[5] = 4;
            }
            if (!A[4])
              continue;      // Skip for no 2nd SL Base and Cover Cell positions found
            A[6] = 0;        // Base Cell positions
            if ((A[0] & 1) && (!(G[I].g[l[a][0]] & Y) | (!(G[I].g[l[a][1]] & Y) << 1) | (!(G[I].g[l[a][2]] & Y) << 2)) ==
            (!(G[I].g[l[Z][0]] & Y) | (!(G[I].g[l[Z][1]] & Y) << 1) | (!(G[I].g[l[Z][2]] & Y) << 2)))
              A[6] = 1;
            if (((A[0] | A[1]) & 2) && (!(G[I].g[l[a][3]] & Y) | (!(G[I].g[l[a][4]] & Y) << 1) | (!(G[I].g[l[a][5]] & Y) << 2)) ==
            (!(G[I].g[l[Z][3]] & Y) | (!(G[I].g[l[Z][4]] & Y) << 1) | (!(G[I].g[l[Z][5]] & Y) << 2)))
              A[6] |= 2;
            if ((A[1] & 4) && (!(G[I].g[l[a][6]] & Y) | (!(G[I].g[l[a][7]] & Y) << 1) | (!(G[I].g[l[a][8]] & Y) << 2)) ==
            (!(G[I].g[l[Z][6]] & Y) | (!(G[I].g[l[Z][7]] & Y) << 1) | (!(G[I].g[l[Z][8]] & Y) << 2)))
              A[6] |= 4;
            if (B[A[6]] != 1)
              continue;      // Skip for neither Skyscraper nor Grouped Skyscraper found
            int K[12] = {-1,-1,-1,-1,
                        l[a][b[A[6]] * 3 - (G[I].g[l[a][b[A[6]] * 3 - 3]] & Y ? 3 : G[I].g[l[a][b[A[6]] * 3 - 2]] & Y ? 2 : 1)],
                        l[Z][b[A[6]] * 3 - (G[I].g[l[Z][b[A[6]] * 3 - 3]] & Y ? 3 : G[I].g[l[Z][b[A[6]] * 3 - 2]] & Y ? 2 : 1)]},
                k[4] = {0};  // Backup Skyscraper and Grouped Skyscraper removal Cell positions

            A[6] = b[A[A[0] == A[6]]] * 3;
                             // Cover Cell positions
            K[6] = G[I].g[l[a][A[6] - 3]] & Y ? l[a][A[6] - 3] : -1;
            K[7] = G[I].g[l[a][A[6] - 2]] & Y ? l[a][A[6] - 2] : -1;
            K[8] = G[I].g[l[a][A[6] - 1]] & Y ? l[a][A[6] - 1] : -1;
            K[9] = G[I].g[l[Z][A[6] - 3]] & Y ? l[Z][A[6] - 3] : -1;
            K[10] = G[I].g[l[Z][A[6] - 2]] & Y ? l[Z][A[6] - 2] : -1;
            K[11] = G[I].g[l[Z][A[6] - 1]] & Y ? l[Z][A[6] - 1] : -1;
            if (!A[2])
            {                // Found 1st SL one Cover Cell position
              A[6] = K[K[6] + 1 ? 6 : K[7] + 1 ? 7 : 8] - K[4] + K[5];
              k[0] = G[I].g[K[0] = w[A[6]][W[3][!y]]];
              k[1] = G[I].g[K[1] = w[A[6]][W[4][!y]]];
            }
            if (A[2] || !A[5])
            {                // Found 2nd SL one Cover Cell position
              A[6] = K[K[9] + 1 ? 9 : K[10] + 1 ? 10 : 11] - K[5] + K[4];
              k[2] = G[I].g[K[2] = w[A[6]][W[3][!y]]];
              k[3] = G[I].g[K[3] = w[A[6]][W[4][!y]]];
            }
            if ((k[0] | k[1] | k[2] | k[3]) & Y)
            {                // Found Skyscraper and Grouped Skyscraper digit in removal Cell positions
              if (!A[2])
              {
                G[I].g[K[0]] &= ~Y;
                G[I].g[K[1]] &= ~Y;
              }
              if (A[2] || !A[5])
              {
                G[I].g[K[2]] &= ~Y;
                G[I].g[K[3]] &= ~Y;
              }
#if RJ > 2
              printf ("%d)%sSkyscraper: %ss %d %d Base %d @ %s %s Cover %d @ r%dc%d r%dc%d => -%d @",
                G[I].p, A[5] ? " Grouped " : " ", RCB, a - y + 1, Z - y + 1, b[Y], S[K[4]], S[K[5]],
                b[Y], ROW ((K[6] + 1 ? w[K[6]][20] : 0) | (K[7] + 1 ? w[K[7]][20] : 0) |
                (K[8] + 1 ? w[K[8]][20] : 0)), COL ((K[6] + 1 ? w[K[6]][20] : 0) |
                (K[7] + 1 ? w[K[7]][20] : 0) | (K[8] + 1 ? w[K[8]][20] : 0)),
                ROW ((K[9] + 1 ? w[K[9]][20] : 0) | (K[10] + 1 ? w[K[10]][20] : 0) |
                (K[11] + 1 ? w[K[11]][20] : 0)), COL ((K[9] + 1 ? w[K[9]][20] : 0) |
                (K[10] + 1 ? w[K[10]][20] : 0) | (K[11] + 1 ? w[K[11]][20] : 0)), b[Y]);
              if (!A[2])
                printf (" r%dc%d", ROW (w[K[0]][20] | w[K[1]][20]),
                  COL (w[K[0]][20] | w[K[1]][20]));
              if (A[2] || !A[5])
                printf (" r%dc%d", ROW (w[K[2]][20] | w[K[3]][20]),
                  COL (w[K[2]][20] | w[K[3]][20]));
              printf ("\n");
#endif
              goto START;
            }
          }
        }
    for (a = 0; a < 81; ++a) // Search 2-String Kite and Grouped 2-String Kite with ERI Ring, ERI and Box Grid wise
    {
      if (!(y = ~G[I].g[a] & (G[I].g[w[a][6]] | G[I].g[w[a][7]]) & (G[I].g[w[a][12]] | G[I].g[w[a][13]])))
        continue;            // Skip for either digit found in ERI Cell values; or not found in mini-Row and mini-Column Cell values
      int K[6] = { 0,-1,-1},
          L,
          M;

      for (; Y = y & -y; y -= Y)
      {                      // Search 2-String Kite and Grouped 2-String Kite with ERI Ring and ERI digit wise
        if (B[X = !(G[I].g[w[a][0]] & Y) | (!(G[I].g[w[a][1]] & Y) << 1) |
          (!(G[I].g[w[a][2]] & Y) << 2) | (!(G[I].g[w[a][3]] & Y) << 3) |
          (!(G[I].g[w[a][4]] & Y) << 4) | (!(G[I].g[w[a][5]] & Y) << 5)] != 5 ||
          B[Z = !(G[I].g[w[a][14]] & Y) | (!(G[I].g[w[a][15]] & Y) << 1) |
          (!(G[I].g[w[a][16]] & Y) << 2) | (!(G[I].g[w[a][17]] & Y) << 3) |
          (!(G[I].g[w[a][18]] & Y) << 4) | (!(G[I].g[w[a][19]] & Y) << 5)] != 5)
          continue;          // Skip for no digit found in either five Row Cells values; or five Column Cells values; or no removal Cell position found
        K[5] = (K[3] = w[a][b[~X & 63] - 1]) - a + (K[4] = w[a][13 + b[~Z & 63]]);
        if ((G[I].g[L = w[K[3]][b[~Z & 63] > 3 ? 14 : 17]] | G[I].g[w[L][12]] | G[I].g[w[L][13]] |
          G[I].g[M = w[K[4]][b[~X & 63] > 3 ? 0 : 3]] | G[I].g[w[M][6]] | G[I].g[w[M][7]] |
          G[I].g[w[K[3]][12]] | G[I].g[w[K[3]][13]] | G[I].g[w[K[4]][6]] | G[I].g[w[K[4]][7]] |
          G[I].g[w[a][8]] | G[I].g[w[a][9]] | G[I].g[w[a][10]] | G[I].g[w[a][11]]) & ERI (K[5]) & Y)
        {                    // Check 2-String Kite+ERI Ring and Grouped 2-String Kite+ERI Ring
          G[I].g[w[K[3]][12]] &= ~Y;
          G[I].g[w[K[3]][13]] &= ~Y;
          G[I].g[L] &= ~Y;
          G[I].g[w[L][12]] &= ~Y;
          G[I].g[w[L][13]] &= ~Y;
          G[I].g[w[K[4]][6]] &= ~Y;
          G[I].g[w[K[4]][7]] &= ~Y;
          G[I].g[M] &= ~Y;
          G[I].g[w[M][6]] &= ~Y;
          G[I].g[w[M][7]] &= ~Y;
          G[I].g[w[a][8]] &= ~Y;
          G[I].g[w[a][9]] &= ~Y;
          G[I].g[w[a][10]] &= ~Y;
          G[I].g[w[a][11]] &= ~Y;
#if RJ > 2
          K[0] = 1;
#endif
        }
        else if ((G[I].g[w[w[K[3]][6]][12]] | G[I].g[w[w[K[3]][6]][13]]) & ERI (w[K[5]][6]) & Y)
        {                    // Check 2-String Kite+ERI and Grouped 2-String Kite+ERI
#if RJ > 2
          G[I].g[K[1] = w[w[K[3]][K[6] = 6]][12]] &= ~Y;
          G[I].g[K[2] = w[w[K[3]][6]][13]] &= ~Y;
#else
          G[I].g[w[w[K[3]][6]][12]] &= ~Y;
          G[I].g[w[w[K[3]][6]][13]] &= ~Y;
#endif
        }
        else if ((G[I].g[w[w[K[3]][7]][12]] | G[I].g[w[w[K[3]][7]][13]]) & ERI (w[K[5]][7]) & Y)
        {                    // Check 2-String Kite+ERI and Grouped 2-String Kite+ERI
#if RJ > 2
          G[I].g[K[1] = w[w[K[3]][K[6] = 7]][12]] &= ~Y;
          G[I].g[K[2] = w[w[K[3]][7]][13]] &= ~Y;
#else
          G[I].g[w[w[K[3]][7]][12]] &= ~Y;
          G[I].g[w[w[K[3]][7]][13]] &= ~Y;
#endif
        }
        else if ((G[I].g[w[w[K[4]][12]][6]] | G[I].g[w[w[K[4]][12]][7]]) & ERI (w[K[5]][12]) & Y)
        {                    // Check 2-String Kite+ERI and Grouped 2-String Kite+ERI
#if RJ > 2
          G[I].g[K[1] = w[w[K[4]][K[6] = 12]][6]] &= ~Y;
          G[I].g[K[2] = w[w[K[4]][12]][7]] &= ~Y;
#else
          G[I].g[w[w[K[4]][12]][6]] &= ~Y;
          G[I].g[w[w[K[4]][12]][7]] &= ~Y;
#endif
        }
        else if ((G[I].g[w[w[K[4]][13]][6]] | G[I].g[w[w[K[4]][13]][7]]) & ERI (w[K[5]][13]) & Y)
        {                    // Check 2-String Kite+ERI and Grouped 2-String Kite+ERI
#if RJ > 2
          G[I].g[K[1] = w[w[K[4]][K[6] = 13]][6]] &= ~Y;
          G[I].g[K[2] = w[w[K[4]][13]][7]] &= ~Y;
#else
          G[I].g[w[w[K[4]][13]][6]] &= ~Y;
          G[I].g[w[w[K[4]][13]][7]] &= ~Y;
#endif
        }
        else if (LB3 (L, w[L][6], w[L][7], 1) & G[I].g[w[K[5]][6]] & Y)
                              // Check 2-String Kite+Box and Grouped 2-String Kite+Box
#if RJ > 2
          G[I].g[K[2] = w[K[5]][6]] -= Y;
#else
          G[I].g[w[K[5]][6]] -= Y;
#endif
        else if (LB3 (L, w[L][7], w[L][6], 1) & G[I].g[w[K[5]][7]] & Y)
                              // Check 2-String Kite+Box and Grouped 2-String Kite+Box
#if RJ > 2
          G[I].g[K[2] = w[K[5]][7]] -= Y;
#else
          G[I].g[w[K[5]][7]] -= Y;
#endif
        else if (LB3 (M, w[M][12], w[M][13], 0) & G[I].g[w[K[5]][12]] & Y)
                              // Check 2-String Kite+Box and Grouped 2-String Kite+Box
#if RJ > 2
          G[I].g[K[2] = w[K[5]][12]] -= Y;
#else
          G[I].g[w[K[5]][12]] -= Y;
#endif
        else if (LB3 (M, w[M][13], w[M][12], 0) & G[I].g[w[K[5]][13]] & Y)
                              // Check 2-String Kite+Box and Grouped 2-String Kite+Box
#if RJ > 2
          G[I].g[K[2] = w[K[5]][13]] -= Y;
#else
          G[I].g[w[K[5]][13]] -= Y;
#endif
        else if (~G[I].g[K[5]] & Y)
          continue;          // Skip 2-String Kite and Grouped 2-String Kite for digit not in removal Cell values
        G[I].g[K[5]] &= ~Y;  // Drop 2-String Kite and Grouped 2-String Kite digit from removal Cell values
#if RJ > 2
        printf ("%d)%s2-String Kite%s SL Row %d between %d @ ", G[I].p,
          ((G[I].g[w[a][6]] & G[I].g[w[a][7]]) | (G[I].g[w[a][12]] & G[I].g[w[a][13]])) & Y ? " Grouped " : " ",
          K[0] ? "+ERI Ring:" : (K[1] + 1 ? "+ERI:" : (K[2] + 1 ? "+Box:" : ":")),
          ROW (w[a][20]), b[Y]);
        if (G[I].g[w[a][6]] & G[I].g[w[a][7]] & Y)
          printf ("r%dc%d", ROW (w[w[a][6]][20] | w[w[a][7]][20]),
            COL (w[w[a][6]][20] | w[w[a][7]][20]));
        else
          printf ("%s", S[w[a][G[I].g[w[a][6]] & Y ? 6 : 7]]);
        printf (" and %d @ %s Column %d between %d @ ",
          b[Y], S[K[3]], COL (w[a][20]), b[Y]);
        if (G[I].g[w[a][12]] & G[I].g[w[a][13]] & Y)
          printf ("r%dc%d", ROW (w[w[a][12]][20] | w[w[a][13]][20]),
            COL (w[w[a][12]][20] | w[w[a][13]][20]));
        else
          printf ("%s", S[w[a][G[I].g[w[a][12]] & Y ? 12 : 13]]);
        printf (" and %d @ %s\n", b[Y], S[K[4]]);
        if (K[0])
          printf ("ERI b%d%s => -%d @ r%dc%d r%dc%d r%dc%d\n",
            BOX (a), S[a], b[Y], ROW (w[w[K[3]][12]][20] | w[w[K[3]][13]][20] |
            w[w[a][8]][20] | w[w[a][9]][20] | w[w[a][10]][20] | w[w[a][11]][20]),
            COL (w[w[K[3]][12]][20] | w[w[K[3]][13]][20] | w[w[a][8]][20] |
            w[w[a][9]][20] | w[w[a][10]][20] | w[w[a][11]][20]),
            ROW (w[L][20] | w[w[L][12]][20] | w[w[L][13]][20]),
            COL (w[L][20] | w[w[L][12]][20] | w[w[L][13]][20]),
            ROW (w[K[5]][20] | w[w[K[4]][6]][20] | w[w[K[4]][7]][20] |
            w[M][20] | w[w[M][6]][20] | w[w[M][7]][20]),
            COL (w[K[5]][20] | w[w[K[4]][6]][20] | w[w[K[4]][7]][20] |
            w[M][20] | w[w[M][6]][20] | w[w[M][7]][20]));
        else if (K[1] + 1)
          printf ("ERI b%d%s => -%d @ %s r%dc%d\n",
            BOX (w[K[5]][K[6]]), S[w[K[5]][K[6]]], b[Y], S[K[5]],
            ROW (w[K[1]][20] | w[K[2]][20]), COL (w[K[1]][20] | w[K[2]][20]));
        else if (K[2] + 1)
          printf ("Box %d => -%d @ r%dc%d\n", BOX (X), b[Y],
            ROW (w[K[2]][20] | w[K[5]][20]), COL (w[K[2]][20] | w[K[5]][20]));
        else
          printf ("=> -%d @ %s\n", b[Y], S[K[5]]);
#endif
        goto START;
      }
    }
    for (a = 0; a < 81; ++a) // Search Empty Rectangle Intersection Cell position grid wise
    {
      int K[8] = {ERI (a)};  // Assign ERI Cell values

      for (; K[1] = K[0] & -K[0]; K[0] -= K[1])
                             // Search SL ERI digit wise
        for (y = 0; y < 2; ++y)
                             // Search SL Line wise
          for (Y = W[1][!y]; Y < W[2][!y]; ++Y)
          {                  // Search SL 1st Cell position Line wise
            if ((G[I].g[K[2] = w[a][Y]] & ~(G[I].g[w[K[2]][W[3][y]]] | G[I].g[w[K[2]][W[4][y]]]) & K[1]) &&
                             // Check ERI digit either in SL 1st Cell values; and not in mini-Line Cells values; and
              B[K[3] = !(G[I].g[w[K[2]][W[1][y]]] & K[1]) | (!(G[I].g[w[K[2]][W[18][y]]] & K[1]) << 1) |
              (!(G[I].g[w[K[2]][W[19][y]]] & K[1]) << 2) | (!(G[I].g[w[K[2]][W[20][y]]] & K[1]) << 3) |
              (!(G[I].g[w[K[2]][W[21][y]]] & K[1]) << 4) | (!(G[I].g[w[K[2]][W[22][y]]] & K[1]) << 5)] == 5)
            {                // No ERI digit found in six Line Cell positions
              K[4] = W[b[~K[3] & 63] < 4 ? 5 : 1][y];
              K[5] = W[Y < W[5][!y] ? 5 : 1][!y];
              K[6] = w[K[2]][W[1][y] + b[~K[3] & 63] - 1];
              K[7] = w[a][W[1][y] + b[~K[3] & 63] - 1];
              if (ERI (K[7]) &
                             // Check Dual Linked Empty Rectangle Intersection Cell values; and
                (G[I].g[K[7]] | G[I].g[w[K[7]][K[5]]] | G[I].g[w[K[7]][K[5] + 1]] | G[I].g[w[K[7]][K[5] + 2]] |
                G[I].g[a] | G[I].g[w[a][K[4]]] | G[I].g[w[a][K[4] + 1]] | G[I].g[w[a][K[4] + 2]] |
                G[I].g[w[a][K[5]]] | G[I].g[w[a][K[5] + 1]] | G[I].g[w[a][K[5] + 2]] |
                G[I].g[w[K[2]][W[3][!y]]] | G[I].g[w[K[2]][W[4][!y]]] |
                G[I].g[w[K[6]][W[3][!y]]] | G[I].g[w[K[6]][W[4][!y]]]) & K[1])
              {              // Dual Linked Empty Rectangle removals
                             // Drop Dual Linked Empty Rectangle ERI digit from removal Cells values
                G[I].g[K[7]] &= ~K[1];
                G[I].g[w[K[7]][K[5]]] &= ~K[1];
                G[I].g[w[K[7]][K[5] + 1]] &= ~K[1];
                G[I].g[w[K[7]][K[5] + 2]] &= ~K[1];
                G[I].g[a] &= ~K[1];
                G[I].g[w[a][K[4]]] &= ~K[1];
                G[I].g[w[a][K[4] + 1]] &= ~K[1];
                G[I].g[w[a][K[4] + 2]] &= ~K[1];
                G[I].g[w[a][K[5]]] &= ~K[1];
                G[I].g[w[a][K[5] + 1]] &= ~K[1];
                G[I].g[w[a][K[5] + 2]] &= ~K[1];
                G[I].g[w[K[2]][W[3][!y]]] &= ~K[1];
                G[I].g[w[K[2]][W[4][!y]]] &= ~K[1];
                G[I].g[w[K[6]][W[3][!y]]] &= ~K[1];
                G[I].g[w[K[6]][W[4][!y]]] &= ~K[1];
#if RJ > 2
                printf ("%d) Dual Linked Empty Rectangle: ERI %d @ b%d%s and ERI %d @ b%d%s SL %s %d between %d @ %s and %d @ %s\n=> -%d @ r%dc%d r%dc%d\n",
                  G[I].p, b[K[1]], BOX (a), S[a], b[K[1]], BOX (K[7]), S[K[7]], R_C, RCN (K[2]),
                  b[K[1]], S[K[2]], b[K[1]], S[w[K[2]][W[1][y] + b[~K[3] & 63] - 1]],
                  b[K[1]], ROW (w[K[7]][20] | w[w[K[7]][K[5]]][20] |
                  w[w[K[7]][K[5] + 1]][20] | w[w[K[7]][K[5] + 2]][20] |
                  w[w[K[6]][W[3][!y]]][20] | w[w[K[6]][W[4][!y]]][20] |
                  w[a][20] | w[w[a][K[5]]][20] | w[w[a][K[5] + 1]][20] |
                  w[w[a][K[5] + 2]][20] | w[w[K[2]][W[3][!y]]][20] |
                  w[w[K[2]][W[4][!y]]][20]), COL (w[K[7]][20] | w[w[K[7]][K[5]]][20] |
                  w[w[K[7]][K[5] + 1]][20] | w[w[K[7]][K[5] + 2]][20] |
                  w[w[K[6]][W[3][!y]]][20] | w[w[K[6]][W[4][!y]]][20] | w[a][20] |
                  w[w[a][K[5]]][20] | w[w[a][K[5] + 1]][20] | w[w[a][K[5] + 2]][20] |
                  w[w[K[2]][W[3][!y]]][20] | w[w[K[2]][W[4][!y]]][20]),
                  ROW (w[w[a][K[4]]][20] | w[w[a][K[4] + 1]][20] | w[w[a][K[4] + 2]][20]),
                  COL (w[w[a][K[4]]][20] | w[w[a][K[4] + 1]][20] | w[w[a][K[4] + 2]][20]));
#endif
                goto START;
              }
              if (!(G[I].g[K[7]] & K[1]))
                continue;    // Skip for no Empty Rectangle digit found in removal Cell position
                             // Drop ERI SL digit from Line Cell position
              G[I].g[K[7]] -= K[1];
#if RJ > 2
              printf ("%d) Empty Rectangle: ERI %d @ b%d%s SL %s %d between %d @ %s and %d @ %s => -%d @ %s\n",
                G[I].p, b[K[1]], BOX (a), S[a], R_C, RCN (K[2]), b[K[1]], S[K[2]],
                b[K[1]], S[w[K[2]][W[1][y] + b[~K[3] & 63] - 1]], b[K[1]], S[K[7]]);
              if (!(G[I].g[w[K[7]][W[3][!y]]] & K[1]) + !(G[I].g[w[K[7]][W[4][!y]]] & K[1]) +
                !(G[I].g[w[K[7]][W[1][!y]]] & K[1]) + !(G[I].g[w[K[7]][W[18][!y]]] & K[1]) +
                !(G[I].g[w[K[7]][W[19][!y]]] & K[1]) + !(G[I].g[w[K[7]][W[20][!y]]] & K[1]) +
                !(G[I].g[w[K[7]][W[21][!y]]] & K[1]) + !(G[I].g[w[K[7]][W[22][!y]]] & K[1]) == 7)
              {              // Check one ERI digit found in 2nd Line Cell positions
                G[I].g[K[2]] -= K[1];
                printf ("%d) Empty Rectangle: ERI %d @ b%d%s SL %s %d between %d @ %s and %d @ %s => -%d @ %s\n",
                  G[I].p, b[K[1]], BOX (a), S[a], y ? "Row" : "Column",
                  y ? ROW (w[K[7]][20]) : COL (w[K[7]][20]), b[K[1]], S[K[7]],
                  b[K[1]], S[w[K[2]][W[1][y] + b[~K[3] & 63] - 1]], b[K[1]], S[K[2]]);
              }              // Drop ERI SL digit from Line Cell position
#endif
              goto START;
            }
            if (!(ERI (K[2]) & K[1]))
              continue;      // Skip for no ERI digit found in SL 1st ERI Cell position
            for (K[3] = W[1][y]; K[3] < W[2][y]; ++K[3])
              if (ERI (w[K[2]][K[3]]) & K[1])
                break;       // Check ERI digit found in SL 2nd ERI Cell position
            if (K[3] == W[2][y])
              continue;      // Skip for no ERI digit found in SL 2nd ERI Cell position
            K[4] = w[K[2]][K[3]];
            K[5] = W[Y < W[5][!y] ? 5 : 1][!y];
            K[6] = W[K[3] < W[5][y] ? 5 : 1][y];
            K[7] = a - K[2] + K[4];
            if (ERI (K[7]) & // Check ERI digit found in Grouped Linked Empty Rectangle Intersection Cell values; and
              (G[I].g[a] | G[I].g[w[a][K[5]]] | G[I].g[w[a][K[5] + 1]] | G[I].g[w[a][K[5] + 2]] |
              G[I].g[K[2]] | G[I].g[w[K[2]][K[6]]] | G[I].g[w[K[2]][K[6] + 1]] | G[I].g[w[K[2]][K[6] + 2]] |
              G[I].g[K[4]] | G[I].g[w[K[7]][K[5]]] | G[I].g[w[K[7]][K[5] + 1]] | G[I].g[w[K[7]][K[5] + 2]] |
              G[I].g[K[7]] | G[I].g[w[a][K[6]]] | G[I].g[w[a][K[6] + 1]] | G[I].g[w[a][K[6] + 2]]) & K[1])
            {                // Grouped Linked Empty Rectangle Intersection removal Cell positions
                             // Drop Grouped Linked Empty Rectangle ERI digit from removal Cells values
              G[I].g[a] &= ~K[1];
              G[I].g[w[a][K[5]]] &= ~K[1];
              G[I].g[w[a][K[5] + 1]] &= ~K[1];
              G[I].g[w[a][K[5] + 2]] &= ~K[1];
              G[I].g[K[2]] &= ~K[1];
              G[I].g[w[K[2]][K[6]]] &= ~K[1];
              G[I].g[w[K[2]][K[6] + 1]] &= ~K[1];
              G[I].g[w[K[2]][K[6] + 2]] &= ~K[1];
              G[I].g[K[4]] &= ~K[1];
              G[I].g[w[K[7]][K[5]]] &= ~K[1];
              G[I].g[w[K[7]][K[5] + 1]] &= ~K[1];
              G[I].g[w[K[7]][K[5] + 2]] &= ~K[1];
              G[I].g[K[7]] &= ~K[1];
              G[I].g[w[a][K[6]]] &= ~K[1];
              G[I].g[w[a][K[6] + 1]] &= ~K[1];
              G[I].g[w[a][K[6] + 2]] &= ~K[1];
#if RJ > 2
              printf ("%d) Grouped Linked Empty Rectangle: ERI %d @ b%d%s and ERI %d @ b%d%s SL %s %d between ERI %d @ b%d%s and ERI %d @ b%d%s\n=> -%d @ r%dc%d r%dc%d\n",
                G[I].p, b[K[1]], BOX (a), S[a], b[K[1]], BOX (K[7]), S[K[7]], R_C, RCN (K[2]),
                b[K[1]], BOX (K[2]), S[K[2]], b[K[1]], BOX (K[4]), S[K[4]], b[K[1]],
                ROW (w[a][20] | w[K[7]][20] | w[w[a][K[6]]][20] | w[w[a][K[6] + 1]][20] |
                w[w[a][K[6] + 2]][20] | w[K[2]][20] | w[K[4]][20] | w[w[K[2]][K[6]]][20] |
                w[w[K[2]][K[6] + 1]][20] | w[w[K[2]][K[6] + 2]][20]),
                COL (w[a][20] | w[K[7]][20] | w[w[a][K[6]]][20] | w[w[a][K[6] + 1]][20] |
                w[w[a][K[6] + 2]][20] | w[K[2]][20] | w[K[4]][20] | w[w[K[2]][K[6]]][20] |
                w[w[K[2]][K[6] + 1]][20] | w[w[K[2]][K[6] + 2]][20]),
                ROW (w[w[a][K[5]]][20] | w[w[a][K[5] + 1]][20] | w[w[a][K[5] + 2]][20] |
                w[w[K[7]][K[5]]][20] | w[w[K[7]][K[5] + 1]][20] | w[w[K[7]][K[5] + 2]][20]),
                COL (w[w[a][K[5]]][20] | w[w[a][K[5] + 1]][20] | w[w[a][K[5] + 2]][20] |
                w[w[K[7]][K[5]]][20] | w[w[K[7]][K[5] + 1]][20] | w[w[K[7]][K[5] + 2]][20]));
#endif
              goto START;
            }
            if (!(G[I].g[K[7]] & K[1]))
              continue;      // Skip for no Grouped Empty Rectangle digit found in removal Cell position
                             // Drop ERI SL digit from Line Cell position
            G[I].g[K[7]] -= K[1];
#if RJ > 2
            printf ("%d) Grouped Empty Rectangle: ERI %d @ b%d%s SL %s %d between ERI %d @ b%d%s and ERI %d @ b%d%s => -%d @ %s\n",
              G[I].p, b[K[1]], BOX (a), S[a], R_C, RCN (K[2]), b[K[1]], BOX (K[2]), S[K[2]],
              b[K[1]], BOX (K[4]), S[K[4]], b[K[1]], S[K[7]]);
#endif
            goto START;
          }
    }
    for (y = G[I].p; y < q - 1; ++y)
    {                        // Search W-Wing Type 1, Type 2 and W-Ring 1st Wing Cell position unsolved Cell positions wise
      if (B[G[I].g[r[y]]] > 2)
        continue;            // Skip for 1st Wing Cell values > two digits
      for (Y = y + 1; Y < q; ++Y)
      {                      // Search W-Wing Type 1, Type 2 and W-Ring 2nd Wing Cell position unsolved Cell positions wise
        if (G[I].g[r[y]] != G[I].g[r[Y]] || (w[r[y]][20] & w[r[Y]][20] & 134217727))
          continue;          // Skip for either 1st and 2nd Wing Cells values not same; or 1st and 2nd Wing Cells positions in Unit
        int K[10] = {r[y], r[Y], G[I].g[r[y]], r[y] - COL (w[r[y]][20]) + COL (w[r[Y]][20]),
                    r[Y] - COL (w[r[Y]][20]) + COL (w[r[y]][20]),-1},
            A[3][2] = {{K[4] == w[K[0]][14] || K[4] == w[K[0]][15] || K[4] == w[K[0]][16] ? 17 : 14,
                      K[3] == w[K[0]][0] || K[3] == w[K[0]][1] || K[3] == w[K[0]][2] ? 3 : 0},
                      { 3, 3}, { 0, 1}},
            L,
            N;

        A[1][0] += A[0][0];
        A[1][1] += A[0][1];
        if ((w[K[0]][20] & W[25][0]) == (w[K[1]][20] & W[25][0]) ||
          (w[K[0]][20] & W[25][1]) == (w[K[1]][20] & W[25][1]))
        {                    // Check W-Wing Type 2 1st and 2nd Wing Cells positions either Band or Stack wise
          if ((w[K[0]][20] & W[25][1]) == (w[K[1]][20] & W[25][1]))
          {                  // Check 1st and 2nd Wing Cells positions Band wise
            A[1][0] = 20;
            A[2][1] = 0;
            L = w[w[K[0]][K[4] == w[K[0]][12] ? 13 : 12]][A[0][1]];
            K[5] = w[K[3]][6];
            K[6] = w[K[3]][7];
            K[7] = w[K[4]][6];
            K[8] = w[K[4]][7];
          }
          else
          {                  // 1st and 2nd Wing Cells positions Stack wise
            A[1][1] = 6;
            A[2][0] = 1;
            L = w[w[K[0]][K[3] == w[K[0]][6] ? 7 : 6]][A[0][0]];
            K[5] = w[K[3]][12];
            K[6] = w[K[3]][13];
            K[7] = w[K[4]][12];
            K[8] = w[K[4]][13];
          }
          if (((N = K[9] = LB3 (w[L][W[1][A[2][0]]], w[L][W[5][A[2][0]]], L, A[2][0]) & K[2]) ||
            (K[9] = LB3 (w[L][W[3][A[2][0]]], w[L][W[4][A[2][0]]], L, A[2][0]) & K[2])) &&
            ((G[I].g[K[3]] | G[I].g[K[4]] | G[I].g[K[5]] | G[I].g[K[6]] | G[I].g[K[7]] | G[I].g[K[8]]) & (K[2] - K[9])))
          {                  // (Type 2 01, 02) Check SL either Line or Box wise
            K[2] -= K[9];
            G[I].g[K[3]] &= ~K[2];
            G[I].g[K[4]] &= ~K[2];
            G[I].g[K[5]] &= ~K[2];
            G[I].g[K[6]] &= ~K[2];
            G[I].g[K[7]] &= ~K[2];
            G[I].g[K[8]] &= ~K[2];
#if RJ > 2
            printf ("%d) Grouped W-Wing Type 2 %s: %d @ %s %s SL %s %d between %d @ r%dc%d and %d @ r%dc%d\n=> -%d @ r%dc%d r%dc%d\n",
              G[I].p, A[2][0] ? "Stack" : "Band", b[G[I].g[K[0]]], S[K[0]], S[K[1]],
              K[9] ? (A[2][0] ? "Column" : "Row") : "Box",
              N ? (A[2][0] ? COL (w[L][20]) : ROW (w[L][20])) : BOX (L), b[K[9]],
              ROW (w[X][20] | w[w[X][W[3][A[2][0]]]][20] | w[w[X][W[4][A[2][0]]]][20]),
              COL (w[X][20] | w[w[X][W[3][A[2][0]]]][20] | w[w[X][W[4][A[2][0]]]][20]), b[K[9]],
              ROW (w[Z][20] | w[w[Z][W[3][A[2][0]]]][20] | w[w[Z][W[4][A[2][0]]]][20]),
              COL (w[Z][20] | w[w[Z][W[3][A[2][0]]]][20] | w[w[Z][W[4][A[2][0]]]][20]),
              b[K[2]], ROW (w[K[3]][20] | w[K[5]][20] | w[K[6]][20]),
              COL (w[K[3]][20] | w[K[5]][20] | w[K[6]][20]),
              ROW (w[K[4]][20] | w[K[7]][20] | w[K[8]][20]),
              COL (w[K[4]][20] | w[K[7]][20] | w[K[8]][20]));
#endif
            goto START;
          }
        }
        else                 // 1st and 2nd Wing Cells positions Grid wise
          for (a = 0; a < 2; ++a)
          {                  // Search W-Wing Type 1 SL Line wise
            for (K[6] = 0; K[6] < 2; ++K[6])
              for (K[7] = 0; K[7] < 2; ++K[7])
                if ((N = (G[I].g[K[8] = w[K[a]][W[3 + K[7]][!K[6]]]] |
                  G[I].g[w[K[8]][W[3][K[6]]]] | G[I].g[w[K[8]][W[4][K[6]]]]) &
                  G[I].g[K[9] = w[K[K[6] ? 4 - a : 3 + a]][W[3 + K[7]][!K[6]]]] & K[2]) &&
                  !(G[I].g[w[K[8]][W[1][K[6]]]] & N) + !(G[I].g[w[K[8]][W[18][K[6]]]] & N) +
                  !(G[I].g[w[K[8]][W[19][K[6]]]] & N) + !(G[I].g[w[K[8]][W[20][K[6]]]] & N) +
                  !(G[I].g[w[K[8]][W[21][K[6]]]] & N) + !(G[I].g[w[K[8]][W[22][K[6]]]] & N) > 4 &&
                  ((G[I].g[K[3]] | G[I].g[K[4]]) & (K[2] - N)))
                {            // (Type 1 01) Check SL Line wise
                  K[2] -= N;
                  G[I].g[K[3]] &= ~K[2];
                  G[I].g[K[4]] &= ~K[2];
#if RJ > 2
                  printf ("%d) Grouped W-Wing Type 1 Grid: %d @ %s %s SL %s %d between %d @ r%dc%d and %d @ %s\n=> -%d @ %s %s\n",
                    G[I].p, b[G[I].g[K[0]]], S[K[0]], S[K[1]], K[6] ? "Column" : "Row",
                    K[6] ? COL (w[K[8]][20]) : ROW (w[K[8]][20]), b[N],
                    ROW (w[K[8]][20] | w[w[K[8]][W[3][K[6]]]][20] | w[w[K[8]][W[4][K[6]]]][20]),
                    COL (w[K[8]][20] | w[w[K[8]][W[3][K[6]]]][20] | w[w[K[8]][W[4][K[6]]]][20]),
                    b[N], S[K[9]], b[K[2]], S[K[3]], S[K[4]]);
#endif
                  goto START;
                }
            int A[6] = {w[K[0]][W[1][a]], w[K[0]][W[18][a]], w[K[0]][W[19][a]],
                       w[K[1]][W[1][!a]], w[K[1]][W[18][!a]], w[K[1]][W[19][!a]]};

            if (K[3 + a] == A[0] || K[3 + a] == A[1] || K[3 + a] == A[2])
            {
              A[0] = w[K[0]][W[20][a]];
              A[1] = w[K[0]][W[21][a]];
              A[2] = w[K[0]][W[22][a]];
            }
            if (K[3 + a] == A[3] || K[3 + a] == A[4] || K[3 + a] == A[5])
            {
              A[3] = w[K[1]][W[20][!a]];
              A[4] = w[K[1]][W[21][!a]];
              A[5] = w[K[1]][W[22][!a]];
            }
            if ((N = ERI (K[3 + a]) & K[2]) && (B[N] < 2 ?
              ((G[I].g[K[3]] | G[I].g[K[4]]) & (K[2] - N)) : ((G[I].g[K[3]] | G[I].g[K[4]] |
              G[I].g[w[K[0]][W[3][a]]] | G[I].g[w[K[0]][W[4][a]]] | G[I].g[A[0]] | G[I].g[A[1]] |
              G[I].g[A[2]] | G[I].g[w[K[1]][W[3][!a]]] | G[I].g[w[K[1]][W[4][!a]]] |
              G[I].g[A[3]] | G[I].g[A[4]] | G[I].g[A[5]]) & N)))
            {                // (W-Wing Type 1 02, W-Ring 02) Check SL ERI wise
              if (B[N] < 2)
                K[2] -= N;
              G[I].g[K[3]] &= ~K[2];
              G[I].g[K[4]] &= ~K[2];
              if (B[N] > 1)
              {
                G[I].g[w[K[0]][W[3][a]]] &= ~N;
                G[I].g[w[K[0]][W[4][a]]] &= ~N;
                G[I].g[A[0]] &= ~N;
                G[I].g[A[1]] &= ~N;
                G[I].g[A[2]] &= ~N;
                G[I].g[w[K[1]][W[3][!a]]] &= ~N;
                G[I].g[w[K[1]][W[4][!a]]] &= ~N;
                G[I].g[A[3]] &= ~N;
                G[I].g[A[4]] &= ~N;
                G[I].g[A[5]] &= ~N;
              }
#if RJ > 2
              printf ("%d) W-%cing Type 1 Grid: %d @ %s %s ERI %d @ b%d%s => -%d @ %s %s",
                G[I].p, B[N] < 2 ? 'W' : 'R', b[G[I].g[K[0]]], S[K[0]], S[K[1]],
                b[N], BOX (K[3 + a]), S[K[3 + a]], b[K[2]], S[K[3]], S[K[4]]);
              if (B[N] > 1)
                printf (" r%dc%d r%dc%d",
                  ROW (w[w[K[0]][W[3][a]]][20] | w[w[K[0]][W[4][a]]][20] |
                  w[A[0]][20] | w[A[1]][20] | w[A[2]][20]),
                  COL (w[w[K[0]][W[3][a]]][20] | w[w[K[0]][W[4][a]]][20] |
                  w[A[0]][20] | w[A[1]][20] | w[A[2]][20]),
                  ROW (w[w[K[1]][W[3][!a]]][20] | w[w[K[1]][W[4][!a]]][20] |
                  w[A[3]][20] | w[A[4]][20] | w[A[5]][20]),
                  COL (w[w[K[1]][W[3][!a]]][20] | w[w[K[1]][W[4][!a]]][20] |
                  w[A[3]][20] | w[A[4]][20] | w[A[5]][20]));
              printf ("\n");
#endif
              goto START;
            }
          }
          for (a = A[2][0]; a <= A[2][1]; ++a)
            for (L = A[0][a]; L < A[1][a]; ++L)
            {                // Search W-Wing Type 1 and Type 2 SL Line and ERI wise
            if (((N = K[9] = LN1 (w[K[0]][L], w[K[3 + a]][L], w[X][A[0][!a]], a) & K[2]) ||
              (K[9] = ERI (X) & ERI (Z) & K[2])) && ((G[I].g[K[3]] | G[I].g[K[4]] |
              (K[5] + 1 ? G[I].g[K[5]] | G[I].g[K[6]] | G[I].g[K[7]] | G[I].g[K[8]] : 0)) & (K[2] - K[9])))
            {                // (Type 1 03, 04, Type 2 03, 04) Check SL either Line or ERI wise
              K[2] -= K[9];
              G[I].g[K[3]] &= ~K[2];
              G[I].g[K[4]] &= ~K[2];
              if (K[5] + 1)
              {
                G[I].g[K[5]] &= ~K[2];
                G[I].g[K[6]] &= ~K[2];
                G[I].g[K[7]] &= ~K[2];
                G[I].g[K[8]] &= ~K[2];
              }
#if RJ > 2
              printf ("%d) W-Wing Type %s: %d @ %s %s SL%s",
                G[I].p, A[2][0] != A[2][1] ? "1 Grid" : A[2][0] ? "2 Stack" : "2 Band", b[G[I].g[K[0]]],
                S[K[0]], S[K[1]], N ? (A[2][0] ? " Column " : " Row ") : " ");
              if (N)
                printf ("%d between %d @ ", A[2][0] ? COL (w[X][20]) : ROW (w[X][20]), b[K[9]]);
              else
                printf ("between ERI %d @ b%d", b[K[9]], BOX (X));
              printf ("%s and%s%d @ ", S[X], N ? " " : " ERI ", b[K[9]]);
              if (!N)
                printf ("b%d", BOX (Z));
              printf ("%s\n=> -%d @ r%dc%d r%dc%d\n", S[Z], b[K[2]],
                ROW (w[K[3]][20] | (K[5] + 1 ? w[K[5]][20] | w[K[6]][20] : 0)),
                COL (w[K[3]][20] | (K[5] + 1 ? w[K[5]][20] | w[K[6]][20] : 0)),
                ROW (w[K[4]][20] | (K[5] + 1 ? w[K[7]][20] | w[K[8]][20] : 0)),
                COL (w[K[4]][20] | (K[5] + 1 ? w[K[7]][20] | w[K[8]][20] : 0)));
#endif
              goto START;
            }
          }
      }
    }
    for (a = G[I].p; a < q; ++a)
    {                        // Search Strong Wing Type 1 and Strong Ring Type 1 Apex Cell unsolved Cell positions wise
      if (!(G[I].g[w[r[a]][0]] | G[I].g[w[r[a]][1]] | G[I].g[w[r[a]][2]] | G[I].g[w[r[a]][3]] |
        G[I].g[w[r[a]][4]] | G[I].g[w[r[a]][5]]) || !(G[I].g[w[r[a]][14]] | G[I].g[w[r[a]][15]] |
        G[I].g[w[r[a]][16]] | G[I].g[w[r[a]][17]] | G[I].g[w[r[a]][18]] | G[I].g[w[r[a]][19]]))
        continue;            // Skip for no unsolved Cell position found in Apex either Row or Column
      int K[10] = {r[a], 0}; // Assign Apex Cell position

      for (; K[1] < 6; ++K[1])
      {                      // Search 1st Wing Cell position Row wise
        if (!G[I].g[K[2] = w[K[0]][K[1]]] || !(K[6] = G[I].g[K[0]] & G[I].g[K[2]] &
                             // Skip for either 1st Wing Cell position not unsolved; or
          ~(G[I].g[w[K[0]][6]] | G[I].g[w[K[0]][7]] | G[I].g[w[K[2]][6]] | G[I].g[w[K[2]][7]] |
          G[I].g[Y = w[K[0]][X = K[1] < 3 ? 3 : 0]] | G[I].g[w[Y][6]] | G[I].g[w[Y][7]])))
          continue;          // No conjugate pair digit found in Apex and 1st Wing Cells values
        for (K[3] = 14; K[3] < 20; ++K[3])
        {                    // Search 2nd Wing Cell position Column wise
          if (!G[I].g[K[4] = w[K[0]][K[3]]] || !(K[7] = G[I].g[K[0]] & G[I].g[K[4]] &
                             // Skip for either 2nd Wing Cell position not unsolved; or
            ~(G[I].g[w[K[0]][12]] | G[I].g[w[K[0]][13]] | G[I].g[w[K[4]][12]] | G[I].g[w[K[4]][13]] |
            G[I].g[Y = w[K[0]][Z = K[3] < 17 ? 17 : 14]] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]])) ||
                             // No conjugate pair digit found in Apex and 2nd Wing Cells values; or
            (K[6] & K[7]) || !G[I].g[K[5] = w[K[4]][K[1]]] || !(K[8] = G[I].g[K[2]] & G[I].g[K[5]] &
                             // Conjugate pair digit in Apex and 1st Wing Cells values same as Apex and 2nd Wing Cells values; or removal Cell not unsolved; or
            ~(G[I].g[w[K[2]][12]] | G[I].g[w[K[2]][13]] | G[I].g[w[K[5]][12]] | G[I].g[w[K[5]][13]] |
            G[I].g[Y = w[K[2]][Z]] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]])) ||
                             // No conjugate pair digit found in 1st Wing and removal Cells values; or
            !(K[9] = G[I].g[K[4]] & G[I].g[K[5]] & ~(G[I].g[w[K[4]][6]] | G[I].g[w[K[4]][7]] | G[I].g[w[K[5]][6]] |
            G[I].g[w[K[5]][7]] | G[I].g[Y = w[K[4]][X]] | G[I].g[w[Y][6]] | G[I].g[w[Y][7]])))
            continue;        // No conjugate pair digit found in 2nd Wing and removal Cells values
          if (Y = K[8] & K[9])
          {                  // Check Strong Wing Type 1 for conjugate pair digit in 1st Wing and removal Cells values same as 2nd Wing and removal Cells values
#if RJ > 2
            printf ("%d) Strong Wing Type 1: SL %d @ r%dc%d %d @ r%dc%d %d @ r%dc%d r%dc%d => -%d @ %s => -%d @ %s %s\n",
              G[I].p, b[K[6]], ROW (w[K[0]][20] | w[K[2]][20]), COL (w[K[0]][20] | w[K[2]][20]),
              b[K[7]], ROW (w[K[0]][20] | w[K[4]][20]), COL (w[K[0]][20] | w[K[4]][20]),
              b[Y], ROW (w[K[2]][20] | w[K[5]][20]), COL (w[K[2]][20] | w[K[5]][20]),
              ROW (w[K[4]][20] | w[K[5]][20]), COL (w[K[4]][20] | w[K[5]][20]),
              b[G[I].g[K[5]] - Y], S[K[5]], b[Y], S[K[2]], S[K[4]]);
#endif
            G[I].g[K[5]] = Y;// Drop from removal Cell values
            G[I].g[K[2]] -= Y;
            G[I].g[K[4]] -= Y;
            goto START;
          }
          if (K[0] > K[2] || K[0] > K[4] ||
                             // Skip Strong Ring Type 1 for either Apex Cell position > 1st Wing Cell position; or Apex Cell position > 2nd Wing Cell position; or
            ((K[6] | K[7]) & K[8]) || ((K[6] | K[7] | K[8]) & K[9]) ||
                             //  Conjugate pair digit in 1st Wing and removal Cells values same; or conjugate pair digit in 2nd Wing and removal Cells values same; or
            (B[G[I].g[K[0]]] | B[G[I].g[K[2]]] | B[G[I].g[K[4]]] | B[G[I].g[K[5]]]) < 3)
            continue;        // No removal Cell values
#if RJ > 2
          printf ("%d) Strong Ring Type 1: SL %d @ r%dc%d %d @ r%dc%d %d @ r%dc%d %d @ r%dc%d\n=>",
            G[I].p, b[K[6]], ROW (w[K[0]][20] | w[K[2]][20]), COL (w[K[0]][20] | w[K[2]][20]),
            b[K[7]], ROW (w[K[0]][20] | w[K[4]][20]), COL (w[K[0]][20] | w[K[4]][20]),
            b[K[8]], ROW (w[K[2]][20] | w[K[5]][20]), COL (w[K[2]][20] | w[K[5]][20]),
            b[K[9]], ROW (w[K[4]][20] | w[K[5]][20]), COL (w[K[4]][20] | w[K[5]][20]));
          if (G[I].g[K[0]] - K[6] - K[7])
            printf (" -%d @ %s", b[G[I].g[K[0]] - K[6] - K[7]], S[K[0]]);
          if (G[I].g[K[2]] - K[6] - K[8])
            printf (" -%d @ %s", b[G[I].g[K[2]] - K[6] - K[8]], S[K[2]]);
          if (G[I].g[K[4]] - K[7] - K[9])
            printf (" -%d @ %s", b[G[I].g[K[4]] - K[7] - K[9]], S[K[4]]);
          if (G[I].g[K[5]] - K[8] - K[9])
            printf (" -%d @ %s", b[G[I].g[K[5]] - K[8] - K[9]], S[K[5]]);
          printf ("\n");
#endif
                             // Drop from removal Cells values
          G[I].g[K[0]] = K[6] | K[7];
          G[I].g[K[2]] = K[6] | K[8];
          G[I].g[K[4]] = K[7] | K[9];
          G[I].g[K[5]] = K[8] | K[9];
          goto START;
        }
      }
    }
    for (a = G[I].p; a < q; ++a)
    {                        // Search Strong Wing Type 2 and Strong Ring Type 2 Apex Cell unsolved Cell positions wise
      int K[12] = {r[a]};    // Assign Apex Cell position

      for (y = 0; y < 2; ++y)// Search Strong Wing Type 2 and Strong Ring Type 2 Chute wise
      {
        if (!(G[I].g[w[K[0]][W[1][y]]] | G[I].g[w[K[0]][W[18][y]]] | G[I].g[w[K[0]][W[19][y]]] |
          G[I].g[w[K[0]][W[20][y]]] | G[I].g[w[K[0]][W[21][y]]] | G[I].g[w[K[0]][W[22][y]]]) ||
          !(G[I].g[w[K[0]][W[6][y]]] | G[I].g[w[K[0]][W[7][y]]] | G[I].g[w[K[0]][W[8][y]]] |
          G[I].g[w[K[0]][W[9][y]]] | G[I].g[w[K[0]][W[10][y]]] | G[I].g[w[K[0]][W[11][y]]]))
          continue;          // Skip for no unsolved Cell position found in Apex either Line or Box
        for (K[1] = W[1][y]; K[1] < W[2][y]; ++K[1])
        {                    // Search 1st Wing Cell position Line wise
          if (!G[I].g[K[2] = w[K[0]][K[1]]] || !(K[6] = (G[I].g[K[0]] & G[I].g[K[2]] &
                             // Skip for either 1st Wing Cell position not unsolved; or
            ~(G[I].g[w[K[0]][W[3][y]]] | G[I].g[w[K[0]][W[4][y]]] | G[I].g[w[K[2]][W[3][y]]] |
            G[I].g[w[K[2]][W[4][y]]] | G[I].g[Y = w[K[0]][K[11] = W[K[1] < W[5][y] ? 5 : 1][y]]] |
            G[I].g[w[Y][W[3][y]]] | G[I].g[w[Y][W[4][y]]]))))
            continue;        // No conjugate pair digit found in Apex and 1st Wing Cells values
          for (K[3] = W[6][y]; K[3] < W[0][y]; ++K[3])
          {                  // Search 2nd Wing Cell position Box wise but not in 1st Wing Line
            if (!G[I].g[K[4] = w[K[0]][K[3]]] || !(K[7] = (G[I].g[K[0]] & G[I].g[K[4]] &
                             // Skip for either 2nd Wing Cell position not unsolved; or
              ~(G[I].g[w[K[0]][W[3][y]]] | G[I].g[w[K[0]][W[4][y]]] | G[I].g[w[K[4]][W[3][y]]] |
              G[I].g[w[K[4]][W[4][y]]] | G[I].g[Y = w[K[0]][Z = W[K[3] == W[6][y] || K[3] == W[7][y] ||
              K[3] == W[8][y] ? 4 : 3][!y]]] | G[I].g[w[Y][W[3][y]]] | G[I].g[w[Y][W[4][y]]]))) ||
              (K[6] & K[7])) // No Conjugate pair digit found in Apex and 2nd Wing Cells values; or
              continue;      // Conjugate pair digit in Apex and 1st Wing Cells values same as Apex and 2nd Wing Cells values
            for (X = K[10] = W[K[1] < W[5][y] ? 1 : 5][y]; X < K[10] + 3; ++X)
            {                // Search removal Cell position 1st Wing Line and 2nd Wing Box intersection wise
              if (!G[I].g[K[5] = w[K[4]][K[1]]] || !(K[8] = G[I].g[K[2]] & G[I].g[K[5]] &
                             // Skip for removal Cell not unsolved; or
                ~(G[I].g[w[K[2]][W[3][y]]] | G[I].g[w[K[2]][W[4][y]]] | G[I].g[w[K[5]][W[3][y]]] |
                G[I].g[w[K[5]][W[4][y]]] | G[I].g[Y = w[K[2]][Z]] | G[I].g[w[Y][W[3][y]]] |
                G[I].g[w[Y][W[4][y]]])) || !(K[9] = G[I].g[K[4]] & G[I].g[K[5]] & ~(G[I].g[w[K[4]][W[3][y]]] |
                             // No conjugate pair digit found in 1st Wing and removal Cells values; or
                G[I].g[w[K[4]][W[4][y]]] | G[I].g[w[K[5]][W[3][y]]] | G[I].g[w[K[5]][W[4][y]]] |
                G[I].g[Y = w[K[4]][K[11]]] | G[I].g[w[Y][W[3][y]]] | G[I].g[w[Y][W[4][y]]])))
                continue;    // No conjugate pair digit found in 2nd Wing and removal Cells values
              if (Y = K[8] & K[9])
              {              // Check Strong Wing Type 2 for conjugate pair digit in 1st Wing and removal Cells values same as 2nd Wing and removal Cells values
#if RJ > 2
                printf ("%d) Strong Wing Type 2: SL %d @ r%dc%d %d @ %s %s %d @ %s %s %d @ r%dc%d => -%d @ %s => -%d @ %s %s\n",
                  G[I].p, b[K[6]], ROW (w[K[0]][20] | w[K[2]][20]), COL (w[K[0]][20] |
                  w[K[2]][20]), b[K[7]], S[K[0]], S[K[4]], b[K[8]], S[K[2]], S[K[5]],
                  b[K[9]], ROW (w[K[4]][20] | w[K[5]][20]), COL (w[K[4]][20] |
                  w[K[5]][20]), b[G[I].g[K[5]] - Y], S[K[5]], b[Y], S[K[2]], S[K[4]]);
#endif
                             // Drop from removal Cell values
                G[I].g[K[5]] = Y;
                G[I].g[K[2]] -= Y;
                G[I].g[K[4]] -= Y;
                goto START;
              }
              if (K[0] > K[2] || K[0] > K[4] ||
                             // Skip Strong Ring Type 2 for either Apex Cell position > 1st Wing Cell position; or Apex Cell position > 2nd Wing Cell position; or
                ((K[6] | K[7]) & K[8]) || ((K[6] | K[7] | K[8]) & K[9]) ||
                             // Conjugate pair digit in 1st Wing and removal Cells values same; or conjugate pair digit in 2nd Wing and removal Cells values same; or
                (B[G[I].g[K[0]]] | B[G[I].g[K[2]]] | B[G[I].g[K[4]]] | B[G[I].g[K[5]]]) < 3)
                continue;    // No removal Cell values
#if RJ > 2
              printf ("%d) Strong Ring Type 2: SL %d @ r%dc%d %d @ %s %s %d @ %s %s %d @ r%dc%d\n=>",
              G[I].p, b[K[6]], ROW (w[K[0]][20] | w[K[2]][20]),
                COL (w[K[0]][20] | w[K[2]][20]), b[K[7]], S[K[0]], S[K[4]],
                b[K[8]], S[K[2]], S[K[5]], b[K[9]], ROW (w[K[4]][20] | w[K[5]][20]),
                COL (w[K[4]][20] | w[K[5]][20]));
              if (G[I].g[K[0]] - K[6] - K[7])
                printf (" -%d @ %s", b[G[I].g[K[0]] - K[6] - K[7]], S[K[0]]);
              if (G[I].g[K[2]] - K[6] - K[8])
                printf (" -%d @ %s", b[G[I].g[K[2]] - K[6] - K[8]], S[K[2]]);
              if (G[I].g[K[4]] - K[7] - K[9])
                printf (" -%d @ %s", b[G[I].g[K[4]] - K[7] - K[9]], S[K[4]]);
              if (G[I].g[K[5]] - K[8] - K[9])
                printf (" -%d @ %s", b[G[I].g[K[5]] - K[8] - K[9]], S[K[5]]);
              printf ("\n");
#endif
                             // Drop from removal Cells values
              G[I].g[K[0]] = K[6] | K[7];
              G[I].g[K[2]] = K[6] | K[8];
              G[I].g[K[4]] = K[7] | K[9];
              G[I].g[K[5]] = K[8] | K[9];
              goto START;
            }
          }
        }
      }
    }
    for (a = G[I].p; a < q; ++a)
    {                        // Search XY-Ring Type 1, XY-Wing Type 1, XY-Wing Type 1 Transport and XYZ-Transport Apex Cell unsolved Cell positions wise
      if (B[G[I].g[r[a]]] > 3 ||
                             // Skip for Apex Cell values > three digits; or
        !(G[I].g[w[r[a]][0]] | G[I].g[w[r[a]][1]] | G[I].g[w[r[a]][2]] |
        G[I].g[w[r[a]][3]] | G[I].g[w[r[a]][4]] | G[I].g[w[r[a]][5]]) ||
        !(G[I].g[w[r[a]][14]] | G[I].g[w[r[a]][15]] | G[I].g[w[r[a]][16]] |
        G[I].g[w[r[a]][17]] | G[I].g[w[r[a]][18]] | G[I].g[w[r[a]][19]]))
        continue;            // No unsolved Cell position found in Apex either Row or Column
      int K[9] = {r[a], 0};  // Assign Apex Cell position

      for (; K[1] < 6; ++K[1])
      {                      // Search 1st Wing Cell position Row wise
        if (B[G[I].g[K[2] = w[K[0]][K[1]]]] != 2 || B[G[I].g[K[0]] | G[I].g[K[2]]] != 3)
          continue;          // Skip for either 1st Wing Cell values not two digits; or Apex and 1st Wing Cells values not three digits
        for (K[3] = 14; K[3] < 20; ++K[3])
        {                    // Search 2nd Wing Cell position Column wise
          if (B[G[I].g[K[4] = w[K[0]][K[3]]]] != 2 || B[G[I].g[K[0]] | G[I].g[K[4]]] != 3)
            continue;        // Skip for either 2nd Wing Cell values not two digits; or Apex and 2nd Wing Cells values not three digits
          K[5] = K[1] < 3 ? 3 : 0;
          K[7] = K[3] < 17 ? 17 : 14;
          if (B[G[I].g[K[6] = K[2] - K[0] + K[4]]] == 2 && K[2] > K[0] && K[4] > K[0] &&
                             // Check XY-Ring Type 1 3rd Wing Cell values two digits; and 1st Wing Cell position > Apex Cell position; and 2nd Wing Cell position > Apex Cell position; and
            B[G[I].g[K[0]]] < 3 && !(G[I].g[K[2]] & G[I].g[K[4]]) && B[G[I].g[K[2]] | G[I].g[K[6]]] == 3 &&
                             // Apex Cell values two digits; and 1st and 2nd Wing Cells values four digits; and 1st and 3rd Wing Cells values three digits; and
            B[G[I].g[K[4]] | G[I].g[K[6]]] == 3 && !(G[I].g[K[0]] & G[I].g[K[6]]) &&
                             // 2nd and 3rd Wing Cells values three digits; and Apex and 3rd Wing Cells values four digits; and
            (((G[I].g[w[K[0]][6]] | G[I].g[w[K[0]][7]] | G[I].g[w[K[2]][6]] |
            G[I].g[w[K[2]][7]] | G[I].g[w[K[0]][K[5]]] | G[I].g[w[K[0]][K[5] + 1]] |
            G[I].g[w[K[0]][K[5] + 2]]) & G[I].g[K[0]] & G[I].g[K[2]]) ||
            ((G[I].g[w[K[4]][6]] | G[I].g[w[K[4]][7]] | G[I].g[w[K[6]][6]] |
            G[I].g[w[K[6]][7]] | G[I].g[w[K[4]][K[5]]] | G[I].g[w[K[4]][K[5] + 1]] |
            G[I].g[w[K[4]][K[5] + 2]]) & G[I].g[K[4]] & G[I].g[K[6]]) ||
            ((G[I].g[w[K[0]][12]] | G[I].g[w[K[0]][13]] | G[I].g[w[K[4]][12]] |
            G[I].g[w[K[4]][13]] | G[I].g[w[K[0]][K[7]]] | G[I].g[w[K[0]][K[7] + 1]] |
            G[I].g[w[K[0]][K[7] + 2]]) & G[I].g[K[0]] & G[I].g[K[4]]) ||
            ((G[I].g[w[K[2]][12]] | G[I].g[w[K[2]][13]] | G[I].g[w[K[6]][12]] |
            G[I].g[w[K[6]][13]] | G[I].g[w[K[2]][K[7]]] | G[I].g[w[K[2]][K[7] + 1]] |
            G[I].g[w[K[2]][K[7] + 2]]) & G[I].g[K[2]] & G[I].g[K[6]])))
          {                  // XY-Ring Type 1 removal Cell values
                             // Drop XY-Ring Type 1 Wing Cells common values from removal Cells values
          G[I].g[w[K[0]][6]] &= (X = ~(G[I].g[K[0]] & G[I].g[K[2]]));
          G[I].g[w[K[0]][7]] &= X;
          G[I].g[w[K[2]][6]] &= X;
          G[I].g[w[K[2]][7]] &= X;
          G[I].g[w[K[0]][K[5]]] &= X;
          G[I].g[w[K[0]][K[5] + 1]] &= X;
          G[I].g[w[K[0]][K[5] + 2]] &= X;
          G[I].g[w[K[4]][6]] &= (X = ~(G[I].g[K[4]] & G[I].g[K[6]]));
          G[I].g[w[K[4]][7]] &= X;
          G[I].g[w[K[6]][6]] &= X;
          G[I].g[w[K[6]][7]] &= X;
          G[I].g[w[K[4]][K[5]]] &= X;
          G[I].g[w[K[4]][K[5] + 1]] &= X;
          G[I].g[w[K[4]][K[5] + 2]] &= X;
          G[I].g[w[K[0]][12]] &= (X = ~(G[I].g[K[0]] & G[I].g[K[4]]));
          G[I].g[w[K[0]][13]] &= X;
          G[I].g[w[K[4]][12]] &= X;
          G[I].g[w[K[4]][13]] &= X;
          G[I].g[w[K[0]][K[7]]] &= X;
          G[I].g[w[K[0]][K[7] + 1]] &= X;
          G[I].g[w[K[0]][K[7] + 2]] &= X;
          G[I].g[w[K[2]][12]] &= (X = ~(G[I].g[K[2]] & G[I].g[K[6]]));
          G[I].g[w[K[2]][13]] &= X;
          G[I].g[w[K[6]][12]] &= X;
          G[I].g[w[K[6]][13]] &= X;
          G[I].g[w[K[2]][K[7]]] &= X;
          G[I].g[w[K[2]][K[7] + 1]] &= X;
          G[I].g[w[K[2]][K[7] + 2]] &= X;
#if RJ > 2
          printf ("%d) XY-Ring Type 1: %d @ r%dc%d r%dc%d => -%d @ r%dc%d => -%d @ r%dc%d => -%d @ r%dc%d => -%d @ r%dc%d\n",
            G[I].p, b[G[I].g[K[2]] | G[I].g[K[4]]], ROW (w[K[0]][20] | w[K[2]][20]),
            COL (w[K[0]][20] | w[K[2]][20]), ROW (w[K[4]][20] | w[K[6]][20]),
            COL (w[K[4]][20] | w[K[6]][20]), b[G[I].g[K[0]] & G[I].g[K[2]]],
            ROW (w[w[K[0]][6]][20] | w[w[K[0]][7]][20] | w[w[K[2]][6]][20] |
            w[w[K[2]][7]][20] | w[w[K[0]][K[5]]][20] | w[w[K[0]][K[5] + 1]][20] |
            w[w[K[0]][K[5] + 2]][20]), COL (w[w[K[0]][6]][20] | w[w[K[0]][7]][20] |
            w[w[K[2]][6]][20] | w[w[K[2]][7]][20] | w[w[K[0]][K[5]]][20] |
            w[w[K[0]][K[5] + 1]][20] | w[w[K[0]][K[5] + 2]][20]),
            b[G[I].g[K[4]] & G[I].g[K[6]]], ROW (w[w[K[4]][6]][20] | w[w[K[4]][7]][20] |
            w[w[K[6]][6]][20] | w[w[K[6]][7]][20] | w[w[K[4]][K[5]]][20] |
            w[w[K[4]][K[5] + 1]][20] | w[w[K[4]][K[5] + 2]][20]),
            COL (w[w[K[4]][6]][20] | w[w[K[4]][7]][20] | w[w[K[6]][6]][20] |
            w[w[K[6]][7]][20] | w[w[K[4]][K[5]]][20] | w[w[K[4]][K[5] + 1]][20] |
            w[w[K[4]][K[5] + 2]][20]), b[G[I].g[K[0]] & G[I].g[K[4]]],
            ROW (w[w[K[0]][12]][20] | w[w[K[0]][13]][20] | w[w[K[4]][12]][20] |
            w[w[K[4]][13]][20] | w[w[K[0]][K[7]]][20] | w[w[K[0]][K[7] + 1]][20] |
            w[w[K[0]][K[7] + 2]][20]), COL (w[w[K[0]][12]][20] | w[w[K[0]][13]][20] |
            w[w[K[4]][12]][20] | w[w[K[4]][13]][20] | w[w[K[0]][K[7]]][20] |
            w[w[K[0]][K[7] + 1]][20] | w[w[K[0]][K[7] + 2]][20]),
            b[G[I].g[K[2]] & G[I].g[K[6]]], ROW (w[w[K[2]][12]][20] | w[w[K[2]][13]][20] |
            w[w[K[6]][12]][20] | w[w[K[6]][13]][20] | w[w[K[2]][K[7]]][20] |
            w[w[K[2]][K[7] + 1]][20] | w[w[K[2]][K[7] + 2]][20]), COL (w[w[K[2]][12]][20] |
            w[w[K[2]][13]][20] | w[w[K[6]][12]][20] | w[w[K[6]][13]][20] |
            w[w[K[2]][K[7]]][20] | w[w[K[2]][K[7] + 1]][20] | w[w[K[2]][K[7] + 2]][20]));
#endif
            goto START;
          }
          if (B[G[I].g[K[0]] | G[I].g[K[2]] | G[I].g[K[4]]] != 3 ||
                             // Skip for either Apex and Wings Cells values not three digits; or
            B[K[5] = G[I].g[K[2]] & G[I].g[K[4]]] != 1)
            continue;        // Wing Cells common value not one digit
          if (~G[I].g[K[0]] & G[I].g[K[6]] & K[5])
          {                  // Check XY-Wing Type 1 removal Cell values
                             // Drop Wing Cells common value from XY-Wing Type 1 removal Cell position
            G[I].g[K[6]] -= K[5];
#if RJ > 2
            printf ("%d) XY-Wing Type 1: %d @ r%dc%d %s => -%d @ %s\n",
              G[I].p, b[G[I].g[K[2]] | G[I].g[K[4]]], ROW (w[K[0]][20] | w[K[2]][20]),
              COL (w[K[0]][20] | w[K[2]][20]), S[K[4]], b[K[5]], S[K[6]]);
#endif
            goto START;
          }
          int L,             // XY-Wing Type 1 Transport and XYZ-Transport
              M,
              N,
#if RJ > 2
              A[2][3] = {{-1,-1,-1}, {-1,-1,-1}},
#endif
              k[19] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};

          K[7] = K[1] < 3 ? 3 : 0;
          K[8] = K[3] < 17 ? 17 : 14;
          for (y = 0; y < 3; ++y)
          {
            X = w[K[0]][K[7] + y];
            if (ERI (X) & K[5])
            {                // ERI 01, 09, 25, Reduced ERI 05, 13, 17, 21, 29
              if (G[I].g[Y = w[K[4]][K[7] + y]] & K[5])
                k[0] = Y;
              if (~G[I].g[w[X][12]] & G[I].g[w[K[0]][13]] & K[5])
                k[1] = w[K[0]][13];
              else if (~G[I].g[w[X][13]] & G[I].g[w[K[0]][12]] & K[5])
                k[1] = w[K[0]][12];
#if RJ > 2
              k[18] = k[1] + 1 ? 6 : 2;
              A[0][0] = X;
#endif
              L = 0;
              Z = w[X][K[8]];
              if ((ERI (Z) & K[5]) || ((L = 9) && (ERI (Z + L) & K[5])) ||
                ((L = 18) && (ERI (Z + L) & K[5])))
              {              // ERI 09, Reduced ERI 13, 17, 21
                if (G[I].g[w[K[0]][K[8]] + L] & K[5])
                  k[2] = w[K[0]][K[8]] + L;
                if (~G[I].g[w[Z + L][6]] & G[I].g[w[Y][7]] & K[5])
                  k[3] = w[Y][7];
                else if (~G[I].g[w[Z + L][7]] & G[I].g[w[Y][6]] & K[5])
                  k[3] = w[Y][6];
#if RJ > 2
                if (k[3] + 1)
                  k[18] = 6;
                A[1][0] = Z + L;
#endif
              }
              else if ((((L = 12) && (ERI (w[Y][L]) & K[5])) ||
                ((L = 13) && (ERI (w[Y][L]) & K[5]))) &&
                ((G[I].g[M = w[K[4]][L]] | G[I].g[w[M][6]] | G[I].g[w[M][7]]) & K[5]))
              {              // ERI 25, Reduced ERI 29
                k[2] = M;
                k[3] = w[M][6];
                k[4] = w[M][7];
#if RJ > 2
                A[1][0] = w[Y][L];
#endif
              }
              if ((k[0] & k[1] & k[2] & k[3]) + 1)
                goto XYWT1Tf;
            }
            X = w[K[0]][K[8] + y];
            if (ERI (X) & K[5])
            {                // ERI 02, 10, 26, Reduced ERI 06, 14, 18, 22, 30
              if (G[I].g[Y = w[K[2]][K[8] + y]] & K[5])
                k[0] = Y;
              if (~G[I].g[w[X][6]] & G[I].g[w[K[0]][7]] & K[5])
                k[1] = w[K[0]][7];
              else if (~G[I].g[w[X][7]] & G[I].g[w[K[0]][6]] & K[5])
                k[1] = w[K[0]][6];
#if RJ > 2
              k[18] = k[1] + 1 ? 6 : 2;
              A[0][0] = X;
#endif
              L = 0;
              Z = w[X][K[7]];
              if ((ERI (Z) & K[5]) || ((L = 1) && (ERI (Z + L) & K[5])) ||
                ((L = 2) && (ERI (Z + L) & K[5])))
              {              // ERI 10, Reduced ERI 14, 18, 22
                if (G[I].g[w[K[0]][K[7]] + L] & K[5])
                  k[2] = w[K[0]][K[7]] + L;
                if (~G[I].g[w[Z + L][12]] & G[I].g[w[Y][13]] & K[5])
                  k[3] = w[Y][13];
                else if (~G[I].g[w[Z + L][13]] & G[I].g[w[Y][12]] & K[5])
                  k[3] = w[Y][12];
#if RJ > 2
                if (k[3] + 1)
                  k[18] = 6;
                A[1][0] = Z + L;
#endif
              }
              else if (((L = 6) && (ERI (w[Y][L]) & K[5])) ||
                ((L = 7) && (ERI (w[Y][L]) & K[5])))
              {              // ERI 26, Reduced ERI 30
                if ((G[I].g[M = w[K[2]][L]] | G[I].g[w[M][12]] | G[I].g[w[M][13]]) & K[5])
                {
                  k[2] = M;
                  k[3] = w[M][12];
                  k[4] = w[M][13];
                }
#if RJ > 2
                A[1][0] = w[Y][L];
#endif
              }
              if ((k[0] & k[1] & k[2] & k[3]) + 1)
                goto XYWT1Tf;
            }
            X = w[K[4]][K[7] + y];
            if (ERI (X) & K[5])
            {                // ERI 03, 11, 27, Reduced ERI 07, 15, 19, 23, 31
              if (G[I].g[Y = w[K[0]][K[7] + y]] & K[5])
                k[0] = Y;
              if (B[G[I].g[K[0]]] < 3)
              {              // Reduced ERI 07
                if (~G[I].g[w[X][12]] & G[I].g[w[K[6]][13]] & K[5])
                  k[1] = w[K[6]][13];
                else if (~G[I].g[w[X][13]] & G[I].g[w[K[6]][12]] & K[5])
                  k[1] = w[K[6]][12];
              }
#if RJ > 2
              k[18] = k[1] + 1 ? 6 : 2;
              A[0][0] = X;
#endif
              L = 0;
              Z = w[Y][K[8]];
              if ((ERI (Z) & K[5]) || ((L = 9) && (ERI (Z + L) & K[5])) ||
                ((L = 18) && (ERI (Z + L) & K[5])))
              {              // ERI 11, Reduced ERI 15, 19, 23
                if (B[G[I].g[K[0]]] < 3 && (G[I].g[w[K[2]][K[8]] + L] & K[5]))
                  k[2] = w[K[2]][K[8]] + L;
                if (~G[I].g[w[Z + L][6]] & G[I].g[w[Y][7]] & K[5])
                  k[3] = w[Y][7];
                else if (~G[I].g[w[Z + L][7]] & G[I].g[w[Y][6]] & K[5])
                  k[3] = w[Y][6];
#if RJ > 2
                if (k[3] + 1)
                  k[18] = 6;
                A[1][0] = Z + L;
#endif
              }
              else if (B[G[I].g[K[0]]] < 3 && (((L = 12) && (ERI (w[Y][L]) & K[5])) ||
                ((L = 13) && (ERI (w[Y][L]) & K[5]))) &&
                ((G[I].g[M = w[K[2]][L]] | G[I].g[w[M][6]] | G[I].g[w[M][7]]) & K[5]))
              {              // ERI 27, Reduced ERI 31
                k[2] = M;
                k[3] = w[M][6];
                k[4] = w[M][7];
#if RJ > 2
                A[1][0] = w[Y][L];
#endif
              }
              if ((k[0] & k[1] & k[2] & k[3]) + 1)
                goto XYWT1Tf;
            }
            X = w[K[2]][K[8] + y];
            if (ERI (X) & K[5])
            {                // ERI 04, 12, 28, Reduced ERI 08, 16, 20, 24, 32
              if (G[I].g[Y = w[K[0]][K[8] + y]] & K[5])
                k[0] = Y;
              if (B[G[I].g[K[0]]] < 3)
              {              // Reduced ERI 08
                if (~G[I].g[w[X][6]] & G[I].g[w[K[6]][7]] & K[5])
                  k[1] = w[K[6]][7];
                else if (~G[I].g[w[X][7]] & G[I].g[w[K[6]][6]] & K[5])
                  k[1] = w[K[6]][6];
              }
#if RJ > 2
              k[18] = k[1] + 1 ? 6 : 2;
              A[0][0] = X;
#endif
              L = 0;
              Z = w[Y][K[7]];
              if ((ERI (Z) & K[5]) || ((L = 1) && (ERI (Z + L) & K[5])) ||
                ((L = 2) && (ERI (Z + L) & K[5])))
              {              // ERI 12, Reduced ERI 16, 20, 24
                if (B[G[I].g[K[0]]] < 3 && (G[I].g[w[K[4]][K[7]] + L] & K[5]))
                  k[2] = w[K[4]][K[7]] + L;
                if (~G[I].g[w[Z + L][12]] & G[I].g[w[Y][13]] & K[5])
                  k[3] = w[Y][13];
                else if (~G[I].g[w[Z + L][13]] & G[I].g[w[Y][12]] & K[5])
                  k[3] = w[Y][12];
#if RJ > 2
                if (k[3] + 1)
                  k[18] = 6;
                A[1][0] = Z + L;
#endif
              }
              else if (B[G[I].g[K[0]]] < 3 && (((L = 6) && (ERI (w[Y][L]) & K[5])) ||
                ((L = 7) && (ERI (w[Y][L]) & K[5]))) &&
                ((G[I].g[M = w[K[4]][L]] | G[I].g[w[M][12]] | G[I].g[w[M][13]]) & K[5]))
              {              // ERI 28, Reduced ERI 32
                k[2] = M;
                k[3] = w[M][12];
                k[4] = w[M][13];
#if RJ > 2
                A[1][0] = w[Y][L];
#endif
              }
              if ((k[0] & k[1] & k[2] & k[3]) + 1)
               goto XYWT1Tf;
            }
            for (Y = 0; Y < 3; ++Y)
              if ((G[I].g[L = w[K[0]][K[8] + Y]] &
                LN1 (w[K[0]][K[7] + y], w[X][K[8] + Y], w[K[4]][K[7] + y], 1) & K[5]) ||
                (G[I].g[L = w[K[0]][K[7] + Y]] &
                LN1 (w[K[0]][K[8] + y], w[X][K[7] + Y], w[K[2]][K[8] + y], 0) & K[5]) ||
                (B[G[I].g[K[0]]] < 3 && ((G[I].g[L = w[K[2]][K[8] + Y]] &
                LN1 (w[K[4]][K[7] + y], w[w[K[0]][K[7] + y]][K[8] + Y],
                w[K[0]][K[7] + y], 1) & K[5]) || (G[I].g[L = w[K[4]][K[7] + Y]] &
                LN1 (w[K[2]][K[8] + y], w[w[K[0]][K[8] + y]][K[7] + Y],
                w[K[0]][K[8] + y], 0) & K[5]))))
              {              // Line 33, 34, 35, 36
                k[0] = L;
#if RJ > 2
                A[0][0] = X;
                A[1][0] = Z;
#endif
                goto XYWT1Tf;
              }
            for (k[18] = Y = 0; Y < 2; ++Y)
            {
              if (LN1 (w[K[0]][K[7] + y], w[M = w[K[4]][K[7] + y]][12 | Y],
                w[X][K[8]], 1) & (G[I].g[w[M][6]] | G[I].g[w[M][7]] |
                G[I].g[L = w[K[4]][12 | Y]] | G[I].g[w[L][6]] | G[I].g[w[L][7]]) & K[5])
              {              // Line 37
                k[0] = w[M][6];
                k[1] = w[M][7];
                k[2] = L;
                k[3] = w[L][6];
                k[4] = w[L][7];
#if RJ > 2
                A[0][0] = X;
                A[1][0] = Z;
#endif
                goto XYWT1Tf;
              }
              if (LN1 (w[K[0]][K[8] + y], w[M = w[K[2]][K[8] + y]][6 | Y],
                w[X][K[7]], 0) & (G[I].g[w[M][12]] | G[I].g[w[M][13]] |
                G[I].g[L = w[K[2]][6 | Y]] | G[I].g[w[L][12]] | G[I].g[w[L][13]]) & K[5])
              {              // Line 38
                k[0] = w[M][12];
                k[1] = w[M][13];
                k[2] = L;
                k[3] = w[L][12];
                k[4] = w[L][13];
#if RJ > 2
                A[0][0] = X;
                A[1][0] = Z;
#endif
                goto XYWT1Tf;
              }
              if (LN1 (w[K[4]][K[7] + y], w[M = w[K[0]][K[7] + y]][12 | Y],
                w[M][K[8]], 1) & (G[I].g[w[M][6]] | G[I].g[w[M][7]] | (B[G[I].g[K[0]]] > 2 ? 0 :
                G[I].g[L = w[K[2]][12 | Y]] | G[I].g[w[L][6]] | G[I].g[w[L][7]])) & K[5])
              {              // Line 39
                k[0] = w[M][6];
                k[1] = w[M][7];
                if (B[G[I].g[K[0]]] < 3)
                {
                  k[2] = L;
                  k[3] = w[L][6];
                  k[4] = w[L][7];
                }
#if RJ > 2
                A[0][0] = X;
                A[1][0] = Z;
#endif
                goto XYWT1Tf;
              }
              if (LN1 (w[K[2]][K[8] + y], w[M = w[K[0]][K[8] + y]][6 | Y],
                w[M][K[7]], 0) & (G[I].g[w[M][12]] | G[I].g[w[M][13]] | (B[G[I].g[K[0]]] > 2 ? 0 :
                G[I].g[L = w[K[4]][6 | Y]] | G[I].g[w[L][12]] | G[I].g[w[L][13]])) & K[5])
              {              // Line 40
                k[0] = w[M][12];
                k[1] = w[M][13];
                if (B[G[I].g[K[0]]] < 3)
                {
                  k[2] = L;
                  k[3] = w[L][12];
                  k[4] = w[L][13];
                }
#if RJ > 2
                A[0][0] = X;
                A[1][0] = Z;
#endif
                goto XYWT1Tf;
              }
            }
            if (((N = LN1 (w[K[0]][K[8] + y], w[K[2]][K[8] + y], w[X][K[7]], 0) & K[5]) ||
              (ERI (X) & ERI (Z) & K[5])) &&
              (((G[I].g[w[K[0]][12]] | G[I].g[w[K[0]][13]] | G[I].g[w[K[4]][12]] | G[I].g[w[K[4]][13]] |
              (N ? G[I].g[w[X][12]] | G[I].g[w[X][13]] | G[I].g[w[Z][12]] | G[I].g[w[Z][13]] :
              G[I].g[X] | G[I].g[Z] | G[I].g[L = w[X][K[7]]] | G[I].g[w[L][6]] | G[I].g[w[L][7]]) |
              G[I].g[w[K[2]][12]] | G[I].g[w[K[2]][13]] | G[I].g[K[6]] | G[I].g[w[K[6]][12]] | G[I].g[w[K[6]][13]]) & K[5]) ||
              ((G[I].g[w[K[0]][6]] | G[I].g[w[K[0]][7]] | G[I].g[w[K[2]][6]] | G[I].g[w[K[2]][7]] |
              G[I].g[w[K[0]][K[7]]] | G[I].g[w[w[K[0]][K[7]]][6]] | G[I].g[w[w[K[0]][K[7]]][7]]) & (G[I].g[K[2]] ^ K[5])) ||
              ((G[I].g[w[K[0]][12]] | G[I].g[w[K[0]][13]] | G[I].g[w[K[4]][12]] | G[I].g[w[K[4]][13]] |
              G[I].g[X] | G[I].g[w[X][12]] | G[I].g[w[X][13]]) & (G[I].g[K[4]] ^ K[5]))))
            {                // Line Ring 41, ERI Ring 43
              if (B[G[I].g[K[0]]] > 2)
                k[0] = K[6];
              k[1] = w[K[6]][12];
              k[2] = w[K[6]][13];
              k[5] = w[K[2]][12];
              k[10] = w[K[2]][13];
              k[11] = w[K[4]][12];
              k[12] = w[K[4]][13];
              k[13] = w[K[0]][12];
              k[14] = w[K[0]][13];
#if RJ > 2
              k[18] = N ? 8 : 10;
              A[0][0] = X;
              A[1][0] = Z;
#endif
              if (N)
              {              // Line Ring 41
                k[3] = w[Z][12];
                k[4] = w[Z][13];
                k[6] = w[X][12];
                k[7] = w[X][13];
              }
              else
              {              // ERI Ring 43
                k[3] = Z;
                k[4] = X;
                k[6] = L;
                k[7] = w[L][6];
                k[9] = w[L][7];
              }
              goto XYWT1Tf;
            }
            if (((N = LN1 (w[K[0]][K[7] + y], w[K[4]][K[7] + y], w[X][K[8]], 1) & K[5]) ||
              (ERI (X) & ERI (Z) & K[5])) &&
              (((G[I].g[w[K[0]][6]] | G[I].g[w[K[0]][7]] | G[I].g[w[K[4]][6]] | G[I].g[w[K[4]][7]] |
              (N ? G[I].g[w[X][6]] | G[I].g[w[X][7]] | G[I].g[w[Z][6]] | G[I].g[w[Z][7]] :
              G[I].g[X] | G[I].g[Z] | G[I].g[L = w[X][K[8]]] | G[I].g[w[L][12]] | G[I].g[w[L][13]]) |
              G[I].g[w[K[2]][6]] | G[I].g[w[K[2]][7]] | G[I].g[K[6]] | G[I].g[w[K[6]][6]] | G[I].g[w[K[6]][7]]) & K[5]) ||
              ((G[I].g[w[K[0]][6]] | G[I].g[w[K[0]][7]] | G[I].g[w[K[2]][6]] | G[I].g[w[K[2]][7]] |
              G[I].g[X] | G[I].g[w[X][6]] | G[I].g[w[X][7]]) & (G[I].g[K[2]] ^ K[5])) ||
              ((G[I].g[w[K[0]][12]] | G[I].g[w[K[0]][13]] | G[I].g[w[K[4]][12]] | G[I].g[w[K[4]][13]] |
              G[I].g[w[K[0]][K[8]]] | G[I].g[w[w[K[0]][K[8]]][12]] | G[I].g[w[w[K[0]][K[8]]][13]]) & (G[I].g[K[4]] ^ K[5]))))
            {                // Line Ring 42, ERI Ring 44
              if (B[G[I].g[K[0]]] > 2)
                k[0] = K[6];
              k[1] = w[K[6]][6];
              k[2] = w[K[6]][7];
              k[5] = w[K[4]][6];
              k[10] = w[K[4]][7];
              k[11] = w[K[2]][6];
              k[12] = w[K[2]][7];
              k[13] = w[K[0]][6];
              k[14] = w[K[0]][7];
#if RJ > 2
              k[18] = N ? 8 : 10;
              A[0][0] = X;
              A[1][0] = Z;
#endif
              if (N)
              {              // Line Ring 42
                k[3] = w[Z][6];
                k[4] = w[Z][7];
                k[6] = w[X][6];
                k[7] = w[X][7];
              }
              else
              {              // ERI Ring 44
                k[3] = Z;
                k[4] = X;
                k[6] = L;
                k[7] = w[L][12];
                k[9] = w[L][13];
              }
              goto XYWT1Tf;
            }
          }
          if ((ERI (K[0]) & K[5]) &&
            (((G[I].g[y = w[K[0]][K[7]]] | G[I].g[w[y][6]] | G[I].g[w[y][7]] | G[I].g[w[K[2]][6]] | G[I].g[w[K[2]][7]] |
            G[I].g[Y = w[K[0]][K[8]]] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]] | G[I].g[w[K[4]][12]] | G[I].g[w[K[4]][13]]) & K[5]) ||
            ((G[I].g[w[K[0]][6]] | G[I].g[w[K[0]][7]] | G[I].g[w[K[2]][6]] | G[I].g[w[K[2]][7]] |
            G[I].g[y] | G[I].g[w[y][6]] | G[I].g[w[y][7]]) & (G[I].g[K[2]] ^ K[5])) ||
            ((G[I].g[w[K[0]][12]] | G[I].g[w[K[0]][13]] | G[I].g[w[K[4]][12]] | G[I].g[w[K[4]][13]] |
            G[I].g[Y] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]]) & (G[I].g[K[4]] ^ K[5]))))
          {                  // ERI Ring 45
            k[0] = y;
            k[1] = w[y][6];
            k[2] = w[y][7];
            k[3] = w[K[2]][6];
            k[5] = w[K[2]][7];
            k[10] = Y;
            k[11] = w[Y][12];
            k[12] = w[Y][13];
            k[13] = w[K[4]][12];
            k[14] = w[K[4]][13];
#if RJ > 2
            k[18] = 10;
            A[0][0] = K[0];
#endif
            goto XYWT1Tf;
          }
          if (B[G[I].g[K[0]]] < 3 && (ERI (K[6]) & K[5]) &&
            (((G[I].g[y = w[K[4]][K[7]]] | G[I].g[w[y][6]] | G[I].g[w[y][7]] | G[I].g[w[K[4]][6]] | G[I].g[w[K[4]][7]] |
            G[I].g[Y = w[K[2]][K[8]]] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]] | G[I].g[w[K[2]][12]] | G[I].g[w[K[2]][13]]) & K[5]) ||
            ((G[I].g[w[K[0]][6]] | G[I].g[w[K[0]][7]] | G[I].g[w[K[2]][6]] | G[I].g[w[K[2]][7]] |
            G[I].g[w[K[0]][K[7]]] | G[I].g[w[w[K[0]][K[7]]][6]] | G[I].g[w[w[K[0]][K[7]]][7]]) & (G[I].g[K[2]] ^ K[5])) ||
            ((G[I].g[w[K[0]][12]] | G[I].g[w[K[0]][13]] | G[I].g[w[K[4]][12]] | G[I].g[w[K[4]][13]] |
            G[I].g[w[K[0]][K[8]]] | G[I].g[w[w[K[0]][K[8]]][12]] | G[I].g[w[w[K[0]][K[8]]][13]]) & (G[I].g[K[4]] ^ K[5]))))
          {                  // ERI Ring 46
            k[0] = w[K[4]][6];
            k[1] = w[K[4]][7];
            k[2] = y;
            k[3] = w[y][6];
            k[5] = w[y][7];
            k[10] = w[K[2]][12];
            k[11] = w[K[2]][13];
            k[12] = Y;
            k[13] = w[Y][12];
            k[14] = w[Y][13];
#if RJ > 2
            k[18] = 10;
            A[0][0] = K[6];
#endif
            goto XYWT1Tf;
          }
          for (y = 0; y < 2; ++y)
          {
            if (B[G[I].g[K[0]]] < 3)
            {
              if ((G[I].g[L = w[K[2]][12 | y]] | G[I].g[w[L][6]] | G[I].g[w[L][7]]) &
                ERI (w[K[0]][12 | y]) & K[5])
              {              // ERI 47
                k[0] = L;
                k[1] = w[L][6];
                k[2] = w[L][7];
#if RJ > 2
                k[18] = 2;
                A[0][0] = w[K[0]][12 | y];
#endif
                goto XYWT1Tf;
              }
              if ((G[I].g[L = w[K[4]][6 | y]] | G[I].g[w[L][12]] | G[I].g[w[L][13]]) &
                ERI (w[K[0]][6 | y]) & K[5])
              {              // ERI 48
                k[0] = L;
                k[1] = w[L][12];
                k[2] = w[L][13];
#if RJ > 2
                k[18] = 2;
                A[0][0] = w[K[0]][6 | y];
#endif
                goto XYWT1Tf;
              }
            }
            if ((G[I].g[L = w[K[2]][6 | y]] | (B[G[I].g[K[0]]] > 2 ? 0 :
              G[I].g[w[L][12]] | G[I].g[w[L][13]])) & ERI (w[K[6]][6 | y]) & K[5])
            {                // ERI 49
              k[0] = L;
              if (B[G[I].g[K[0]]] < 3)
              {
                k[1] = w[L][12];
                k[2] = w[L][13];
              }
#if RJ > 2
              k[18] = 2;
              A[0][0] = w[K[6]][6 | y];
#endif
              goto XYWT1Tf;
            }
            if ((G[I].g[L = w[K[4]][12 | y]] | (B[G[I].g[K[0]]] > 2 ? 0 :
              G[I].g[w[L][6]] | G[I].g[w[L][7]])) & ERI (w[K[6]][12 | y]) & K[5])
            {                // ERI 50
              k[0] = L;
              if (B[G[I].g[K[0]]] < 3)
              {
                k[1] = w[L][6];
                k[2] = w[L][7];
              }
#if RJ > 2
              k[18] = 2;
              A[0][0] = w[K[6]][12 | y];
#endif
              goto XYWT1Tf;
            }
            if ((N = LB3 (w[K[0]][12 | y], w[K[2]][12 | y], w[X][K[7]], 0) & K[5]) ||
              LB3 (w[K[0]][K[7]], w[X][13 ^ y], w[X][12 | y], 0) & K[5])
            {                // Box 51, Line 55, 67, Reduced Line Ring 59, 63
              if (G[I].g[w[K[0]][13 ^ y]] & K[5])
                k[0] = w[K[0]][13 ^ y];
#if RJ > 2
              k[18] = !N;
              A[0][0] = X;
              A[0][1] = w[X][6];
              A[0][2] = w[X][7];
              A[1][0] = Z;
              A[1][1] = w[Z][6];
              A[1][2] = w[Z][7];
#endif
              if (N)
              {
                if ((~(G[I].g[w[X][6]] | G[I].g[w[X][7]]) & K[5]) &&
                  (((G[I].g[L = w[K[0]][K[8]]] | G[I].g[w[L][12]] | G[I].g[w[L][13]] |
                  G[I].g[w[K[4]][12]] | G[I].g[w[K[4]][13]] | G[I].g[w[K[2]][6]] | G[I].g[w[K[2]][7]] |
                  G[I].g[M = w[K[2]][13 ^ y]] | G[I].g[w[M][6]] | G[I].g[w[M][7]] |
                  ((G[I].g[w[Z][6]] | G[I].g[w[Z][7]]) & K[5] ? 0 :
                  G[I].g[Y = w[K[2]][K[8]]] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]] |
                  G[I].g[K[6]] | G[I].g[w[K[6]][12]] | G[I].g[w[K[6]][13]])) & K[5]) ||
                  ((G[I].g[w[K[0]][6]] | G[I].g[w[K[0]][7]] | G[I].g[w[K[2]][6]] | G[I].g[w[K[2]][7]] |
                  G[I].g[Y = w[K[0]][K[7]]] | G[I].g[w[Y][6]] | G[I].g[w[Y][7]]) & (G[I].g[K[2]] ^ K[5])) ||
                  ((G[I].g[w[K[0]][12]] | G[I].g[w[K[0]][13]] | G[I].g[w[K[4]][12]] | G[I].g[w[K[4]][13]] |
                  G[I].g[Y = w[K[0]][K[8]]] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]]) & (G[I].g[K[4]] ^ K[5]))))
                {            // Reduced Line Ring 59, 63
                  k[1] = L;
                  k[2] = w[L][12];
                  k[3] = w[L][13];
                  k[5] = w[K[2]][6];
                  k[10] = w[K[2]][7];
                  k[11] = M;
                  k[12] = w[M][6];
                  k[13] = w[M][7];
                  k[14] = w[K[4]][12];
                  k[6] = w[K[4]][13];
#if RJ > 2
                  k[18] = 12;
                  A[0][1] = -1;
#endif
                  if (~(G[I].g[w[Z][6]] | G[I].g[w[Z][7]]) & K[5])
                  {          // Reduced Line Ring 63
                    k[7] = w[K[2]][K[8]];
                    k[8] = w[k[7]][12];
                    k[15] = w[k[7]][13];
                    k[16] = w[K[6]][12];
                    k[17] = w[K[6]][13];
                    if (B[G[I].g[K[0]]] > 2)
                      k[9] = K[6];
#if RJ > 2
                    A[1][1] = -1;
#endif
                  }
                }
                else if (B[G[I].g[K[0]]] < 3 && (~G[I].g[X] & K[5]) &&
                  (((G[I].g[Y = w[K[4]][L = 6]] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]]) &
                  ~G[I].g[w[X][7]] & K[5]) ||
                  ((G[I].g[Y = w[K[4]][L = 7]] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]]) &
                  ~G[I].g[w[X][6]] & K[5])))
                {            // Line 67
                  k[1] = Y;
                  k[2] = w[Y][12];
                  k[3] = w[Y][13];
#if RJ > 2
                  A[0][0] = w[X][L];
                  A[0][1] = -1;
#endif
                }
              }
            }
            else if (B[G[I].g[K[0]]] < 3 &&
              (LB3 (w[K[2]][12 | y], w[w[K[0]][12 | y]][K[7]], w[K[0]][12 | y], 0) & K[5]) &&
              ((G[I].g[w[K[4]][L = K[7]]] & ~(G[I].g[w[Z][6]] | G[I].g[w[Z][7]]) & K[5]) ||
              (G[I].g[w[K[4]][++L]] & ~(G[I].g[Z] | G[I].g[w[Z][7]]) & K[5]) ||
              (G[I].g[w[K[4]][++L]] & ~(G[I].g[Z] | G[I].g[w[Z][6]]) & K[5])))
            {                // Line 71
              k[0] = w[K[4]][L];
#if RJ > 2
              A[0][0] = w[w[K[0]][12 | y]][L];
              A[0][1] = -1;
              A[1][0] = X;
              A[1][1] = w[X][6];
              A[1][2] = w[X][7];
#endif
            }
            else if ((G[I].g[Y = w[K[0]][K[7]]] | G[I].g[w[Y][6]] | G[I].g[w[Y][7]]) &
              LN3 (w[K[0]][12 | y], w[X][K[7]], w[K[2]][12 | y], 0) & K[5])
            {                // Line 75
              k[0] = Y;
              k[1] = w[Y][6];
              k[2] = w[Y][7];
#if RJ > 2
              A[0][0] = Z;
              A[0][1] = -1;
              A[1][0] = X;
              A[1][1] = w[X][6];
              A[1][2] = w[X][7];
#endif
            }
            if ((k[0] & k[1]) + 1)
              goto XYWT1Tf;
            if ((N = LB3 (w[K[0]][6 | y], w[K[4]][6 | y], w[X][K[8]], 1) & K[5]) ||
              LB3 (w[K[0]][K[8]], w[X][7 ^ y], w[X][6 | y], 1) & K[5])
            {                // Box 52, Line 56, 68, Reduced Line Ring 60, 64
              if (G[I].g[w[K[0]][7 ^ y]] & K[5])
                k[0] = w[K[0]][7 ^ y];
#if RJ > 2
              k[18] = !N;
              A[0][0] = X;
              A[0][1] = w[X][12];
              A[0][2] = w[X][13];
              A[1][0] = Z;
              A[1][1] = w[Z][12];
              A[1][2] = w[Z][13];
#endif
              if (N)
              {
                if ((~(G[I].g[w[X][12]] | G[I].g[w[X][13]]) & K[5]) &&
                  (((G[I].g[L = w[K[0]][K[7]]] | G[I].g[w[L][6]] | G[I].g[w[L][7]] |
                  G[I].g[w[K[2]][6]] | G[I].g[w[K[2]][7]] | G[I].g[w[K[4]][12]] | G[I].g[w[K[4]][13]] |
                  G[I].g[M = w[K[4]][7 ^ y]] | G[I].g[w[M][12]] | G[I].g[w[M][13]] |
                  ((G[I].g[w[Z][12]] | G[I].g[w[Z][13]]) & K[5] ? 0 :
                  G[I].g[Y = w[K[4]][K[7]]] | G[I].g[w[Y][6]] | G[I].g[w[Y][7]] |
                  G[I].g[K[6]] | G[I].g[w[K[6]][6]] | G[I].g[w[K[6]][7]])) & K[5]) ||
                  ((G[I].g[w[K[0]][6]] | G[I].g[w[K[0]][7]] | G[I].g[w[K[2]][6]] | G[I].g[w[K[2]][7]] |
                  G[I].g[Y = w[K[0]][K[7]]] | G[I].g[w[Y][6]] | G[I].g[w[Y][7]]) & (G[I].g[K[2]] ^ K[5])) ||
                  ((G[I].g[w[K[0]][12]] | G[I].g[w[K[0]][13]] | G[I].g[w[K[4]][12]] | G[I].g[w[K[4]][13]] |
                  G[I].g[Y = w[K[0]][K[8]]] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]]) & (G[I].g[K[4]] ^ K[5]))))
                {            // Reduced Line Ring 60, 64
                  k[1] = L;
                  k[2] = w[L][6];
                  k[3] = w[L][7];
                  k[5] = w[K[2]][6];
                  k[10] = w[K[2]][7];
                  k[11] = M;
                  k[12] = w[M][12];
                  k[13] = w[M][13];
                  k[14] = w[K[4]][12];
                  k[6] = w[K[4]][13];
#if RJ > 2
                  k[18] = 12;
                  A[0][1] = -1;
#endif
                  if (~(G[I].g[w[Z][12]] | G[I].g[w[Z][13]]) & K[5])
                  {          // Reduced Line Ring 64
                    k[7] = w[K[4]][K[7]];
                    k[8] = w[k[7]][6];
                    k[15] = w[k[7]][7];
                    k[16] = w[K[6]][6];
                    k[17] = w[K[6]][7];
                    if (B[G[I].g[K[0]]] > 2)
                      k[9] = K[6];
#if RJ > 2
                    A[1][1] = -1;
#endif
                  }
                }
                else if (B[G[I].g[K[0]]] < 3 && (~G[I].g[X] & K[5]) &&
                  (((G[I].g[Y = w[K[2]][L = 12]] | G[I].g[w[Y][6]] | G[I].g[w[Y][7]]) &
                  ~G[I].g[w[X][13]] & K[5]) ||
                  ((G[I].g[Y = w[K[2]][L = 13]] | G[I].g[w[Y][6]] | G[I].g[w[Y][7]]) &
                  ~G[I].g[w[X][12]] & K[5])))
                {            // Line 68
                  k[1] = Y;
                  k[2] = w[Y][6];
                  k[3] = w[Y][7];
#if RJ > 2
                  A[0][0] = w[X][L];
                  A[0][1] = -1;
#endif
                }
              }
            }
            else if (B[G[I].g[K[0]]] < 3 &&
              (LB3 (w[K[4]][6 | y], w[w[K[0]][6 | y]][K[8]], w[K[0]][6 | y], 1) & K[5]) &&
              ((G[I].g[w[K[2]][L = K[8]]] & ~(G[I].g[w[Z][12]] | G[I].g[w[Z][13]]) & K[5]) ||
              (G[I].g[w[K[2]][++L]] & ~(G[I].g[Z] | G[I].g[w[Z][13]]) & K[5]) ||
              (G[I].g[w[K[2]][++L]] & ~(G[I].g[Z] | G[I].g[w[Z][12]]) & K[5])))
            {                // Line 72
              k[0] = w[K[2]][L];
#if RJ > 2
              A[0][0] = w[w[K[0]][6 | y]][L];
              A[0][1] = -1;
              A[1][0] = X;
              A[1][1] = w[X][12];
              A[1][2] = w[X][13];
#endif
            }
            else if ((G[I].g[Y = w[K[0]][K[8]]] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]]) &
              LN3 (w[K[0]][6 | y], w[X][K[8]], w[K[4]][6 | y], 1) & K[5])
            {                // Line 76
              k[0] = Y;
              k[1] = w[Y][12];
              k[2] = w[Y][13];
#if RJ > 2
              A[0][0] = Z;
              A[0][1] = -1;
              A[1][0] = X;
              A[1][1] = w[X][12];
              A[1][2] = w[X][13];
#endif
            }
            if ((k[0] & k[1]) + 1)
              goto XYWT1Tf;
            if ((N = LB3 (w[K[6]][12 | y], w[K[4]][12 | y], w[Z][K[7]], 0) & K[5]) ||
              (B[G[I].g[K[0]]] < 3 && LB3 (w[K[4]][K[7]], w[X][13 ^ y], w[X][12 | y], 0) & K[5]))
            {                // Box 53, Line 57, 69, 69a, Reduced Line Ring 61, 65
              if (B[G[I].g[K[0]]] < 3)
              {
                if (G[I].g[w[K[6]][13 ^ y]] & K[5])
                  k[0] = w[K[6]][13 ^ y];
              }
              else if (~(G[I].g[w[Z][6]] | G[I].g[w[Z][7]]) & (G[I].g[K[6]] | G[I].g[w[K[6]][13 ^ y]]) & K[5])
              {
                k[0] = w[K[6]][13 ^ y];
                k[4] = K[6];
              }
#if RJ > 2
              k[18] = !N;
              A[0][0] = X;
              A[0][1] = w[X][6];
              A[0][2] = w[X][7];
              A[1][0] = Z;
              if (B[G[I].g[K[0]]] < 3)
              {
                A[1][1] = w[Z][6];
                A[1][2] = w[Z][7];
              }
              else
                A[1][1] = -1;
#endif
              if (N)
              {
                if ((~(G[I].g[w[X][6]] | G[I].g[w[X][7]]) & K[5]) &&
                  (((G[I].g[L = w[K[2]][K[8]]] | G[I].g[w[L][12]] | G[I].g[w[L][13]] |
                  G[I].g[w[K[2]][12]] | G[I].g[w[K[2]][13]] | G[I].g[M = w[K[4]][13 ^ y]] |
                  (B[G[I].g[K[0]]] > 2 ? G[I].g[K[6]] : G[I].g[w[M][6]] | G[I].g[w[M][7]] |
                  G[I].g[w[K[4]][6]] | G[I].g[w[K[4]][7]]) | G[I].g[N = w[K[6]][13 ^ y]] |
                  ((G[I].g[w[Z][6]] | G[I].g[w[Z][7]]) & K[5] ? 0 :
                  G[I].g[Y = w[K[0]][K[8]]] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]] |
                  G[I].g[w[K[0]][12]] | G[I].g[w[K[0]][13]])) & K[5]) ||
                  ((G[I].g[w[K[0]][6]] | G[I].g[w[K[0]][7]] | G[I].g[w[K[2]][6]] | G[I].g[w[K[2]][7]] |
                  G[I].g[Y = w[K[0]][K[7]]] | G[I].g[w[Y][6]] | G[I].g[w[Y][7]]) & (G[I].g[K[2]] ^ K[5])) ||
                  ((G[I].g[w[K[4]][12]] | G[I].g[w[K[4]][13]] | G[I].g[w[K[0]][12]] | G[I].g[w[K[0]][13]] |
                  G[I].g[Y = w[K[0]][K[8]]] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]]) & (G[I].g[K[4]] ^ K[5]))))
                {            // Reduced Line Ring 61, 65
                  if (B[G[I].g[K[0]]] < 3 || (~(G[I].g[w[Z][6]] | G[I].g[w[Z][7]]) & K[5]))
                  {
                    if (B[G[I].g[K[0]]] < 3)
                    {
                      k[1] = w[M][6];
                      k[2] = w[M][7];
                      k[3] = w[K[4]][6];
                      k[4] = w[K[4]][7];
                    }
                    k[5] = M;
                    k[10] = N;
                    k[11] = L;
                    k[12] = w[L][12];
                    k[13] = w[L][13];
                    k[14] = w[K[2]][12];
                    k[6] = w[K[2]][13];
#if RJ > 2
                    k[18] = 12;
                    A[0][1] = -1;
#endif
                  }
                  if (~(G[I].g[w[Z][6]] | G[I].g[w[Z][7]]) & K[5])
                  {          // Reduced Line Ring 65
                    k[7] = w[K[0]][K[8]];
                    k[8] = w[k[7]][12];
                    k[15] = w[k[7]][13];
                    k[16] = w[K[0]][12];
                    k[17] = w[K[0]][13];
#if RJ > 2
                    k[18] = 12;
                    A[1][1] = -1;
#endif
                  }
                }
                else if ((~G[I].g[X] & K[5]) &&
                  ((~G[I].g[w[X][7]] & (G[I].g[Y = w[K[2]][L = 6]] |
                  (B[G[I].g[K[0]]] < 3 || (~(G[I].g[w[Z][6]] | G[I].g[w[Z][7]]) & K[5]) ?
                  G[I].g[w[Y][12]] | G[I].g[w[Y][13]] : 0)) & K[5]) ||
                  (~G[I].g[w[X][6]] & (G[I].g[Y = w[K[2]][L = 7]] |
                  (B[G[I].g[K[0]]] < 3 || (~(G[I].g[w[Z][6]] | G[I].g[w[Z][7]]) & K[5]) ?
                  G[I].g[w[Y][12]] | G[I].g[w[Y][13]] : 0)) & K[5])))
                {            // Line 69, 69a
                  k[1] = Y;
                  if (B[G[I].g[K[0]]] < 3 || (~(G[I].g[w[Z][6]] | G[I].g[w[Z][7]]) & K[5]))
                  {
                    k[2] = w[Y][12];
                    k[3] = w[Y][13];
                  }
#if RJ > 2
                  A[0][0] = w[X][L];
                  A[0][1] = -1;
#endif
                }
              }
            }
            else if ((LB3 (w[K[4]][12 | y], w[X][K[7]], w[K[6]][12 | y], 0) & K[5]) &&
              ((G[I].g[w[K[0]][L = K[7]]] & ~(G[I].g[w[Z][6]] | G[I].g[w[Z][7]]) & K[5]) ||
              (G[I].g[w[K[0]][++L]] & ~(G[I].g[Z] | G[I].g[w[Z][7]]) & K[5]) ||
              (G[I].g[w[K[0]][++L]] & ~(G[I].g[Z] | G[I].g[w[Z][6]]) & K[5])))
            {                // Line 73
              k[0] = w[K[0]][L];
#if RJ > 2
              A[0][0] = w[X][L];
              A[0][1] = -1;
              A[1][0] = X;
              A[1][1] = w[X][6];
              A[1][2] = w[X][7];
#endif
            }
            else if (B[G[I].g[K[0]]] < 3 &&
              (G[I].g[Y = w[K[4]][K[7]]] | G[I].g[w[Y][6]] | G[I].g[w[Y][7]]) &
              LN3 (w[K[6]][12 | y], w[w[K[4]][12 | y]][K[7]], w[K[4]][12 | y], 0) & K[5])
            {                // Line 77
              k[0] = Y;
              k[1] = w[Y][6];
              k[2] = w[Y][7];
#if RJ > 2
              A[0][0] = X;
              A[0][1] = -1;
              A[1][0] = Z;
              A[1][1] = w[Z][6];
              A[1][2] = w[Z][7];
#endif
            }
            if ((k[0] & k[1]) + 1)
              goto XYWT1Tf;
            if ((N = LB3 (w[K[6]][6 | y], w[K[2]][6 | y], w[Z][K[8]], 1) & K[5]) ||
              (B[G[I].g[K[0]]] < 3 && LB3 (w[K[2]][K[8]], w[X][7 ^ y], w[X][6 | y], 1) & K[5]))
            {                // Box 54, Line 58, 70, 70a, Reduced Line Ring 62, 66
              if (B[G[I].g[K[0]]] < 3)
              {
                if (G[I].g[w[K[6]][7 ^ y]] & K[5])
                  k[0] = w[K[6]][7 ^ y];
              }
              else if (~(G[I].g[w[Z][12]] | G[I].g[w[Z][13]]) & (G[I].g[K[6]] | G[I].g[w[K[6]][7 ^ y]]) & K[5])
              {
                k[0] = w[K[6]][7 ^ y];
                k[4] = K[6];
              }
#if RJ > 2
              k[18] = !N;
              A[0][0] = X;
              A[0][1] = w[X][12];
              A[0][2] = w[X][13];
              A[1][0] = Z;
              if (B[G[I].g[K[0]]] < 3)
              {
                A[1][1] = w[Z][12];
                A[1][2] = w[Z][13];
              }
              else
                A[1][1] = -1;
#endif
              if (N)
              {
                if ((~(G[I].g[w[X][12]] | G[I].g[w[X][13]]) & K[5]) &&
                  (((G[I].g[L = w[K[4]][K[7]]] | G[I].g[w[L][6]] | G[I].g[w[L][7]] |
                  G[I].g[w[K[4]][6]] | G[I].g[w[K[4]][7]] | G[I].g[M = w[K[2]][7 ^ y]] |
                  G[I].g[N = w[K[6]][7 ^ y]] | (B[G[I].g[K[0]]] > 2 ? G[I].g[K[6]] :
                  G[I].g[w[M][12]] | G[I].g[w[M][13]] | G[I].g[w[K[2]][12]] | G[I].g[w[K[2]][13]]) |
                  ((G[I].g[w[Z][12]] | G[I].g[w[Z][13]]) & K[5] ? 0 :
                  G[I].g[Y = w[K[0]][K[7]]] | G[I].g[w[Y][6]] | G[I].g[w[Y][7]] |
                  G[I].g[w[K[0]][6]] | G[I].g[w[K[0]][7]])) & K[5]) ||
                  ((G[I].g[w[K[0]][6]] | G[I].g[w[K[0]][7]] | G[I].g[w[K[2]][6]] | G[I].g[w[K[2]][7]] |
                  G[I].g[Y = w[K[0]][K[7]]] | G[I].g[w[Y][6]] | G[I].g[w[Y][7]]) & (G[I].g[K[2]] ^ K[5])) ||
                  ((G[I].g[w[K[4]][12]] | G[I].g[w[K[4]][13]] | G[I].g[w[K[0]][12]] | G[I].g[w[K[0]][13]] |
                  G[I].g[Y = w[K[0]][K[8]]] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]]) & (G[I].g[K[4]] ^ K[5]))))
                {            // Reduced Line Ring 62, 66
                  if (B[G[I].g[K[0]]] < 3 || (~(G[I].g[w[Z][12]] | G[I].g[w[Z][13]]) & K[5]))
                  {
                    if (B[G[I].g[K[0]]] < 3)
                    {
                      k[1] = w[M][12];
                      k[2] = w[M][13];
                      k[3] = w[K[2]][12];
                      k[4] = w[K[2]][13];
                    }
                    k[5] = M;
                    k[10] = N;
                    k[11] = L;
                    k[12] = w[L][6];
                    k[13] = w[L][7];
                    k[14] = w[K[4]][6];
                    k[6] = w[K[4]][7];
#if RJ > 2
                    k[18] = 12;
                    A[0][1] = -1;
#endif
                  }
                  if (~(G[I].g[w[Z][12]] | G[I].g[w[Z][13]]) & K[5])
                  {          // Reduced Line Ring 66
                    k[7] = w[K[0]][K[7]];
                    k[8] = w[k[7]][6];
                    k[15] = w[k[7]][7];
                    k[16] = w[K[0]][6];
                    k[17] = w[K[0]][7];
#if RJ > 2
                    k[18] = 12;
                    A[1][1] = -1;
#endif
                  }
                }
                else if ((~G[I].g[X] & K[5]) &&
                  ((~G[I].g[w[X][13]] & (G[I].g[Y = w[K[4]][L = 12]] |
                  (B[G[I].g[K[0]]] < 3 || (~(G[I].g[w[Z][12]] | G[I].g[w[Z][13]]) & K[5]) ?
                  G[I].g[w[Y][6]] | G[I].g[w[Y][7]] : 0)) & K[5]) ||
                  (~G[I].g[w[X][12]] & (G[I].g[Y = w[K[4]][L = 13]] |
                  (B[G[I].g[K[0]]] < 3 || (~(G[I].g[w[Z][12]] | G[I].g[w[Z][13]]) & K[5]) ?
                  G[I].g[w[Y][6]] | G[I].g[w[Y][7]] : 0)) & K[5])))
                {            // Line 70, 70a
                  k[1] = Y;
                  if (B[G[I].g[K[0]]] < 3 || (~(G[I].g[w[Z][12]] | G[I].g[w[Z][13]]) & K[5]))
                  {
                    k[2] = w[Y][6];
                    k[3] = w[Y][7];
                  }
#if RJ > 2
                  A[0][0] = w[X][L];
                  A[0][1] = -1;
#endif
                }
              }
            }
            else if ((LB3 (w[K[2]][6 | y], w[X][K[8]], w[K[6]][6 | y], 1) & K[5]) &&
              ((G[I].g[w[K[0]][L = K[8]]] & ~(G[I].g[w[Z][12]] | G[I].g[w[Z][13]]) & K[5]) ||
              (G[I].g[w[K[0]][++L]] & ~(G[I].g[Z] | G[I].g[w[Z][13]]) & K[5]) ||
              (G[I].g[w[K[0]][++L]] & ~(G[I].g[Z] | G[I].g[w[Z][12]]) & K[5])))
            {                // Line 74
              k[0] = w[K[0]][L];
#if RJ > 2
              A[0][0] = w[X][L];
              A[0][1] = -1;
              A[1][0] = X;
              A[1][1] = w[X][12];
              A[1][2] = w[X][13];
#endif
            }
            else if (B[G[I].g[K[0]]] < 3 &&
              (G[I].g[Y = w[K[2]][K[8]]] | G[I].g[w[Y][12]] | G[I].g[w[Y][13]]) &
              LN3 (w[K[6]][6 | y], w[w[K[2]][6 | y]][K[8]], w[K[2]][6 | y], 1) & K[5])
            {                // Line 78
              k[0] = Y;
              k[1] = w[Y][12];
              k[2] = w[Y][13];
#if RJ > 2
              A[0][0] = X;
              A[0][1] = -1;
              A[1][0] = Z;
              A[1][1] = w[Z][12];
              A[1][2] = w[Z][13];
#endif
            }
            if ((k[0] & k[1]) + 1)
            {
XYWT1Tf:
              if (k[0] + 1)
                G[I].g[k[0]] &= ~K[5];
              if (k[1] + 1)
                G[I].g[k[1]] &= ~K[5];
              if (k[2] + 1)
                G[I].g[k[2]] &= ~K[5];
              if (k[3] + 1)
               G[I]. g[k[3]] &= ~K[5];
              if (k[4] + 1)
                G[I].g[k[4]] &= ~K[5];
              if (k[5] + 1)
              {
                G[I].g[k[5]] &= ~K[5];
                G[I].g[k[10]] &= ~K[5];
                G[I].g[k[11]] &= ~K[5];
                G[I].g[k[12]] &= ~K[5];
                G[I].g[k[13]] &= ~K[5];
                G[I].g[k[14]] &= ~K[5];
                G[I].g[w[K[0]][6]] &= ~(y = G[I].g[K[2]] ^ K[5]);
                G[I].g[w[K[0]][7]] &= ~y;
                G[I].g[w[K[0]][K[7]]] &= ~y;
                G[I].g[w[K[0]][K[7] + 1]] &= ~y;
                G[I].g[w[K[0]][K[7] + 2]] &= ~y;
                G[I].g[w[K[2]][6]] &= ~y;
                G[I].g[w[K[2]][7]] &= ~y;
                G[I].g[w[K[0]][12]] &= ~(Y = G[I].g[K[4]] ^ K[5]);
                G[I].g[w[K[0]][13]] &= ~Y;
                G[I].g[w[K[0]][K[8]]] &= ~Y;
                G[I].g[w[K[0]][K[8] + 1]] &= ~Y;
                G[I].g[w[K[0]][K[8] + 2]] &= ~Y;
                G[I].g[w[K[4]][12]] &= ~Y;
                G[I].g[w[K[4]][13]] &= ~Y;
                if (k[6] + 1)
                {
                  G[I].g[k[6]] &= ~K[5];
                  if (k[7] + 1)
                  {
                    G[I].g[k[7]] &= ~K[5];
                    if (k[8] + 1)
                    {
                      G[I].g[k[8]] &= ~K[5];
                      G[I].g[k[15]] &= ~K[5];
                      G[I].g[k[16]] &= ~K[5];
                      G[I].g[k[17]] &= ~K[5];
                    }
                    if (k[9] + 1)
                    {
                      G[I].g[k[9]] &= ~K[5];
                    }
                  }
                }
              }
#if RJ > 2
              printf ("%d) XY%sTransport:%s%s%s%d @ r%dc%d %s SL%s",
                G[I].p, B[G[I].g[K[0]]] < 3 ? "-Wing Type 1 " : "Z-", k[18] & 4 ? " Reduced " : " ",
                k[18] & 1 ? "Box" : (k[18] & 2 ? "ERI" : R_C), k[18] & 8 ? " Ring " : " ",
                b[G[I].g[K[2]] | G[I].g[K[4]]], ROW (w[K[0]][20] | w[K[2]][20]),
                COL (w[K[0]][20] | w[K[2]][20]), S[K[4]], A[1][0] + 1 ? " between " : " ");
              if (k[18] & 2)
                printf ("ERI %d @ b%d", b[K[5]], BOX (A[0][0]));
              else
                printf ("%d @ ", b[K[5]]);
              printf ("r%dc%d", ROW (w[A[0][0]][20] | (A[0][1] + 1 ? w[A[0][1]][20] : 0) |
                (A[0][2] + 1 ? w[A[0][2]][20] : 0)), COL (w[A[0][0]][20] |
                (A[0][1] + 1 ? w[A[0][1]][20] : 0) | (A[0][2] + 1 ? w[A[0][2]][20] : 0)));
              if (A[1][0] + 1)
              {
                if (k[18] & 2)
                  printf (" and ERI %d @ b%d", b[K[5]], BOX (A[1][0]));
                else
                  printf (" and %d @ ", b[K[5]]);
                printf ("r%dc%d", ROW (w[A[1][0]][20] | (A[1][1] + 1 ? w[A[1][1]][20] : 0) |
                  (A[1][2] + 1 ? w[A[1][2]][20] : 0)), COL (w[A[1][0]][20] |
                  (A[1][1] + 1 ? w[A[1][1]][20] : 0) | (A[1][2] + 1 ? w[A[1][2]][20] : 0)));
              }
              printf ("\n=> -%d @", b[K[5]]);
              if (k[0] + 1)
                printf (" %s", S[k[0]]);
              if (k[1] + 1)
                printf (" %s", S[k[1]]);
              if (k[2] + 1)
                printf (" %s", S[k[2]]);
              if (k[3] + 1)
                printf (" %s", S[k[3]]);
              if (k[4] + 1)
                printf (" %s", S[k[4]]);
              if (k[5] + 1)
              {
                printf (" %s %s %s %s %s %s", S[k[5]], S[k[10]], S[k[11]], S[k[12]], S[k[13]], S[k[14]]);
                if (k[6] + 1)
                {
                  printf (" %s", S[k[6]]);
                  if (k[7] + 1)
                  {
                    printf (" %s", S[k[7]]);
                    if (k[8] + 1)
                      printf (" %s %s %s %s", S[k[8]], S[k[15]], S[k[16]], S[k[17]]);
                    if (k[9] + 1)
                      printf (" %s", S[k[9]]);
                  }
                }
                printf ("\n=> -%d @ r%dc%d => -%d @ r%dc%d",
                  b[y], ROW (w[w[K[0]][6]][20] | w[w[K[0]][7]][20] | w[w[K[2]][6]][20] |
                  w[w[K[2]][7]][20] | w[w[K[0]][K[7]]][20] | w[w[K[0]][K[7] + 1]][20] |
                  w[w[K[0]][K[7] + 2]][20]), COL (w[w[K[0]][6]][20] | w[w[K[0]][7]][20] |
                  w[w[K[2]][6]][20] | w[w[K[2]][7]][20] | w[w[K[0]][K[7]]][20] |
                  w[w[K[0]][K[7] + 1]][20] | w[w[K[0]][K[7] + 2]][20]), b[Y],
                  ROW (w[w[K[0]][12]][20] | w[w[K[0]][13]][20] | w[w[K[4]][12]][20] |
                  w[w[K[4]][13]][20] | w[w[K[0]][K[8]]][20] | w[w[K[0]][K[8] + 1]][20] |
                  w[w[K[0]][K[8] + 2]][20]), COL (w[w[K[0]][12]][20] | w[w[K[0]][13]][20] |
                  w[w[K[4]][12]][20] | w[w[K[4]][13]][20] | w[w[K[0]][K[8]]][20] |
                  w[w[K[0]][K[8] + 1]][20] | w[w[K[0]][K[8] + 2]][20]));
              }
              printf ("\n");
#endif
              goto START;
            }
          }
          if (B[G[I].g[K[0]]] < 3 || !(G[I].g[K[6]] & K[5]))
            continue;        // Skip XYZ-Hybrid for either Apex Cell values < three digits; or no Wing Cells common value in Hybrid Cell values
          if (k[0] = (G[I].g[w[K[0]][6]] | G[I].g[w[K[0]][7]] | G[I].g[w[K[2]][6]] | G[I].g[w[K[2]][7]] |
            G[I].g[w[K[0]][K[7]]] | G[I].g[w[K[0]][K[7] + 1]] | G[I].g[w[K[0]][K[7] + 2]]) &
                             // Check Wing Cells common value in Apex and 1st Wing Cells Row removal Cells values; and
            ~(G[I].g[w[K[2]][12]] | G[I].g[w[K[2]][13]] | G[I].g[w[K[6]][12]] | G[I].g[w[K[6]][13]] |
            G[I].g[w[K[2]][K[8]]] | G[I].g[w[K[2]][K[8] + 1]] | G[I].g[w[K[2]][K[8] + 2]]) & K[5])
          {                  // No Wing Cells common value in 1st Wing and Hybrid Cells Column other Cells values
                             // Drop Wing Cells common value from XYZ-Hybrid Row wise removal Cells values
            G[I].g[w[K[0]][6]] &= ~K[5];
            G[I].g[w[K[0]][7]] &= ~K[5];
            G[I].g[w[K[2]][6]] &= ~K[5];
            G[I].g[w[K[2]][7]] &= ~K[5];
            G[I].g[w[K[0]][K[7]]] &= ~K[5];
            G[I].g[w[K[0]][K[7] + 1]] &= ~K[5];
            G[I].g[w[K[0]][K[7] + 2]] &= ~K[5];
          }
          if (k[1] = (G[I].g[w[K[0]][12]] | G[I].g[w[K[0]][13]] | G[I].g[w[K[4]][12]] | G[I].g[w[K[4]][13]] |
            G[I].g[w[K[0]][K[8]]] | G[I].g[w[K[0]][K[8] + 1]] | G[I].g[w[K[0]][K[8] + 2]]) &
                             // Check Wing Cells common value in Apex and 2nd Wing Cells Column removal Cells values; and
            ~(G[I].g[w[K[4]][6]] | G[I].g[w[K[4]][7]] | G[I].g[w[K[6]][6]] | G[I].g[w[K[6]][7]] |
            G[I].g[w[K[4]][K[7]]] | G[I].g[w[K[4]][K[7] + 1]] | G[I].g[w[K[4]][K[7] + 2]]) & K[5])
          {                  // No Wing Cells common value in 2nd Wing and Hybrid Cells Row other Cells values
                             // Drop Wing Cells common value from XYZ-Hybrid Column wise removal Cells values
            G[I].g[w[K[0]][12]] &= ~K[5];
            G[I].g[w[K[0]][13]] &= ~K[5];
            G[I].g[w[K[4]][12]] &= ~K[5];
            G[I].g[w[K[4]][13]] &= ~K[5];
            G[I].g[w[K[0]][K[8]]] &= ~K[5];
            G[I].g[w[K[0]][K[8] + 1]] &= ~K[5];
            G[I].g[w[K[0]][K[8] + 2]] &= ~K[5];
          }
          if (!k[0] && !k[1])
            continue;        // Skip for no XYZ-Hybrid found
#if RJ > 2
          printf ("%d)%sXYZ-Hybrid: %d @ r%dc%d %s %s Hybrid %d @ %s => -%d @",
            G[I].p, k[0] && k[1] ? " Dual " : " ", b[G[I].g[K[2]] | G[I].g[K[4]]],
            ROW (w[K[0]][20] | w[K[2]][20]), COL (w[K[0]][20] | w[K[2]][20]),
            S[K[4]], k[0] && k[1] ? "Dual" : (k[0] ? "Column wise" : "Row wise"),
            b[K[5]], S[K[6]], b[K[5]]);
          if (k[0])
            printf (" r%dc%d", ROW (w[w[K[0]][6]][20] | w[w[K[0]][7]][20] |
              w[w[K[2]][6]][20] | w[w[K[2]][7]][20] | w[w[K[0]][K[7]]][20] |
              w[w[K[0]][K[7] + 1]][20] | w[w[K[0]][K[7] + 2]][20]), COL (w[w[K[0]][6]][20] |
              w[w[K[0]][7]][20] | w[w[K[2]][6]][20] | w[w[K[2]][7]][20] |
              w[w[K[0]][K[7]]][20] | w[w[K[0]][K[7] + 1]][20] | w[w[K[0]][K[7] + 2]][20]));
          if (k[1])
            printf (" r%dc%d", ROW (w[w[K[0]][12]][20] | w[w[K[0]][13]][20] |
              w[w[K[4]][12]][20] | w[w[K[4]][13]][20] | w[w[K[0]][K[8]]][20] |
              w[w[K[0]][K[8] + 1]][20] | w[w[K[0]][K[8] + 2]][20]), COL (w[w[K[0]][12]][20] |
              w[w[K[0]][13]][20] | w[w[K[4]][12]][20] | w[w[K[4]][13]][20] |
              w[w[K[0]][K[8]]][20] | w[w[K[0]][K[8] + 1]][20] | w[w[K[0]][K[8] + 2]][20]));
          printf ("\n");
#endif
          goto START;
        }
      }
    }
    for (a = G[I].p; a < q; ++a)
    {                        // Search XY-Ring Type 2, XY-Wing Type 2, XY-Wing Type 2 Transport, XYZ-Wing and XYZ-Wing Transport Apex unsolved Cell positions wise
      if (B[G[I].g[r[a]]] > 3)
        continue;            // Skip for unsolved Cell values > three digits
      int K[9] = {r[a]};     // Assign Apex Cell position

      for (y = 0; y < 2; ++y)// Search Wing Cells position Chute wise
      {
        if (!(G[I].g[w[K[0]][W[1][y]]] | G[I].g[w[K[0]][W[18][y]]] | G[I].g[w[K[0]][W[19][y]]] |
          G[I].g[w[K[0]][W[20][y]]] | G[I].g[w[K[0]][W[21][y]]] | G[I].g[w[K[0]][W[22][y]]]) ||
          !(G[I].g[w[K[0]][W[6][y]]] | G[I].g[w[K[0]][W[7][y]]] | G[I].g[w[K[0]][W[8][y]]] |
          G[I].g[w[K[0]][W[9][y]]] | G[I].g[w[K[0]][W[10][y]]] | G[I].g[w[K[0]][W[11][y]]]))
          continue;          // Skip for no unsolved Cell position found in Apex either Line or Box
        for (K[1] = W[1][y]; K[1] < W[2][y]; ++K[1])
        {                    // Search 1st Wing Cell position Line wise
          if (B[G[I].g[K[2] = w[K[0]][K[1]]]] != 2 || B[G[I].g[K[0]] | G[I].g[K[2]]] != 3)
            continue;        // Skip for either 1st Wing Cell position not two digits; or Apex and 1st Wing Cells values not three digits
          for (K[3] = W[6][y]; K[3] < W[0][y]; ++K[3])
          {                  // Search 2nd Wing Cell position Box wise but not in 1st Wing Line
            if (B[G[I].g[K[4] = w[K[0]][K[3]]]] != 2 || B[G[I].g[K[0]] | G[I].g[K[4]]] != 3)
              continue;      // Skip for either 2nd Wing Cell values not two digits; or Apex and 2nd Wing Cells values not three digits
            K[6] = W[K[1] < W[5][y] ? 1 : 5][y];
            K[7] = W[K[1] < W[5][y] ? 5 : 1][y];
            K[8] = W[K[3] == W[6][y] || K[3] == W[7][y] || K[3] == W[8][y] ? 4 : 3][!y];
            if (K[2] > K[0] && K[4] > K[0] &&
                             // Check XY-Ring Type 2 1st Wing Cell position > Apex Cell position; and 2nd Wing Cell position > Apex Cell position; and
              B[G[I].g[K[0]]] < 3 && !(G[I].g[K[2]] & G[I].g[K[4]]))
                             // Apex Cell values two digits; and 1st and 2nd Wing Cells values four digits
              for (Y = K[6]; Y < K[6] + 3; ++Y)
              {              // Search XY-Ring Type 2 3rd Wing Cell position 1st and 2nd Wing Cells common Cell positions wise
                if (B[G[I].g[K[5] = w[K[4]][Y]]] != 2 || B[G[I].g[K[2]] | G[I].g[K[5]]] != 3 ||
                             // Skip for either 3rd Wing Cell values not two digits; or 1st and 3rd Wing Cells values not three digits; or
                  B[G[I].g[K[4]] | G[I].g[K[5]]] != 3 || (G[I].g[K[0]] & G[I].g[K[5]]) ||
                             // 2nd and 3rd Wing Cells values not three digits; or no common digits in Apex and 3rd Wing Cells values; or
                  !(((G[I].g[w[K[0]][W[3][y]]] | G[I].g[w[K[0]][W[4][y]]] |
                  G[I].g[w[K[2]][W[3][y]]] | G[I].g[w[K[2]][W[4][y]]] |
                  G[I].g[w[K[0]][K[7]]] | G[I].g[w[K[0]][K[7] + 1]] |
                  G[I].g[w[K[0]][K[7] + 2]]) & G[I].g[K[0]] & G[I].g[K[2]]) ||
                  ((G[I].g[w[K[4]][W[3][y]]] | G[I].g[w[K[4]][W[4][y]]] |
                  G[I].g[w[K[5]][W[3][y]]] | G[I].g[w[K[5]][W[4][y]]] |
                  G[I].g[w[K[4]][K[7]]] | G[I].g[w[K[4]][K[7] + 1]] |
                  G[I].g[w[K[4]][K[7] + 2]]) & G[I].g[K[4]] & G[I].g[K[5]]) ||
                  ((G[I].g[w[K[0]][W[3][y]]] | G[I].g[w[K[0]][W[4][y]]] |
                  G[I].g[w[K[4]][W[3][y]]] | G[I].g[w[K[4]][W[4][y]]] |
                  G[I].g[X = w[K[0]][K[8]]] | G[I].g[w[X][W[3][y]]] | G[I].g[w[X][W[4][y]]] |
                  (w[K[0]][20] & w[K[4]][20] & W[15][y] ? G[I].g[w[K[0]][W[1][!y]]] |
                  G[I].g[w[K[0]][W[18][!y]]] | G[I].g[w[K[0]][W[19][!y]]] |
                  G[I].g[w[K[0]][W[20][!y]]] | G[I].g[w[K[0]][W[21][!y]]] |
                  G[I].g[w[K[0]][W[22][!y]]] : 0)) & G[I].g[K[0]] & G[I].g[K[4]]) ||
                  ((G[I].g[w[K[2]][W[3][y]]] | G[I].g[w[K[2]][W[4][y]]] |
                  G[I].g[w[K[5]][W[3][y]]] | G[I].g[w[K[5]][W[4][y]]] |
                  G[I].g[Z = w[K[2]][K[8]]] | G[I].g[w[Z][W[3][y]]] | G[I].g[w[Z][W[4][y]]] |
                  (w[K[2]][20] & w[K[5]][20] & W[15][y] ? G[I].g[w[K[2]][W[1][!y]]] |
                  G[I].g[w[K[2]][W[18][!y]]] | G[I].g[w[K[2]][W[19][!y]]] |
                  G[I].g[w[K[2]][W[20][!y]]] | G[I].g[w[K[2]][W[21][!y]]] |
                  G[I].g[w[K[2]][W[22][!y]]] : 0)) & G[I].g[K[2]] & G[I].g[K[5]])))
                  continue;  // No XY-Ring Type 2 removal Cell values found
                             // Drop XY-Ring Type 2 Wing Cells common values from removal Cell values
                G[I].g[w[K[0]][W[3][y]]] &= ~G[I].g[K[0]];
                G[I].g[w[K[0]][W[4][y]]] &= ~G[I].g[K[0]];
                G[I].g[w[K[2]][W[3][y]]] &= ~G[I].g[K[2]];
                G[I].g[w[K[2]][W[4][y]]] &= ~G[I].g[K[2]];
                G[I].g[w[K[0]][K[7]]] &= ~(G[I].g[K[0]] & G[I].g[K[2]]);
                G[I].g[w[K[0]][K[7] + 1]] &= ~(G[I].g[K[0]] & G[I].g[K[2]]);
                G[I].g[w[K[0]][K[7] + 2]] &= ~(G[I].g[K[0]] & G[I].g[K[2]]);
                G[I].g[w[K[4]][W[3][y]]] &= ~G[I].g[K[4]];
                G[I].g[w[K[4]][W[4][y]]] &= ~G[I].g[K[4]];
                G[I].g[w[K[5]][W[3][y]]] &= ~G[I].g[K[5]];
                G[I].g[w[K[5]][W[4][y]]] &= ~G[I].g[K[5]];
                G[I].g[w[K[4]][K[7]]] &= ~(G[I].g[K[4]] & G[I].g[K[5]]);
                G[I].g[w[K[4]][K[7] + 1]] &= ~(G[I].g[K[4]] & G[I].g[K[5]]);
                G[I].g[w[K[4]][K[7] + 2]] &= ~(G[I].g[K[4]] & G[I].g[K[5]]);
                G[I].g[X = w[K[0]][K[8]]] &= ~(G[I].g[K[0]] & G[I].g[K[4]]);
                G[I].g[w[X][W[3][y]]] &= ~(G[I].g[K[0]] & G[I].g[K[4]]);
                G[I].g[w[X][W[4][y]]] &= ~(G[I].g[K[0]] & G[I].g[K[4]]);
                G[I].g[Z = w[K[2]][K[8]]] &= ~(G[I].g[K[2]] & G[I].g[K[5]]);
                G[I].g[w[Z][W[3][y]]] &= ~(G[I].g[K[2]] & G[I].g[K[5]]);
                G[I].g[w[Z][W[4][y]]] &= ~(G[I].g[K[2]] & G[I].g[K[5]]);
                if (w[K[0]][20] & w[K[4]][20] & W[15][y])
                {            // Check Apex Cell position and 2nd Wing Cell position same Line
                  G[I].g[w[K[0]][W[1][!y]]] &= ~(G[I].g[K[0]] & G[I].g[K[4]]);
                  G[I].g[w[K[0]][W[18][!y]]] &= ~(G[I].g[K[0]] & G[I].g[K[4]]);
                  G[I].g[w[K[0]][W[19][!y]]] &= ~(G[I].g[K[0]] & G[I].g[K[4]]);
                  G[I].g[w[K[0]][W[20][!y]]] &= ~(G[I].g[K[0]] & G[I].g[K[4]]);
                  G[I].g[w[K[0]][W[21][!y]]] &= ~(G[I].g[K[0]] & G[I].g[K[4]]);
                  G[I].g[w[K[0]][W[22][!y]]] &= ~(G[I].g[K[0]] & G[I].g[K[4]]);
                }
                if (w[K[2]][20] & w[K[5]][20] & W[15][y])
                {            // Check 1st Wing Cell position and 3rd Wing Cell position same Line
                  G[I].g[w[K[2]][W[1][!y]]] &= ~(G[I].g[K[2]] & G[I].g[K[5]]);
                  G[I].g[w[K[2]][W[18][!y]]] &= ~(G[I].g[K[2]] & G[I].g[K[5]]);
                  G[I].g[w[K[2]][W[19][!y]]] &= ~(G[I].g[K[2]] & G[I].g[K[5]]);
                  G[I].g[w[K[2]][W[20][!y]]] &= ~(G[I].g[K[2]] & G[I].g[K[5]]);
                  G[I].g[w[K[2]][W[21][!y]]] &= ~(G[I].g[K[2]] & G[I].g[K[5]]);
                  G[I].g[w[K[2]][W[22][!y]]] &= ~(G[I].g[K[2]] & G[I].g[K[5]]);
                }
#if RJ > 2
                printf ("%d) XY-Ring Type 2: %d @ r%dc%d r%dc%d => -%d @ r%dc%d => -%d @ r%dc%d\n=> -%d @ r%dc%d r%dc%d r%dc%d",
                  G[I].p, b[G[I].g[K[2]] | G[I].g[K[4]]], ROW (w[K[0]][20] | w[K[2]][20]),
                  COL (w[K[0]][20] | w[K[2]][20]), ROW (w[K[4]][20] | w[K[5]][20]),
                  COL (w[K[4]][20] | w[K[5]][20]), b[G[I].g[K[0]] & G[I].g[K[2]]],
                  ROW (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20] |
                  w[w[K[2]][W[3][y]]][20] | w[w[K[2]][W[4][y]]][20] | w[w[K[0]][K[7]]][20] |
                  w[w[K[0]][K[7] + 1]][20] | w[w[K[0]][K[7] + 2]][20]),
                  COL (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20] |
                  w[w[K[2]][W[3][y]]][20] | w[w[K[2]][W[4][y]]][20] | w[w[K[0]][K[7]]][20] |
                  w[w[K[0]][K[7] + 1]][20] | w[w[K[0]][K[7] + 2]][20]), b[G[I].g[K[4]] & G[I].g[K[5]]],
                  ROW (w[w[K[4]][W[3][y]]][20] | w[w[K[4]][W[4][y]]][20] |
                  w[w[K[5]][W[3][y]]][20] | w[w[K[5]][W[4][y]]][20] | w[w[K[4]][K[7]]][20] |
                  w[w[K[4]][K[7] + 1]][20] | w[w[K[4]][K[7] + 2]][20]),
                  COL (w[w[K[4]][W[3][y]]][20] | w[w[K[4]][W[4][y]]][20] |
                  w[w[K[5]][W[3][y]]][20] | w[w[K[5]][W[4][y]]][20] | w[w[K[4]][K[7]]][20] |
                  w[w[K[4]][K[7] + 1]][20] | w[w[K[4]][K[7] + 2]][20]), b[G[I].g[K[0]] & G[I].g[K[4]]],
                  ROW (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20]),
                  COL (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20]),
                  ROW (w[w[K[4]][W[3][y]]][20] | w[w[K[4]][W[4][y]]][20]),
                  COL (w[w[K[4]][W[3][y]]][20] | w[w[K[4]][W[4][y]]][20]),
                  ROW (w[X][20] | w[w[X][W[3][y]]][20] | w[w[X][W[4][y]]][20]),
                  COL (w[X][20] | w[w[X][W[3][y]]][20] | w[w[X][W[4][y]]][20]));
                if (w[K[0]][20] & w[K[4]][20] & W[15][y])
                  printf (" r%dc%d",
                    ROW (w[w[K[0]][W[1][!y]]][20] | w[w[K[0]][W[18][!y]]][20] |
                    w[w[K[0]][W[19][!y]]][20] | w[w[K[0]][W[20][!y]]][20] |
                    w[w[K[0]][W[21][!y]]][20] | w[w[K[0]][W[22][!y]]][20]),
                    COL (w[w[K[0]][W[1][!y]]][20] | w[w[K[0]][W[18][!y]]][20] |
                    w[w[K[0]][W[19][!y]]][20] | w[w[K[0]][W[20][!y]]][20] |
                    w[w[K[0]][W[21][!y]]][20] | w[w[K[0]][W[22][!y]]][20]));
                printf (" => -%d @ r%dc%d r%dc%d r%dc%d", b[G[I].g[K[2]] & G[I].g[K[5]]],
                  ROW (w[w[K[2]][W[3][y]]][20] | w[w[K[2]][W[4][y]]][20]),
                  COL (w[w[K[2]][W[3][y]]][20] | w[w[K[2]][W[4][y]]][20]),
                  ROW (w[w[K[5]][W[3][y]]][20] | w[w[K[5]][W[4][y]]][20]),
                  COL (w[w[K[5]][W[3][y]]][20] | w[w[K[5]][W[4][y]]][20]),
                  ROW (w[Z][20] | w[w[Z][W[3][y]]][20] | w[w[Z][W[4][y]]][20]),
                  COL (w[Z][20] | w[w[Z][W[3][y]]][20] | w[w[Z][W[4][y]]][20]));
                if (w[K[2]][20] & w[K[5]][20] & W[15][y])
                  printf (" r%dc%d",
                    ROW (w[w[K[2]][W[1][!y]]][20] | w[w[K[2]][W[18][!y]]][20] |
                    w[w[K[2]][W[19][!y]]][20] | w[w[K[2]][W[20][!y]]][20] |
                    w[w[K[2]][W[21][!y]]][20] | w[w[K[2]][W[22][!y]]][20]),
                    COL (w[w[K[2]][W[1][!y]]][20] | w[w[K[2]][W[18][!y]]][20] |
                    w[w[K[2]][W[19][!y]]][20] | w[w[K[2]][W[20][!y]]][20] |
                    w[w[K[2]][W[21][!y]]][20] | w[w[K[2]][W[22][!y]]][20]));
                printf ("\n");
#endif
                goto START;
              }
            if (B[G[I].g[K[0]] | G[I].g[K[2]] | G[I].g[K[4]]] > 3 ||
                             // Skip for either Apex Cell and Wing Cells values > three digits; or
            B[K[5] = G[I].g[K[2]] & G[I].g[K[4]]] != 1 ||
                             // Wing Cells common value not one digit; or
            ((G[I].g[K[0]] & K[5]) && B[G[I].g[K[0]]] != 3))
              continue;      // Wing Cells common value in Apex Cell values; and Apex Cell values not three digits
            if ((G[I].g[w[K[0]][W[3][y]]] | G[I].g[w[K[0]][W[4][y]]] | (B[G[I].g[K[0]]] > 2 ? 0 :
              G[I].g[w[K[4]][K[6]]] | G[I].g[w[K[4]][K[6] + 1]] | G[I].g[w[K[4]][K[6] + 2]])) & K[5])
            {                // Check Wing Cells common value in XY-Wing Type 2 and XYZ-Wing removal Cells values
                             // Drop Wing Cells common value from XY-Wing Type 2 and XYZ-Wing removal Cell positions
              G[I].g[w[K[0]][W[3][y]]] &= ~K[5];
              G[I].g[w[K[0]][W[4][y]]] &= ~K[5];
              if (B[G[I].g[K[0]]] < 3)
              {              // Drop Wing Cells common value from XY-Wing Type 2 more removal Cell positions
                G[I].g[w[K[4]][K[6]]] &= ~K[5];
                G[I].g[w[K[4]][K[6] + 1]] &= ~K[5];
                G[I].g[w[K[4]][K[6] + 2]] &= ~K[5];
              }
#if RJ > 2
              printf ("%d) XY%s: %d @ r%dc%d %s => -%d @ r%dc%d",
                G[I].p, B[G[I].g[K[0]]] < 3 ? "-Wing Type 2" : "Z-Wing", b[G[I].g[K[2]] | G[I].g[K[4]]],
                ROW (w[K[0]][20] | w[K[2]][20]), COL (w[K[0]][20] | w[K[2]][20]),
                S[K[4]], b[K[5]], ROW (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20]),
                COL (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20]));
              if (B[G[I].g[K[0]]] < 3)
                printf (" r%dc%d", ROW (w[w[K[4]][K[6]]][20] | w[w[K[4]][K[6] + 1]][20] |
                  w[w[K[4]][K[6] + 2]][20]), COL (w[w[K[4]][K[6]]][20] |
                  w[w[K[4]][K[6] + 1]][20] | w[w[K[4]][K[6] + 2]][20]));
              printf ("\n");
#endif
              goto START;
            }
            {                // Search XY-Wing Type 2 Transport and XYZ-Wing Transport
              int A,
                  L,
                  M,
                  N = W[K[0] == w[K[4]][W[6][y]] || K[0] == w[K[4]][W[7][y]] ||
                      K[0] == w[K[4]][W[8][y]] ? 4 : 3][!y],
                  k[3] = {0};

              if (((k[0] = LB3 (M = w[K[4]][N], w[X][K[1]], w[X][K[7]], y) & K[5]) ||
                (LB3 (w[K[0]][K[7]], w[K[4]][K[7]], w[X][K[8]], y) & K[5])) &&
                (((G[I].g[w[K[2]][W[3][y]]] | G[I].g[w[K[2]][W[4][y]]] |
                G[I].g[w[K[4]][W[3][y]]] | G[I].g[w[K[4]][W[4][y]]] | (B[G[I].g[K[0]]] < 3 ? 0 :
                G[I].g[A = w[K[4]][K[1]]] | G[I].g[w[A][W[3][y]]] | G[I].g[w[A][W[4][y]]]) |
                (k[0] && (B[G[I].g[K[0]]] < 3 || w[K[0]][K[8]] == M) &&
                (~(G[I].g[w[X][W[3][y]]] | G[I].g[w[X][W[4][y]]]) & K[5]) ?
                G[I].g[w[X][W[1][!y]]] | G[I].g[w[X][W[18][!y]]] | G[I].g[w[X][W[19][!y]]] |
                G[I].g[w[X][W[20][!y]]] | G[I].g[w[X][W[21][!y]]] | G[I].g[w[X][W[22][!y]]] : 0) |
                (k[0] && (~(G[I].g[w[Z][W[3][y]]] | G[I].g[w[Z][W[4][y]]]) & K[5]) ?
                G[I].g[w[Z][W[1][!y]]] | G[I].g[w[Z][W[18][!y]]] | G[I].g[w[Z][W[19][!y]]] |
                G[I].g[w[Z][W[20][!y]]] | G[I].g[w[Z][W[21][!y]]] | G[I].g[w[Z][W[22][!y]]] : 0)) & K[5]) ||
                ((G[I].g[w[K[0]][W[3][y]]] | G[I].g[w[K[0]][W[4][y]]] |
                G[I].g[L = w[K[0]][K[7]]] | G[I].g[w[L][W[3][y]]] | G[I].g[w[L][W[4][y]]] |
                G[I].g[w[K[2]][W[3][y]]] | G[I].g[w[K[2]][W[4][y]]]) & (G[I].g[K[2]] ^ K[5])) ||
                ((G[I].g[w[K[0]][W[3][y]]] | G[I].g[w[K[0]][W[4][y]]] | G[I].g[M] | G[I].g[w[M][W[3][y]]] |
                G[I].g[w[M][W[4][y]]] | G[I].g[w[K[4]][W[3][y]]] | G[I].g[w[K[4]][W[4][y]]] |
                (w[K[0]][K[8]] == M ? G[I].g[w[K[4]][W[1][!y]]] | G[I].g[w[K[4]][W[18][!y]]] |
                G[I].g[w[K[4]][W[19][!y]]] | G[I].g[w[K[4]][W[20][!y]]] | G[I].g[w[K[4]][W[21][!y]]] |
                G[I].g[w[K[4]][W[22][!y]]] : 0)) & (G[I].g[K[4]] ^ K[5]))))
              {              // Line Ring 05, 07, Box Ring 06, 08, Reduced Line Ring 09, 10, 11, 12
                if (B[G[I].g[K[0]]] > 2)
                {
                  G[I].g[A] &= ~K[5];
                  G[I].g[w[A][W[3][y]]] &= ~K[5];
                  G[I].g[w[A][W[4][y]]] &= ~K[5];
                }
                G[I].g[w[K[0]][W[3][y]]] &= ~G[I].g[K[0]];
                G[I].g[w[K[0]][W[4][y]]] &= ~G[I].g[K[0]];
                G[I].g[w[K[2]][W[3][y]]] &= ~G[I].g[K[2]];
                G[I].g[w[K[2]][W[4][y]]] &= ~G[I].g[K[2]];
                G[I].g[L = w[K[0]][K[7]]] &= (Y = ~(G[I].g[K[2]] ^ K[5]));
                G[I].g[w[L][W[3][y]]] &= Y;
                G[I].g[w[L][W[4][y]]] &= Y;
                G[I].g[w[K[4]][W[3][y]]] &= ~G[I].g[K[4]];
                G[I].g[w[K[4]][W[4][y]]] &= ~G[I].g[K[4]];
                G[I].g[M] &= (Y = ~(G[I].g[K[4]] ^ K[5]));
                G[I].g[w[M][W[3][y]]] &= Y;
                G[I].g[w[M][W[4][y]]] &= Y;
                if (w[K[0]][K[8]] == M)
                {
                  G[I].g[w[K[4]][W[1][!y]]] &= Y;
                  G[I].g[w[K[4]][W[18][!y]]] &= Y;
                  G[I].g[w[K[4]][W[19][!y]]] &= Y;
                  G[I].g[w[K[4]][W[20][!y]]] &= Y;
                  G[I].g[w[K[4]][W[21][!y]]] &= Y;
                  G[I].g[w[K[4]][W[22][!y]]] &= Y;
                }
                if (k[0] && (B[G[I].g[K[0]]] < 3 || w[K[0]][K[8]] == M) &&
                  ~(G[I].g[w[M][W[3][y]]] | G[I].g[w[M][W[4][y]]]) & K[5])
                {            // Reduced Line Ring 09, 12
                  G[I].g[w[K[4]][W[1][!y]]] &= ~K[5];
                  G[I].g[w[K[4]][W[18][!y]]] &= ~K[5];
                  G[I].g[w[K[4]][W[19][!y]]] &= ~K[5];
                  G[I].g[w[K[4]][W[20][!y]]] &= ~K[5];
                  G[I].g[w[K[4]][W[21][!y]]] &= ~K[5];
                  G[I].g[w[K[4]][W[22][!y]]] &= ~K[5];
#if RJ > 2
                  k[1] = 1;
#endif
                }
                if (k[0] && ~(G[I].g[w[Y = w[K[2]][K[8]]][W[3][y]]] | G[I].g[w[Y][W[4][y]]]) & K[5])
                {            // Reduced Line Ring 10, 11, 12
                  G[I].g[w[K[2]][W[1][!y]]] &= ~K[5];
                  G[I].g[w[K[2]][W[18][!y]]] &= ~K[5];
                  G[I].g[w[K[2]][W[19][!y]]] &= ~K[5];
                  G[I].g[w[K[2]][W[20][!y]]] &= ~K[5];
                  G[I].g[w[K[2]][W[21][!y]]] &= ~K[5];
                  G[I].g[w[K[2]][W[22][!y]]] &= ~K[5];
#if RJ > 2
                  k[2] = 1;
#endif
                }
#if RJ > 2
                printf ("%d) XY%s Transport:%s%s Ring %d @ r%dc%d %s SL %d @ %s %d\n=> -%d @ r%dc%d r%dc%d",
                  G[I].p, B[G[I].g[K[0]]] < 3 ? "-Wing Type 2" : "Z-Wing",
                  (k[1] | k[2]) ? " Reduced " : " ", k[0] ? R_C : "Box", b[G[I].g[K[2]] | G[I].g[K[4]]],
                  ROW (w[K[0]][20] | w[K[2]][20]), COL (w[K[0]][20] | w[K[2]][20]),
                  S[K[4]], b[K[5]], k[0] ? R_C : "Box", k[0] ? RCN (M) : BOX (M), b[K[5]],
                  ROW (w[w[K[2]][W[3][y]]][20] | w[w[K[2]][W[4][y]]][20]),
                  COL (w[w[K[2]][W[3][y]]][20] | w[w[K[2]][W[4][y]]][20]),
                  ROW (w[w[K[4]][W[3][y]]][20] | w[w[K[4]][W[4][y]]][20]),
                  COL (w[w[K[4]][W[3][y]]][20] | w[w[K[4]][W[4][y]]][20]));
                if (B[G[I].g[K[0]]] > 2)
                  printf (" r%dc%d",
                    ROW (w[A][20] | w[w[A][W[3][y]]][20] | w[w[A][W[4][y]]][20]),
                    COL (w[A][20] | w[w[A][W[3][y]]][20] | w[w[A][W[4][y]]][20]));
                if (k[1])
                  printf (" r%dc%d",
                    ROW (w[w[K[4]][W[1][!y]]][20] | w[w[K[4]][W[18][!y]]][20] |
                    w[w[K[4]][W[19][!y]]][20] | w[w[K[4]][W[20][!y]]][20] |
                    w[w[K[4]][W[21][!y]]][20] | w[w[K[4]][W[22][!y]]][20]),
                    COL (w[w[K[4]][W[1][!y]]][20] | w[w[K[4]][W[18][!y]]][20] |
                    w[w[K[4]][W[19][!y]]][20] | w[w[K[4]][W[20][!y]]][20] |
                    w[w[K[4]][W[21][!y]]][20] | w[w[K[4]][W[22][!y]]][20]));
                if (k[2])
                  printf (" r%dc%d",
                    ROW (w[w[K[2]][W[1][!y]]][20] | w[w[K[2]][W[18][!y]]][20] |
                    w[w[K[2]][W[19][!y]]][20] | w[w[K[2]][W[20][!y]]][20] |
                    w[w[K[2]][W[21][!y]]][20] | w[w[K[2]][W[22][!y]]][20]),
                    COL (w[w[K[2]][W[1][!y]]][20] | w[w[K[2]][W[18][!y]]][20] |
                    w[w[K[2]][W[19][!y]]][20] | w[w[K[2]][W[20][!y]]][20] |
                    w[w[K[2]][W[21][!y]]][20] | w[w[K[2]][W[22][!y]]][20]));
                printf (" => -%d @ r%dc%d => -%d @ r%dc%d r%dc%d r%dc%d", b[G[I].g[K[2]] ^ K[5]],
                  ROW (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20] |
                  w[w[K[2]][W[3][y]]][20] | w[w[K[2]][W[4][y]]][20] |
                  w[L][20] | w[w[L][W[3][y]]][20] | w[w[L][W[4][y]]][20]),
                  COL (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20] |
                  w[w[K[2]][W[3][y]]][20] | w[w[K[2]][W[4][y]]][20] | w[L][20] |
                  w[w[L][W[3][y]]][20] | w[w[L][W[4][y]]][20]), b[G[I].g[K[4]] ^ K[5]],
                  ROW (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20]),
                  COL (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20]),
                  ROW (w[w[K[4]][W[3][y]]][20] | w[w[K[4]][W[4][y]]][20]),
                  COL (w[w[K[4]][W[3][y]]][20] | w[w[K[4]][W[4][y]]][20]),
                  ROW (w[M][20] | w[w[M][W[3][y]]][20] | w[w[M][W[4][y]]][20]),
                  COL (w[M][20] | w[w[M][W[3][y]]][20] | w[w[M][W[4][y]]][20]));
                if (w[K[0]][K[8]] == M)
                  printf (" r%dc%d",
                    ROW (w[w[K[4]][W[1][!y]]][20] | w[w[K[4]][W[18][!y]]][20] |
                    w[w[K[4]][W[19][!y]]][20] | w[w[K[4]][W[20][!y]]][20] |
                    w[w[K[4]][W[21][!y]]][20] | w[w[K[4]][W[22][!y]]][20]),
                    COL (w[w[K[4]][W[1][!y]]][20] | w[w[K[4]][W[18][!y]]][20] |
                    w[w[K[4]][W[19][!y]]][20] | w[w[K[4]][W[20][!y]]][20] |
                    w[w[K[4]][W[21][!y]]][20] | w[w[K[4]][W[22][!y]]][20]));
                printf ("\n");
#endif
                goto START;
              }
              for (Y = W[1][!y]; Y < W[2][!y]; ++Y)
              {
                A = W[Y < W[5][!y] ? 5 : 1][!y];
                if (((k[0] = LN1 (w[K[2]][Y], w[K[4]][Y], w[Z][K[7]], y) & K[5]) ||
                  (ERI (X) & ERI (Z) & K[5])) &&
                  (((G[I].g[M = w[K[4]][N]] | (B[G[I].g[K[0]]] < 3 || w[K[0]][K[8]] == M ?
                  (k[0] ? G[I].g[w[X][W[3][!y]]] | G[I].g[w[X][W[4][!y]]] |
                  G[I].g[w[Z][W[3][!y]]] | G[I].g[w[Z][W[4][!y]]] : G[I].g[X] | G[I].g[Z] |
                  G[I].g[w[Z][K[7]]] | G[I].g[w[Z][K[7] + 1]] | G[I].g[w[Z][K[7] + 2]]) |
                  G[I].g[w[K[4]][K[1]]] | G[I].g[w[K[2]][K[8]]] | G[I].g[L = w[K[2]][A]] |
                  G[I].g[w[L][W[3][!y]]] | G[I].g[w[L][W[4][!y]]] | G[I].g[L = w[K[4]][A]] |
                  G[I].g[w[L][W[3][!y]]] | G[I].g[w[L][W[4][!y]]] : 0)) & K[5]) ||
                  ((G[I].g[w[K[0]][W[3][y]]] | G[I].g[w[K[0]][W[4][y]]] |
                  G[I].g[w[K[0]][K[7]]] | G[I].g[w[K[0]][K[7] + 1]] | G[I].g[w[K[0]][K[7] + 2]] |
                  G[I].g[w[K[2]][W[3][y]]] | G[I].g[w[K[2]][W[4][y]]]) & (G[I].g[K[2]] ^ K[5])) ||
                  ((G[I].g[w[K[0]][W[3][y]]] | G[I].g[w[K[0]][W[4][y]]] |
                  G[I].g[M] | G[I].g[w[M][W[3][y]]] | G[I].g[w[M][W[4][y]]] |
                  G[I].g[w[K[4]][W[3][y]]] | G[I].g[w[K[4]][W[4][y]]] |
                  (w[K[0]][K[8]] == M ? (k[0] ? G[I].g[w[Z][W[3][!y]]] |
                  G[I].g[w[Z][W[4][!y]]] : G[I].g[Z]) | G[I].g[w[K[4]][A]] | G[I].g[w[K[4]][A + 1]] |
                  G[I].g[w[K[4]][A + 2]] : 0)) & (G[I].g[K[4]] ^ K[5]))))
                {            // Line Ring 13, 14, ERI Ring 15, 16
                  G[I].g[w[K[0]][W[3][y]]] &= ~G[I].g[K[0]];
                  G[I].g[w[K[0]][W[4][y]]] &= ~G[I].g[K[0]];
                  G[I].g[w[K[2]][W[3][y]]] &= ~(G[I].g[K[2]] ^ K[5]);
                  G[I].g[w[K[2]][W[4][y]]] &= ~(G[I].g[K[2]] ^ K[5]);
                  G[I].g[w[K[0]][K[7]]] &= ~(G[I].g[K[2]] ^ K[5]);
                  G[I].g[w[K[0]][K[7] + 1]] &= ~(G[I].g[K[2]] ^ K[5]);
                  G[I].g[w[K[0]][K[7] + 2]] &= ~(G[I].g[K[2]] ^ K[5]);
                  G[I].g[w[K[4]][W[3][y]]] &= ~(G[I].g[K[4]] ^ K[5]);
                  G[I].g[w[K[4]][W[4][y]]] &= ~(G[I].g[K[4]] ^ K[5]);
                  G[I].g[M] &= ~G[I].g[K[4]];
                  G[I].g[w[M][W[3][y]]] &= ~(G[I].g[K[4]] ^ K[5]);
                  G[I].g[w[M][W[4][y]]] &= ~(G[I].g[K[4]] ^ K[5]);
                  if (B[G[I].g[K[0]]] < 3 || w[K[0]][K[8]] == M)
                  {          // Line Ring 14, ERI Ring 16
                    k[1] = ~(w[K[0]][K[8]] == M ? G[I].g[K[4]] : K[5]);
                    if (k[0])
                    {        // Line Ring 14
                      G[I].g[w[X][W[3][!y]]] &= ~K[5];
                      G[I].g[w[X][W[4][!y]]] &= ~K[5];
                      G[I].g[w[Z][W[3][!y]]] &= k[1];
                      G[I].g[w[Z][W[4][!y]]] &= k[1];
                    }
                    else
                    {        // ERI Ring 16
                      G[I].g[X] &= ~K[5];
                      G[I].g[Z] &= k[1];
                      G[I].g[w[Z][K[7]]] &= ~K[5];
                      G[I].g[w[Z][K[7] + 1]] &= ~K[5];
                      G[I].g[w[Z][K[7] + 2]] &= ~K[5];
                    }
                    G[I].g[w[K[4]][K[1]]] &= ~K[5];
                    G[I].g[w[K[2]][K[8]]] &= ~K[5];
                    G[I].g[L = w[K[2]][A]] &= ~K[5];
                    G[I].g[w[L][W[3][!y]]] &= ~K[5];
                    G[I].g[w[L][W[4][!y]]] &= ~K[5];
                    G[I].g[L = w[K[4]][A]] &= k[1];
                    G[I].g[w[L][W[3][!y]]] &= k[1];
                    G[I].g[w[L][W[4][!y]]] &= k[1];
                  }
#if RJ > 2
                  printf ("%d) XY%s Transport: %s Ring %d @ r%dc%d %s SL %s %d between %d @ %s and %d @ %s\n=> -%d @ %s",
                    G[I].p, B[G[I].g[K[0]]] < 3 ? "-Wing Type 2" : "Z-Wing", k[0] ? R_C : "ERI",
                    b[G[I].g[K[2]] | G[I].g[K[4]]], ROW (w[K[0]][20] | w[K[2]][20]),
                    COL (w[K[0]][20] | w[K[2]][20]), S[K[4]], k[0] ? R_C : "ERI",
                    k[0] ? RCN (X) : BOX (X), b[K[5]], S[X], b[K[5]], S[Z], b[K[5]], S[M]);
                  if (B[G[I].g[K[0]]] < 3 || w[K[0]][K[8]] == M)
                  {
                    if (k[0])
                      printf (" r%dc%d r%dc%d",
                        ROW (w[w[X][W[3][!y]]][20] | w[w[X][W[4][!y]]][20]),
                        COL (w[w[X][W[3][!y]]][20] | w[w[X][W[4][!y]]][20]),
                        ROW (w[w[Z][W[3][!y]]][20] | w[w[Z][W[4][!y]]][20]),
                        COL (w[w[Z][W[3][!y]]][20] | w[w[Z][W[4][!y]]][20]));
                    else
                      printf (" %s r%dc%d", S[X],
                        ROW (w[Z][20] | w[w[Z][K[7]]][20] |
                        w[w[Z][K[7] + 1]][20] | w[w[Z][K[7] + 2]][20]),
                        COL (w[Z][20] | w[w[Z][K[7]]][20] |
                        w[w[Z][K[7] + 1]][20] | w[w[Z][K[7] + 2]][20]));
                    if (B[G[I].g[K[0]]] > 2)
                      printf (" %s", S[w[K[4]][K[1]]]);
                    printf (" %s %s %s %s %s %s %s", S[w[K[2]][K[8]]],
                      S[w[K[2]][A]], S[w[w[K[2]][A]][W[3][!y]]], S[w[w[K[2]][A]][W[4][!y]]],
                      S[w[K[4]][A]], S[w[w[K[4]][A]][W[3][!y]]], S[w[w[K[4]][A]][W[4][!y]]]);
                  }
                  printf ("\n=> -%d @ r%dc%d => -%d @ r%dc%d r%dc%d r%dc%d",
                    b[G[I].g[K[2]] ^ K[5]], ROW (w[w[K[0]][W[3][y]]][20] |
                    w[w[K[0]][W[4][y]]][20] | w[w[K[2]][W[3][y]]][20] |
                    w[w[K[2]][W[4][y]]][20] | w[w[K[0]][K[7]]][20] |
                    w[w[K[0]][K[7] + 1]][20] | w[w[K[0]][K[7] + 2]][20]),
                    COL (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20] |
                    w[w[K[2]][W[3][y]]][20] | w[w[K[2]][W[4][y]]][20] |
                    w[w[K[0]][K[7]]][20] | w[w[K[0]][K[7] + 1]][20] |
                    w[w[K[0]][K[7] + 2]][20]), b[G[I].g[K[4]] ^ K[5]],
                    ROW (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20]),
                    COL (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20]),
                    ROW (w[w[K[4]][W[3][y]]][20] | w[w[K[4]][W[4][y]]][20]),
                    COL (w[w[K[4]][W[3][y]]][20] | w[w[K[4]][W[4][y]]][20]),
                    ROW (w[M][20] | w[w[M][W[3][y]]][20] | w[w[M][W[4][y]]][20]),
                    COL (w[M][20] | w[w[M][W[3][y]]][20] | w[w[M][W[4][y]]][20]));
                  if (w[K[0]][K[8]] == M)
                    printf (" r%dc%d", ROW ((k[0] ? w[w[Z][W[3][!y]]][20] |
                      w[w[Z][W[4][!y]]][20] : w[Z][20]) | w[w[K[4]][A]][20] |
                      w[w[w[K[4]][A]][W[3][!y]]][20] | w[w[w[K[4]][A]][W[4][!y]]][20]),
                      COL ((k[0] ? w[w[Z][W[3][!y]]][20] |
                      w[w[Z][W[4][!y]]][20] : w[Z][20]) | w[w[K[4]][A]][20] |
                      w[w[w[K[4]][A]][W[3][!y]]][20] | w[w[w[K[4]][A]][W[4][!y]]][20]));
                  printf ("\n");
#endif
                  goto START;
                }
                if (B[G[I].g[K[0]]] > 2 && w[K[0]][K[8]] != w[K[4]][N])
                  for (A = 3; A < 5; ++A)
                    if (((k[0] = LN1 (w[L = w[w[K[4]][K[1]]][W[A][y]]][Y],
                      w[K[0]][Y], w[Z][K[7]], y) & K[5]) ||
                      (ERI (X) & ERI (Z) & K[5])) && G[I].g[L] & K[5])
                    {        // Line 17, ERI 18
                      G[I].g[L] -= K[5];
#if RJ > 2
                      printf ("%d) XYZ-Wing Transport: %s %d @ r%dc%d %s SL %s %d between%s%d @ %s and%s%d @ %s\n=> -%d @ %s\n",
                        G[I].p, k[0] ? R_C : "ERI", b[G[I].g[K[0]]], ROW (w[K[0]][20] | w[K[2]][20]),
                        COL (w[K[0]][20] | w[K[2]][20]), S[K[4]], k[0] ? R_C : "ERI",
                        k[0] ? RCN (X) : BOX (X), k[29] ? " " : " ERI ", b[K[5]], S[X],
                        k[0] ? " " : " ERI ", b[K[5]], S[Z], b[K[5]], S[L]);
#endif
                      goto START;
                    }
                for (M = 0; M < 2; ++M)
                {
                  if (!M || B[G[I].g[K[0]]] < 3)
                    for (A = K[7]; A < K[7] + 3; ++A)
                      if (((k[0] = LN1 (w[L = w[K[W[16][M]]][A]][Y],
                        w[K[4 >> M]][Y], w[K[2 << M]][Y], y) & K[5]) ||
                        (ERI (X) & ERI (Z) & K[5])) && ((G[I].g[L] | (!k[0] &&
                        (B[G[I].g[K[0]]] < 3 || w[K[0]][K[8]] == w[K[4]][N]) ?
                        G[I].g[w[K[2 << M]][Y]] : 0)) & K[5]))
                      {      // Line 19, ERI 20, 21
                        G[I].g[L] &= ~K[5];
                        if (!k[0] && (B[G[I].g[K[0]]] < 3 || w[K[0]][K[8]] == w[K[4]][N]))
                             // ERI 21
                          G[I].g[w[K[2 << M]][Y]] &= ~K[5];
#if RJ > 2
                        printf ("%d) XY%s Transport: %s %d @ r%dc%d %s SL %d @ %s %d => -%d @ %s",
                          G[I].p, B[G[I].g[K[0]]] < 3 ? "-Wing Type 2" : "Z-Wing", k[0] ? R_C : "ERI",
                          b[G[I].g[K[2]] | G[I].g[K[4]]], ROW (w[K[0]][20] | w[K[2]][20]),
                          COL (w[K[0]][20] | w[K[2]][20]), S[K[4]], b[K[5]],
                          k[0] ? R_C : "ERI Box", k[0] ? RCN (X) : BOX (X), b[K[5]], S[L]);
                        if (!k[0] && (B[G[I].g[K[0]]] < 3 || w[K[0]][K[8]] == w[K[4]][N]))
                          printf (" %s", S[w[K[2 << M]][Y]]);
                        printf ("\n");
#endif
                        goto START;
                      }
                  for (A = 3; A < 5; ++A)
                    if (((k[0] = LN1 (w[L = w[K[2 << M]][W[A][y]]][Y],
                      w[K[4 >> M]][Y], w[M ? X : Z][K[7]], y) & K[5]) ||
                      (ERI (X) & ERI (Z) & K[5])) &&
                      ((G[I].g[L] | (B[G[I].g[K[0]]] < 3 || w[K[0]][K[8]] == w[K[4]][N] ?
                      (M ? G[I].g[w[L][N]] : G[I].g[w[L][W[3][!y]]] | G[I].g[w[L][W[4][!y]]]) |
                      (k[0] ? G[I].g[w[w[K[2 << M]][Y]][W[3][!y]]] |
                      G[I].g[w[w[K[2 << M]][Y]][W[4][!y]]] : G[I].g[w[K[2 << M]][Y]]) : 0)) & K[5]))
                    {        // Line 22, 24, 26, 28, 30 ERI 23, 25, 27, 29, 31
                      G[I].g[L] &= ~K[5];
                      if (B[G[I].g[K[0]]] < 3 || w[K[0]][K[8]] == w[K[4]][N])
                      {      // Line 22, 24 ERI 23, 25
                        if (M)
                        {    // Line 22, ERI 23
                          G[I].g[w[L][N]] &= ~K[5];
                        }
                        else
                        {    // Line 24, ERI 25
                          if (B[G[I].g[K[0]]] < 3)
                          {
                            G[I].g[w[L][K[8]]] &= ~K[5];
                          }
                          else
                          {
                            G[I].g[w[L][W[3][!y]]] &= ~K[5];
                            G[I].g[w[L][W[4][!y]]] &= ~K[5];
                          }
                        }
                        if (k[0])
                        {    // Line 26, 28, 30
                          G[I].g[w[w[K[2 << M]][Y]][W[3][!y]]] &= ~K[5];
                          G[I].g[w[w[K[2 << M]][Y]][W[4][!y]]] &= ~K[5];
                        }
                        else // ERI 27, 29, 31
                          G[I].g[w[K[2 << M]][Y]] &= ~K[5];
                      }
#if RJ > 2
                      printf ("%d) XY%s Transport: %s %d @ r%dc%d %s SL %s %d between %d @ %s and %d @ %s\n=> -%d @ %s",
                        G[I].p, B[G[I].g[K[0]]] < 3 ? "-Wing Type 2" : "Z-Wing", k[0] ? R_C : "ERI",
                        b[G[I].g[K[2]] | G[I].g[K[4]]], ROW (w[K[0]][20] | w[K[2]][20]),
                        COL (w[K[0]][20] | w[K[2]][20]), S[K[4]], k[0] ? R_C : "ERI",
                        k[0] ? RCN (X) : BOX (X), b[K[5]], S[X], b[K[5]], S[Z], b[K[5]], S[L]);
                      if (B[G[I].g[K[0]]] < 3 || w[K[0]][K[8]] == w[K[4]][N])
                      {
                        printf (" %s", S[w[L][M ? N : (B[G[I].g[K[0]]] < 3 ? K[8] : W[3][!y])]]);
                        if (!M && B[G[I].g[K[0]]] > 2)
                          printf (" %s", S[w[L][W[4][!y]]]);
                      }
                      printf (" %s", S[k[0] ? w[w[K[2 << M]][Y]][W[3][!y]] : w[K[2 << M]][Y]]);
                      if (k[0])
                        printf (" %s", S[w[w[K[2 << M]][Y]][W[4][!y]]]);
                      printf ("\n");
#endif
                      goto START;
                    }
                  if ((B[G[I].g[K[0]]] < 3 || w[K[0]][K[8]] == w[K[4]][N]) &&
                    (G[I].g[w[K[4 >> M]][Y]] & ERI (w[K[2 << M]][Y]) & K[5]))
                  {          // ERI 32, 33
                    G[I].g[w[K[4 >> M]][Y]] -= K[5];
#if RJ > 2
                    printf ("%d) XY%s Transport: ERI %d @ r%dc%d %s SL ERI %d @ b%d%s => -%d @ %s\n",
                      G[I].p, B[G[I].g[K[0]]] < 3 ? "-Wing Type 2" : "Z-Wing", b[G[I].g[K[2]] | G[I].g[K[4]]],
                      ROW (w[K[0]][20] | w[K[2]][20]), COL (w[K[0]][20] | w[K[2]][20]),
                      S[K[4]], b[K[5]], BOX (w[K[2 << M]][Y]), S[w[K[2 << M]][Y]],
                      b[K[5]], S[w[K[4 >> M]][Y]]);
#endif
                    goto START;
                  }
                }
              }
            }
            if (B[G[I].g[K[0]]] > 2 &&
              (G[I].g[w[K[4]][K[6]]] | G[I].g[w[K[4]][K[6] + 1]] | G[I].g[w[K[4]][K[6] + 2]]) & K[5])
            {                // Check XYZ-Wing Hybrid for Apex Cell values > two digits; and Wing Cells common value found in XYZ-Wing Hybrid Cells values
              int k[3] = { 0, 0, 0};

              if (~(G[I].g[w[K[4]][K[7]]] | G[I].g[w[K[4]][K[7] + 1]] | G[I].g[w[K[4]][K[7] + 2]]) &
                (G[I].g[X = w[K[0]][K[8]]] | G[I].g[w[X][W[3][y]]] | G[I].g[w[X][W[4][y]]] |
                (Y = (w[K[0]][20] & w[K[4]][20] & W[15][y]) &&
                (~(G[I].g[w[K[4]][W[3][y]]] | G[I].g[w[K[4]][W[4][y]]]) & K[5]) ?
                G[I].g[w[K[0]][W[1][!y]]] | G[I].g[w[K[0]][W[18][!y]]] |
                G[I].g[w[K[0]][W[19][!y]]] | G[I].g[w[K[0]][W[20][!y]]] |
                G[I].g[w[K[0]][W[21][!y]]] | G[I].g[w[K[0]][W[22][!y]]] : 0)) & K[5])
              {              // Check XYZ-Wing Hybrid for either 2nd Wing Line wise or other Box wise and Wing Cells common value found in removal Cells values
                G[I].g[X] &= ~K[5];
                G[I].g[w[X][W[3][y]]] &= ~K[5];
                G[I].g[w[X][W[4][y]]] &= ~K[5];
                k[0] = 1;
                if (Y)
                {                // Check Apex and 2nd Wing in Line; and Wing Cells common digit not in 2nd Wing mini-Line Cells values
                  G[I].g[w[K[0]][W[1][!y]]] &= ~K[5];
                  G[I].g[w[K[0]][W[18][!y]]] &= ~K[5];
                  G[I].g[w[K[0]][W[19][!y]]] &= ~K[5];
                  G[I].g[w[K[0]][W[20][!y]]] &= ~K[5];
                  G[I].g[w[K[0]][W[21][!y]]] &= ~K[5];
                  G[I].g[w[K[0]][W[22][!y]]] &= ~K[5];
#if RJ > 2
                  k[2] = 1;
#endif
                }
              }
              if (((G[I].g[w[K[0]][K[7]]] | G[I].g[w[K[0]][K[7] + 1]] | G[I].g[w[K[0]][K[7] + 2]]) & K[5]) &&
                ((~(G[I].g[Z = w[K[2]][K[8]]] | G[I].g[w[Z][W[3][y]]] | G[I].g[w[Z][W[4][y]]]) & K[5]) ||
                (~(G[I].g[Z] | G[I].g[w[K[2]][W[1][!y]]] | G[I].g[w[K[2]][W[18][!y]]] |
                G[I].g[w[K[2]][W[19][!y]]] | G[I].g[w[K[2]][W[20][!y]]] | G[I].g[w[K[2]][W[21][!y]]] |
                G[I].g[w[K[2]][W[22][!y]]]) & G[I].g[w[K[4]][K[1]]] & K[5])))
              {              // Backup XYZ-Wing Hybrid 1st Wing either Line or Box wise and remove Wing Cells common value from removal Cells values
                G[I].g[w[K[0]][K[7]]] &= ~K[5];
                G[I].g[w[K[0]][K[7] + 1]] &= ~K[5];
                G[I].g[w[K[0]][K[7] + 2]] &= ~K[5];
                k[1] = 1;
              }
              if (!k[0] && !k[1])
                continue;    // Skip for no XYZ-Wing Hybrid found
#if RJ > 2
              printf ("%d)%sXYZ-Wing Hybrid: %d @ r%dc%d %s%s%s Hybrid %d @ r%dc%d => -%d @",
                G[I].p, k[0] & k[1] ? " Dual " : " ", b[G[I].g[K[2]] | G[I].g[K[4]]],
                ROW (w[K[0]][20] | w[K[2]][20]), COL (w[K[0]][20] | w[K[2]][20]), S[K[4]],
                k[2] ? " Reduced " : " ", k[0] & k[1] ? "Dual" :
                (k[0] ? (y ? "Column wise" : "Row wise") : "Box wise"), b[K[5]],
                ROW (w[w[K[4]][K[6]]][20] | w[w[K[4]][K[6] + 1]][20] |
                w[w[K[4]][K[6] + 2]][20]), COL (w[w[K[4]][K[6]]][20] |
                w[w[K[4]][K[6] + 1]][20] | w[w[K[4]][K[6] + 2]][20]), b[K[5]]);
              if (k[0])
                printf (" r%dc%d", ROW (w[X][20] | w[w[X][W[3][y]]][20] | w[w[X][W[4][y]]][20]),
                  COL (w[X][20] | w[w[X][W[3][y]]][20] | w[w[X][W[4][y]]][20]));
              if (k[1])
                printf (" r%dc%d", ROW (w[w[K[0]][K[7]]][20] | w[w[K[0]][K[7] + 1]][20] |
                  w[w[K[0]][K[7] + 2]][20]), COL (w[w[K[0]][K[7]]][20] |
                  w[w[K[0]][K[7] + 1]][20] | w[w[K[0]][K[7] + 2]][20]));
              if (k[2])
                printf (" r%dc%d", ROW (w[w[K[0]][W[1][!y]]][20] | w[w[K[0]][W[18][!y]]][20] |
                  w[w[K[0]][W[19][!y]]][20] | w[w[K[0]][W[20][!y]]][20] |
                  w[w[K[0]][W[21][!y]]][20] | w[w[K[0]][W[22][!y]]][20]),
                  COL (w[w[K[0]][W[1][!y]]][20] | w[w[K[0]][W[18][!y]]][20] |
                  w[w[K[0]][W[19][!y]]][20] | w[w[K[0]][W[20][!y]]][20] |
                  w[w[K[0]][W[21][!y]]][20] | w[w[K[0]][W[22][!y]]][20]));
              printf ("\n");
#endif
              goto START;
            }
          }
        }
      }
    }
    for (a = G[I].p; a < q; ++a)
    {                        // Search WXYZ-Wing Type 1, Almost Locked Set move Type 1a and Type 1b Apex unsolved Cell positions wise
      if (B[G[I].g[r[a]]] > 4 ||
                             // Skip for either unsolved Cell values > four digits; or
        !(G[I].g[w[r[a]][0]] | G[I].g[w[r[a]][1]] | G[I].g[w[r[a]][2]] |
        G[I].g[w[r[a]][3]] | G[I].g[w[r[a]][4]] | G[I].g[w[r[a]][5]]) ||
        !(G[I].g[w[r[a]][14]] | G[I].g[w[r[a]][15]] | G[I].g[w[r[a]][16]] |
        G[I].g[w[r[a]][17]] | G[I].g[w[r[a]][18]] | G[I].g[w[r[a]][19]]))
        continue;            // No unsolved Cell position found in either Apex Row or Column
      int K[9] = {r[a], 0};  // Assign Apex Cell position

      for (; K[1] < 8; ++K[1])
      {                      // Search 1st Wing Cell position Row wise
        if (!G[I].g[K[2] = w[K[0]][K[1]]] || B[G[I].g[K[0]] | G[I].g[K[2]]] > 4)
          continue;          // Skip for either 1st Wing Cell position not unsolved; or Apex and 1st Wing Cells values > four digits
        for (K[3] = K[1] > 5 ? 14 : 12; K[3] < 20; ++K[3])
        {                    // Search 2nd Wing Cell position Column wise but not both Wings in Apex Box
          if (!G[I].g[K[4] = w[K[0]][K[3]]] || B[G[I].g[K[0]] | G[I].g[K[2]] | G[I].g[K[4]]] > 4)
            continue;        // Skip for either 2nd Wing Cell position not unsolved; or Apex and Wings Cells values > four digits
          for (Y = 0; Y < 2; ++Y)
          {                  // Search 3rd Wing Cell position Line wise
            if ((!Y && K[3] < 14) || (Y && K[1] > 5) || B[G[I].g[K[4 >> Y]]] > 2)
              continue;      // Skip for either 2nd (or 1st) Wing Cell position within Chute; or 2nd (or 1st) Wing Cell values > two digits
            for (K[5] = !Y && K[1] > 5 ? 0 : K[W[14][Y]] + (Y && K[3] == 12) + 1; K[5] < W[2][Y]; ++K[5])
            {                // Search 3rd Wing Cell position
              if (!G[I].g[K[6] = w[K[0]][K[5]]] || B[G[I].g[K[0]] | G[I].g[K[2]] | G[I].g[K[4]] | G[I].g[K[6]]] > 4 ||
                             // Skip for either 3rd Wing Cell position not unsolved; or Apex and Wings Cells values > four digits; or
                B[K[7] = G[I].g[K[4 >> Y]] & (G[I].g[K[2 << Y]] | G[I].g[K[6]])] != 1 ||
                             // Wing Cells common value not one digit; or
                ((G[I].g[K[0]] & K[7]) &&
                             // Wing Cells common value in Apex Cell values; and
                !((G[I].g[K[2]] & K[7]) && K[1] > 5) && !((G[I].g[K[4]] & K[7]) && K[3] < 14)) ||
                             // either 2nd or 3rd Wing Cell position within Apex Box; or
                (G[I].g[K[2 << Y]] & G[I].g[K[6]] & K[7]))
                continue;    // Wing Cells common value in Both 1st (or 2nd) and 3rd Wing Cells values
              int k[6] = {G[I].g[K[8] = K[G[I].g[K[2]] & K[7] ? 2 : 6] - K[0] +
                         K[G[I].g[K[4]] & K[7] ? 4 : 6]], 0, 0, 0, 0,-1};

              if (((G[I].g[K[2]] & K[7]) && K[1] > 5) || ((G[I].g[K[4]] & K[7]) && K[3] < 14))
              {              // Wings Cells common value in Wing Cell position within Apex Box
                k[5] = (G[I].g[K[2]] & K[7]) && K[1] > 5;
                if (G[I].g[K[0]] & K[7])
                  k[0] = 0;
                else
                {
                  k[1] = G[I].g[w[K[8]][W[3][k[5]]]];
                  k[2] = G[I].g[w[K[8]][W[4][k[5]]]];
                }
                k[3] = G[I].g[w[K[0]][W[3][k[5]]]];
                k[4] = G[I].g[w[K[0]][W[4][k[5]]]];
              }
              if ((k[0] | k[1] | k[2] | k[3] | k[4]) & K[7])
              {              // Check no Wing Cells common value in WXYZ-Wing Type 1 removal Cell values
                if (k[5] + 1)
                {            // Drop Wing Cells common value from WXYZ-Wing Type 1 removal Cell positions
                  G[I].g[w[K[0]][W[3][k[5]]]] &= ~K[7];
                  G[I].g[w[K[0]][W[4][k[5]]]] &= ~K[7];
                  if (~G[I].g[K[0]] & K[7])
                  {
                    G[I].g[K[8]] &= ~K[7];
                    G[I].g[w[K[8]][W[3][k[5]]]] &= ~K[7];
                    G[I].g[w[K[8]][W[4][k[5]]]] &= ~K[7];
                  }
                }
                else
                  G[I].g[K[8]] &= ~K[7];
#if RJ > 2
                printf ("%d) WXYZ-Wing Type 1: %d @ r%dc%d %s => -%d @ ",
                  G[I].p, b[G[I].g[K[2]] | G[I].g[K[4]] | G[I].g[K[6]]],
                  ROW (w[K[0]][20] | w[K[2 << Y]][20] | w[K[6]][20]),
                  COL (w[K[0]][20] | w[K[2 << Y]][20] | w[K[6]][20]), S[K[4 >> Y]], b[K[7]]);
                if (k[5] + 1)
                {
                  printf ("r%dc%d",
                    ROW (w[w[K[0]][W[3][k[5]]]][20] | w[w[K[0]][W[4][k[5]]]][20]),
                    COL (w[w[K[0]][W[3][k[5]]]][20] | w[w[K[0]][W[4][k[5]]]][20]));
                  if (~G[I].g[K[0]] & K[7])
                    printf (" r%dc%d",
                      ROW (w[K[8]][20] | w[w[K[8]][W[3][k[5]]]][20] | S[w[K[8]][W[4][k[5]]]][20]),
                      COL (w[K[8]][20] | w[w[K[8]][W[3][k[5]]]][20] | S[w[K[8]][W[4][k[5]]]][20]));
                  printf ("\n");
                }
                else
                  printf ("%s\n", S[K[8]]);
#endif
                goto START;
              }
// WXYZ-Wing Type 1 Transport
            }
          }
          if (K[1] > 5 || K[3] < 14 || B[G[I].g[K[0]]] > 3 ||
                             // Skip Almost Locked Set move Type 1a and Type 1b for either 1st Wing Cell position not Apex Box; or 2nd Wing Cell position not Apex Box; or Apex Cell values > three digits; or
            B[G[I].g[K[2]]] > 2 || B[G[I].g[K[4]]] > 2 || (G[I].g[K[2]] & G[I].g[K[4]]))
            continue;        // 1st Wing Cell values > two digits; or 2nd Wing Cell values > two digits; or common digits in 1st and 2nd Wing Cells values
          if (B[G[I].g[K[0]]] > 2 && B[G[I].g[K[5] = K[2] - K[0] + K[4]]] == 2 &&
                             // Check for Apex Cell values three digits; and 3rd Wing Cell values two digits; and
            B[G[I].g[K[0]] | G[I].g[K[5]]] == 4 &&
                             // Apex and 3rd Wing Cells values four digits; and
            B[G[I].g[K[2]] | G[I].g[K[5]]] == 3 && B[G[I].g[K[4]] | G[I].g[K[5]]] == 3 &&
                             // 1st and 3rd Wing Cells values three digits; and 2nd and 3rd Wing Cells values three digits; and
            ((G[I].g[w[K[0]][W[3][Y = B[G[I].g[K[0]] | G[I].g[K[2]]] > 3]]] | G[I].g[w[K[0]][W[4][Y]]] |
            G[I].g[w[y = K[2 << Y]][W[3][Y]]] | G[I].g[w[y][W[4][Y]]] |
            G[I].g[w[K[0]][Z = W[K[W[14][Y]] < W[5][Y] ? 5 : 1][Y]]] |
            G[I].g[w[K[0]][Z + 1]] | G[I].g[w[K[0]][Z + 2]]) & (K[6] = ~G[I].g[K[5]] & G[I].g[y])))
          {                  // Almost Locked Set move Type 1a removal Cell values
                             // Drop Almost Locked Set move Type 1a Wing Cells common values from removal Cell values
            G[I].g[w[K[0]][W[3][Y]]] &= ~K[6];
            G[I].g[w[K[0]][W[4][Y]]] &= ~K[6];
            G[I].g[w[y][W[3][Y]]] &= ~K[6];
            G[I].g[w[y][W[4][Y]]] &= ~K[6];
            G[I].g[w[K[0]][Z]] &= ~K[6];
            G[I].g[w[K[0]][Z + 1]] &= ~K[6];
            G[I].g[w[K[0]][Z + 2]] &= ~K[6];
#if RJ > 2
            printf ("%d) Almost Locked Set move Type 1a: %d @ r%dc%d r%dc%d => -%d @ r%dc%d\n",
              G[I].p, b[G[I].g[K[2]] | G[I].g[K[4]]], ROW (w[K[0]][20] | w[K[2]][20]), COL (w[K[0]][20] |
              w[K[2]][20]), ROW (w[K[4]][20] | w[K[5]][20]), COL (w[K[4]][20] | w[K[5]][20]),
              b[K[6]], ROW (w[w[K[0]][W[3][Y]]][20] | w[w[K[0]][W[4][Y]]][20] |
              w[w[y][W[3][Y]]][20] | w[w[y][W[4][Y]]][20] | w[w[K[0]][Z]][20] |
              w[w[K[0]][Z + 1]][20] | w[w[K[0]][Z + 2]][20]), COL (w[w[K[0]][W[3][Y]]][20] |
              w[w[K[0]][W[4][Y]]][20] | w[w[y][W[3][Y]]][20] | w[w[y][W[4][Y]]][20] |
              w[w[K[0]][Z]][20] | w[w[K[0]][Z + 1]][20] | w[w[K[0]][Z + 2]][20]));
#endif
            goto START;
          }
          for (Y = 0; Y < 2; ++Y)
          {                  // Search Almost Locked Set move Type 1b 3rd Wing Cell position Line wise
            if (B[G[I].g[K[0]] | G[I].g[K[2 << Y]]] != 3 || B[G[I].g[K[0]] & G[I].g[K[4 >> Y]]] != 1)
              continue;      // Skip for either Apex and 1st (or 2nd) Wing Cells values not three digits; or no one common digit in Apex and 2nd (or 1st) Wing Cells values
            for (K[5] = W[23][Y]; K[5] < W[24][Y]; ++K[5])
            {                // Search 3rd Wing Cell position 1st (or 2nd) Wing Box+Line wise
              if (w[K[6] = w[K[4 >> Y]][K[5]]][20] & w[K[2 << Y]][20] & W[15][Y] ||
                             // Skip for either 3rd Wing Cell position and 2nd (or 1st) Wing Cell position same Line; or
                B[G[I].g[K[6]]] != 2 || B[G[I].g[K[0]] | G[I].g[K[6]]] != 4 ||
                             // 3rd Wing Cell values not two digits; or Apex and 3rd Wing Cells values not four digits; or
                B[G[I].g[K[2]] & G[I].g[K[6]]] != 1 || B[G[I].g[K[4]] & G[I].g[K[6]]] != 1)
                continue;    // No one common digit in 1st and 3rd Wing Cells values; or no one common digit in 2nd and 3rd Wing Cells values
              int k[3] = {K[2 << Y] - COL (w[K[2 << Y]][20]) + COL (w[K[6]][20]),
                          K[6] - COL (w[K[6]][20]) + COL (w[K[2 << Y]][20]),
                          (w[K[2 << Y]][20] & W[25][Y]) == (w[K[6]][20] & W[25][Y])};

              K[7] = G[I].g[K[2 << Y]] & G[I].g[K[6]];
              if ((G[I].g[k[Y]] | (B[G[I].g[K[0]]] > 2 ? 0 : G[I].g[k[!Y]] |
                (k[2] ? G[I].g[w[k[0]][W[3][!Y]]] | G[I].g[w[k[0]][W[4][!Y]]] |
                G[I].g[w[k[1]][W[3][!Y]]] | G[I].g[w[k[1]][W[4][!Y]]] : 0))) & K[7])
              {
                G[I].g[k[Y]] &= ~K[7];
                if (B[G[I].g[K[0]]] < 3)
                {
                  G[I].g[k[!Y]] &= ~K[7];
                  if (k[2])
                  {
                    G[I].g[w[k[0]][W[3][!Y]]] &= ~K[7];
                    G[I].g[w[k[0]][W[4][!Y]]] &= ~K[7];
                    G[I].g[w[k[1]][W[3][!Y]]] &= ~K[7];
                    G[I].g[w[k[1]][W[4][!Y]]] &= ~K[7];
                  }
                }
#if RJ > 2
                printf ("%d) Almost Locked Set move Type 1b: %d @ r%dc%d %s %s => -%d @ r%dc%d",
                  G[I].p, b[G[I].g[K[2]] | G[I].g[K[4]]], ROW (w[K[0]][20] | w[K[2 << Y]][20]),
                  COL (w[K[0]][20] | w[K[2 << Y]][20]), S[K[4 >> Y]], S[K[6]], b[K[7]],
                  ROW (w[k[Y]][20] | (k[2] ? w[w[k[Y]][W[3][!Y]]][20] |
                  w[w[k[Y]][W[4][!Y]]][20] : 0)), COL (w[k[Y]][20] | (k[2] ?
                  w[w[k[Y]][W[3][!Y]]][20] | w[w[k[Y]][W[4][!Y]]][20] : 0)));
                if (B[G[I].g[K[0]]] < 3)
                  printf (" r%dc%d", ROW (w[k[!Y]][20] | (k[2] ? w[w[k[!Y]][W[3][!Y]]][20] |
                    w[w[k[!Y]][W[4][!Y]]][20] : 0)), COL (w[k[!Y]][20] | (k[2] ?
                    w[w[k[!Y]][W[3][!Y]]][20] | w[w[k[!Y]][W[4][!Y]]][20] : 0)));
                printf ("\n");
#endif
                goto START;
              }
            }
          }
        }
      }
    }
    for (a = G[I].p; a < q; ++a)
    {                        // Search WXYZ-Wing Type 2a, Type 2b, Type 3, Type 4a, Type 4b, Almost Locked Set move Type 2a, Type 2b and Type 2c Apex unsolved Cell positions wise
      if (B[G[I].g[r[a]]] > 4)
        continue;            // Skip for unsolved Cell values > four digits
      int K[8] = {r[a]};     // Assign Apex Cell position

      for (y = 0; y < 2; ++y)// Search Wing Cell positions Chute wise
      {
        if (!(G[I].g[w[K[0]][W[6][y]]] | G[I].g[w[K[0]][W[7][y]]] | G[I].g[w[K[0]][W[8][y]]] |
          G[I].g[w[K[0]][W[9][y]]] | G[I].g[w[K[0]][W[10][y]]] | G[I].g[w[K[0]][W[11][y]]]) ||
          !(G[I].g[w[K[0]][W[1][y]]] | G[I].g[w[K[0]][W[18][y]]] | G[I].g[w[K[0]][W[19][y]]] |
          G[I].g[w[K[0]][W[20][y]]] | G[I].g[w[K[0]][W[21][y]]] | G[I].g[w[K[0]][W[22][y]]]))
          continue;          // Skip for no unsolved Cell position found in either Apex Box or Line
        for (K[1] = W[6][y]; K[1] < W[0][y]; ++K[1])
        {                    // Search 1st Wing Cell position Box wise
          if (!G[I].g[K[2] = w[K[0]][K[1]]] || B[G[I].g[K[0]] | G[I].g[K[2]]] > 4)
            continue;        // Skip for either 1st Wing Cell position not unsolved; or Apex and 1st Wing Cell values > four digits
          for (K[3] = W[1][y]; K[3] < W[2][y]; ++K[3])
          {                  // Search 2nd Wing Cell position Line wise
            if (!G[I].g[K[4] = w[K[0]][K[3]]] || B[G[I].g[K[0]] | G[I].g[K[2]] | G[I].g[K[4]]] > 4)
              continue;      // Skip for either 2nd Wing Cell position not unsolved; or Apex and Wings Cells values > four digits
            for (Y = 0; Y < 2; ++Y)
                             // Search WXYZ-Wing Type 2a, Type 2b and Type 3 for 3rd Wing Cell position Box and Line wise
              for (K[5] = K[W[14][Y]] + 1; K[5] < W[Y << 1][y]; ++K[5])
              {              // Search 3rd Wing Cell position
                if (!G[I].g[K[6] = w[K[0]][K[5]]] ||
                             // Skip for either 3rd Wing Cell position not unsolved; or
                  B[G[I].g[K[0]] | G[I].g[K[2]] | G[I].g[K[4]] | G[I].g[K[6]]] != 4 ||
                             // Apex and Wings Cells values not four digits; or
                  !(G[I].g[K[0]] & G[I].g[K[4 >> Y]]) ||
                             // No common value in Apex and 1st (or 2nd) Wing Cells values; or
                  !(G[I].g[K[0]] & (G[I].g[K[2 << Y]] | G[I].g[K[6]])) ||
                             // No common value in Apex and 2nd (or 1st) or 3rd Wings Cells values; or
                  B[K[7] = G[I].g[K[4 >> Y]] & (G[I].g[K[2 << Y]] | G[I].g[K[6]])] != 1)
                  continue;  // Wing Cells common value not one digit
                int A[2] = {-1};

                if ((~G[I].g[K[0]] & K[7]) &&
                             // Check no Wing Cells common value in Apex Cell values; and
                  (K[6] == w[K[2 << Y]][W[3][y]] || K[6] == w[K[2 << Y]][W[4][y]] ||
                             // 3rd Wing Cell position within 1st (or 2nd) Wing Cell position mini-Line; or
                  (G[I].g[K[2 << Y]] & K[7]) != (G[I].g[K[6]] & K[7])))
                {            // No Wing Cells common value in both 1st (or 2nd) Wing Cell values and 3rd Wing Cell values
                  A[0] = K[G[I].g[K[2]] & G[I].g[K[4 >> Y]] & (G[I].g[K[2 << Y]] | G[I].g[K[6]]) ? 2 : 6];
                  A[1] = W[K[G[I].g[K[4]] & G[I].g[K[4 >> Y]] & (G[I].g[K[2 << Y]] | G[I].g[K[6]]) ? 3 : 5] < W[5][y] ? 1 : 5][y];
                }            // Backup WXYZ-Wing Type 2a more removal Cell positions
                if ((G[I].g[w[K[0]][W[3][y]]] | G[I].g[w[K[0]][W[4][y]]] |
                  (A[0] + 1 ? G[I].g[w[A[0]][A[1]]] | G[I].g[w[A[0]][A[1] + 1]] |
                  G[I].g[w[A[0]][A[1] + 2]] : 0)) & K[7])
                {            // Check WXYZ-Wing Type 2a, Type 2b and Type 3 removal Cells values
                             // Drop Wing Cells common value from WXYZ-Wing Type 2a, Type 2b and Type 3 removal Cell positions
                  G[I].g[w[K[0]][W[3][y]]] &= ~K[7];
                  G[I].g[w[K[0]][W[4][y]]] &= ~K[7];
                  if (A[0] + 1)
                  {          // Drop Wing Cells common value from WXYZ-Wing Type 2a more removal Cell positions
                    G[I].g[w[A[0]][A[1]]] &= ~K[7];
                    G[I].g[w[A[0]][A[1] + 1]] &= ~K[7];
                    G[I].g[w[A[0]][A[1] + 2]] &= ~K[7];
                  }
#if RJ > 2
                  printf ("%d) WXYZ-Wing Type %s: %d @ %s %s %s %s => -%d @ r%dc%d",
                    G[I].p, A[0] + 1 ? "2a" : G[I].g[K[0]] & K[7] ? "3" : "2b",
                    b[G[I].g[K[0]] | G[I].g[K[2]] | G[I].g[K[4]] | G[I].g[K[6]]],
                    S[K[0]], S[K[2]], S[K[4]], S[K[6]], b[K[7]],
                    ROW (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20]),
                    COL (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20]));
                  if (A[0] + 1)
                    printf (" r%dc%d", ROW (w[w[A[0]][A[1]]][20] | w[w[A[0]][A[1] + 1]][20] |
                      w[w[A[0]][A[1] + 2]][20]), COL (w[w[A[0]][A[1]]][20] |
                      w[w[A[0]][A[1] + 1]][20] | w[w[A[0]][A[1] + 2]][20]));
                  printf ("\n");
#endif
                  goto START;
                }
// WXYZ-Wing Hybrid Type 1 and Type 2
// WXYZ-Wing Type 2a, Type 2b and Type 3 Transport
              }
            for (K[5] = 3; K[5] < 5; ++K[5])
            {                // Search WXYZ-Wing Type 4a and Type 4b for 2nd Apex Cell position mini-Line wise
              if (K[0] > (K[6] = w[K[0]][W[K[5]][y]]) ||
                             // Skip for either 1st Apex Cell position > 2nd Apex Cell position; or
                !G[I].g[K[6]] || B[G[I].g[K[0]] | G[I].g[K[2]] | G[I].g[K[4]] | G[I].g[K[6]]] != 4 ||
                             // 2nd Apex Cell position not unsolved; or Apex Cells values and Wing Cells values not four digits; or
                !((G[I].g[K[0]] | G[I].g[K[6]]) & G[I].g[K[2]]) ||
                             // No common value in Apex Cells and 1st Wing Cell values; or
                !((G[I].g[K[0]] | G[I].g[K[6]]) & G[I].g[K[4]]) ||
                             // No common value in Apex Cells and 2nd Wing Cell values; or
                B[K[7] = G[I].g[K[2]] & G[I].g[K[4]]] != 1)
                continue;    // Wing Cells common value not one digit
              Z = -1;
              if ((G[I].g[w[K[0]][W[7 - K[5]][y]]] |
                (~(G[I].g[K[0]] | G[I].g[K[6]]) & K[7] ?
                G[I].g[w[K[2]][Z = W[K[3] < W[5][y] ? 1 : 5][y]]] |
                G[I].g[w[K[2]][Z + 1]] | G[I].g[w[K[2]][Z + 2]] : 0)) & K[7])
              {              // Check WXYZ-Wing Type 4a and Type 4b removal Cells values
                             // Drop Wing Cells common value from WXYZ-Wing Type 4b removal Cell position
                G[I].g[w[K[0]][W[7 - K[5]][y]]] &= ~K[7];
                if (Z + 1)
                {            // Drop Wing Cells common value from WXYZ-Wing Type 4a more removal Cell positions
                  G[I].g[w[K[2]][Z]] &= ~K[7];
                  G[I].g[w[K[2]][Z + 1]] &= ~K[7];
                  G[I].g[w[K[2]][Z + 2]] &= ~K[7];
                }
#if RJ > 2
                printf ("%d) WXYZ-Wing Type 4%c: %d @ %s %s %s %s => -%d @ %s",
                  G[I].p, Z + 1 ? 'a' : 'b', b[G[I].g[K[0]] | G[I].g[K[2]] | G[I].g[K[4]] | G[I].g[K[6]]],
                  S[K[0]], S[K[6]], S[K[2]], S[K[4]], b[K[7]], S[w[K[0]][W[7 - K[5]][y]]]);
                if (Z + 1)
                  printf (" r%dc%d", ROW (w[w[K[2]][Z]][20] | w[w[K[2]][Z + 1]][20] |
                    w[w[K[2]][Z + 2]][20]), COL (w[w[K[2]][Z]][20] |
                    w[w[K[2]][Z + 1]][20] | w[w[K[2]][Z + 2]][20]));
                printf ("\n");
#endif
                goto START;
              }
            }
            if (B[G[I].g[K[0]]] == 3 && B[G[I].g[K[0]] | G[I].g[K[2]]] == 4 &&
                             // Check Almost Locked Set move Type 2c for Apex Cell values three digits; and Apex and 1st Wing Cells values four digits; and
              B[G[I].g[K[0]] | G[I].g[K[4]]] == 4 && B[G[I].g[K[2]] & G[I].g[K[4]]] == 1)
                             // Apex and 2nd Wing Cells values four digits; and 1st and 2nd Wing Cells values one common digit
              for (Y = W[K[3] < W[5][y] ? 1 : 5][y]; Y < W[K[3] < W[5][y] ? 5 : 2][y]; ++Y)
              {              // Search Almost Locked Set move Type 2c 3rd Wing Cell position 1st Wing Box and 2nd Wing Line wise
                if (B[G[I].g[K[5] = w[K[2]][Y]]] != 2 || B[G[I].g[K[0]] | G[I].g[K[5]]] != 4 ||
                  B[G[I].g[K[2]] | G[I].g[K[5]]] != 3 || B[G[I].g[K[4]] | G[I].g[K[5]]] != 3)
                  continue;  // 1st and 3rd Wing Cells values not three digits; or 2nd and 3rd Wing Cells values not three digits; or
                if (((B[G[I].g[K[2]]] < 3 ? G[I].g[w[K[4]][W[3][y]]] | G[I].g[w[K[4]][W[4][y]]] : 0) |
                  (B[G[I].g[K[4]]] < 3 ? G[I].g[w[K[2]][W[3][y]]] | G[I].g[w[K[2]][W[4][y]]] : 0)) &
                  (K[6] = G[I].g[K[0]] & G[I].g[K[5]]))
                {
                  if (B[G[I].g[K[2]]] < 3)
                  {
                    G[I].g[w[K[4]][W[3][y]]] &= ~K[6];
                    G[I].g[w[K[4]][W[4][y]]] &= ~K[6];
                  }
                  if (B[G[I].g[K[4]]] < 3)
                  {
                    G[I].g[w[K[2]][W[3][y]]] &= ~K[6];
                    G[I].g[w[K[2]][W[4][y]]] &= ~K[6];
                  }
#if RJ > 2
                  printf ("%d) Almost Locked Set move Type 2c: %d @ r%dc%d r%dc%d => -%d @",
                    G[I].p, b[G[I].g[K[0]] | G[I].g[K[5]]], ROW (w[K[0]][20] | w[K[4]][20]),
                    COL (w[K[0]][20] | w[K[4]][20]), ROW (w[K[2]][20] | w[K[5]][20]),
                    COL (w[K[2]][20] | w[K[5]][20]), b[K[6]]);
                  if (B[G[I].g[K[2]]] < 3)
                    printf (" r%dc%d", ROW (w[w[K[4]][W[3][y]]][20] | w[w[K[4]][W[4][y]]][20]),
                      COL (w[w[K[4]][W[3][y]]][20] | w[w[K[4]][W[4][y]]][20]));
                  if (B[G[I].g[K[4]]] < 3)
                    printf (" r%dc%d", ROW (w[w[K[2]][W[3][y]]][20] | w[w[K[2]][W[4][y]]][20]),
                      COL (w[w[K[2]][W[3][y]]][20] | w[w[K[2]][W[4][y]]][20]));
                  printf ("\n");
#endif
                  goto START;
                }
              }
            if (B[G[I].g[K[0]]] > 3 || B[G[I].g[K[2]]] > 2 || B[G[I].g[K[4]]] > 2 || (G[I].g[K[2]] & G[I].g[K[4]]))
              continue;      // Skip Almost Locked Set move Type 2a and Type 2b for either Apex Cell values > three digits; or 1st Wing Cell values > two digits; or 2nd Wing Cell values > two digits; or 1st and 2nd Wing Cell values common digit
            if (B[G[I].g[K[0]]] > 2)
            {                // Check Almost Locked Set move Type 2a for Apex Cell values three digits
              int L = B[G[I].g[K[0]] & G[I].g[K[2]]] == 2;

              K[6] = W[K[3] < W[5][y] ? 5 : 1][y];
              K[7] = W[K[1] == W[6][y] || K[1] == W[7][y] || K[1] == W[8][y] ? 4 : 3][!y];
              for (Y = W[K[3] < W[5][y] ? 1 : 5][y]; Y < W[K[3] < W[5][y] ? 5 : 2][y]; ++Y)
              {              // Search Almost Locked Set move Type 2a 3rd Wing Cell position 1st Wing Box and 2nd Wing Line wise
                if (!G[I].g[K[5] = w[K[2]][Y]] || B[G[I].g[K[5]]] > 3 || B[G[I].g[K[0]] | G[I].g[K[5]]] != 4 ||
                             // Skip for 3rd Wing Cell values not unsolved; or > three digits; or Apex and 3rd Wing Cells values not four digits; or
                  B[G[I].g[K[2]] | G[I].g[K[5]]] != (B[G[I].g[K[5]]] < 3 || L ? 3 : 4) ||
                             // 1st and 3rd Wing Cells values not if either 3rd Wing Cell values < three digits or Apex and 1st Wing Cells values three digits then three digits else four digits; or
                  B[G[I].g[K[4]] | G[I].g[K[5]]] != (B[G[I].g[K[5]]] > 2 && L ? 4 : 3) ||
                             // 2nd and 3rd Wing Cells values not if either 3rd Wing Cell values > two digits and Apex and 1st Wing Cells values three digits then four digits else three digits; or
                  ((B[G[I].g[K[5]]] > 2 || !((G[I].g[Z = w[K[0]][K[6 | L]]] |
                  G[I].g[w[Z][W[3][y]]] | G[I].g[w[Z][W[4][y]]] | G[I].g[w[K[0]][W[3][y]]] |
                  G[I].g[w[K[0]][W[4][y]]]) & (X = ~G[I].g[K[5]] & G[I].g[K[4 >> L]]))) &&
                             //
                  !((G[I].g[w[K[4 >> L]][W[3][y]]] | G[I].g[w[K[4 >> L]][W[4][y]]]) & G[I].g[K[4 >> L]])))
                  continue;  //
                G[I].g[w[K[4 >> L]][W[3][y]]] &= ~G[I].g[K[4 >> L]];
                G[I].g[w[K[4 >> L]][W[4][y]]] &= ~G[I].g[K[4 >> L]];
                if (B[G[I].g[K[5]]] < 3)
                {
                  G[I].g[Z] &= ~X;
                  G[I].g[w[Z][W[3][y]]] &= ~X;
                  G[I].g[w[Z][W[4][y]]] &= ~X;
                  G[I].g[w[K[0]][W[3][y]]] &= ~X;
                  G[I].g[w[K[0]][W[4][y]]] &= ~X;
                  if (L && (w[K[0]][20] & w[K[2]][20] & W[15][y]))
                  {          // Apex and 1st Wing Cell positions within Line
                    G[I].g[w[K[0]][W[1][!y]]] &= ~X;
                    G[I].g[w[K[0]][W[18][!y]]] &= ~X;
                    G[I].g[w[K[0]][W[19][!y]]] &= ~X;
                    G[I].g[w[K[0]][W[20][!y]]] &= ~X;
                    G[I].g[w[K[0]][W[21][!y]]] &= ~X;
                    G[I].g[w[K[0]][W[22][!y]]] &= ~X;
                  }
                }
#if RJ > 2
                printf ("%d) Almost Locked Set move Type 2a: %d @ r%dc%d r%dc%d => -%d @ r%dc%d",
                  G[I].p, b[G[I].g[K[2]] | G[I].g[K[4]]], ROW (w[K[0]][20] | w[K[4]][20]),
                  COL (w[K[0]][20] | w[K[4]][20]), ROW (w[K[2]][20] | w[K[5]][20]),
                  COL (w[K[2]][20] | w[K[5]][20]), b[G[I].g[K[4 >> L]]],
                  ROW (w[w[K[4 >> L]][W[3][y]]][20] | w[w[K[4 >> L]][W[4][y]]][20]),
                  COL (w[w[K[4 >> L]][W[3][y]]][20] | w[w[K[4 >> L]][W[4][y]]][20]));
                if (B[G[I].g[K[5]]] < 3)
                {
                  printf (" => -%d @ ", b[X]);
                  if (L)
                  {
                    printf ("r%dc%d r%dc%d",
                      ROW (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20]),
                      COL (w[w[K[0]][W[3][y]]][20] | w[w[K[0]][W[4][y]]][20]),
                      ROW (w[Z][20] | w[w[Z][W[3][y]]][20] | w[w[Z][W[4][y]]][20]),
                      COL (w[Z][20] | w[w[Z][W[3][y]]][20] | w[w[Z][W[4][y]]][20]));
                    if (w[K[0]][20] & w[K[2]][20] & W[15][y])
                      printf (" r%dc%d",
                        ROW (w[w[K[0]][W[1][!y]]][20] | w[w[K[0]][W[18][!y]]][20] |
                        w[w[K[0]][W[19][!y]]][20] | w[w[K[0]][W[20][!y]]][20] |
                        w[w[K[0]][W[21][!y]]][20] | w[w[K[0]][W[22][!y]]][20]),
                        COL (w[w[K[0]][W[1][!y]]][20] | w[w[K[0]][W[18][!y]]][20] |
                        w[w[K[0]][W[19][!y]]][20] | w[w[K[0]][W[20][!y]]][20] |
                        w[w[K[0]][W[21][!y]]][20] | w[w[K[0]][W[22][!y]]][20]));
                  }
                  else
                    printf ("r%dc%d",
                      ROW (w[w[K[0]][W[3][y]]][20] |w[w[K[0]][W[4][y]]][20] |
                      w[Z][20] | w[w[Z][W[3][y]]][20] | w[w[Z][W[4][y]]][20]),
                      COL (w[w[K[0]][W[3][y]]][20] |w[w[K[0]][W[4][y]]][20] |
                      w[Z][20] | w[w[Z][W[3][y]]][20] | w[w[Z][W[4][y]]][20]));
                }
                printf ("\n");
#endif
                goto START;
              }
            }
            if (B[G[I].g[K[0]] & G[I].g[K[2]]] != 1 || B[G[I].g[K[0]] | G[I].g[K[4]]] != 3)
              continue;      // Skip Almost Locked Set move Type 2b for either Apex and 1st Wing Cells values not one common digit; or Apex and 2nd Wing Cells values not three digits
            for (Y = W[K[3] < W[5][y] ? 5 : 1][y]; Y < W[K[3] < W[5][y] ? 2 : 5][y]; ++Y)
            {                // Search Almost Locked Set move Type 2b 3rd Wing Cell position 2nd Wing Line wise but not in Box
              if (B[G[I].g[K[5] = w[K[2]][Y]]] != 2 || B[G[I].g[K[0]] | G[I].g[K[5]]] != 4 ||
                             // Skip for 3rd Wing Cell values not two digits; or Apex and 3rd Wing Cells values not four digits; or
                B[G[I].g[K[2]] | G[I].g[K[5]]] != 3 || B[G[I].g[K[4]] | G[I].g[K[5]]] != 3)
                continue;    // 1st and 3rd Wing Cells values not three digits; or 2nd and 3rd Wing Cells values not three digits
              if ((G[I].g[K[6] = K[4 | y] - COL (w[K[4 | y]][20]) + COL (w[K[5 - y]][20])] |
                G[I].g[w[K[6]][W[3][y]]] | G[I].g[w[K[6]][W[4][y]]] | (B[G[I].g[K[0]]] > 2 ? 0 :
                G[I].g[K[7] = K[5 - y] - COL (w[K[5 - y]][20]) + COL (w[K[4 | y]][20])] |
                G[I].g[w[K[7]][W[3][y]]] | G[I].g[w[K[7]][W[4][y]]])) & G[I].g[K[4]] & G[I].g[K[5]])
              {
                G[I].g[K[6]] &= ~(G[I].g[K[4]] & G[I].g[K[5]]);
                G[I].g[w[K[6]][W[3][y]]] &= ~(G[I].g[K[4]] & G[I].g[K[5]]);
                G[I].g[w[K[6]][W[4][y]]] &= ~(G[I].g[K[4]] & G[I].g[K[5]]);
                if (B[G[I].g[K[0]]] < 3)
                {
                  G[I].g[K[7]] &= ~(G[I].g[K[4]] & G[I].g[K[5]]);
                  G[I].g[w[K[7]][W[3][y]]] &= ~(G[I].g[K[4]] & G[I].g[K[5]]);
                  G[I].g[w[K[7]][W[4][y]]] &= ~(G[I].g[K[4]] & G[I].g[K[5]]);
                }
#if RJ > 2
                printf ("%d) Almost Locked Set move Type 2b: %d @ r%dc%d r%dc%d => -%d @ r%dc%d",
                  G[I].p, b[G[I].g[K[2]] | G[I].g[K[4]]], ROW (w[K[0]][20] | w[K[4]][20]),
                  COL (w[K[0]][20] | w[K[4]][20]), ROW (w[K[2]][20] | w[K[5]][20]),
                  COL (w[K[2]][20] | w[K[5]][20]), b[G[I].g[K[4]] & G[I].g[K[5]]],
                  ROW (w[K[6]][20] | w[w[K[6]][W[3][y]]][20] | w[w[K[6]][W[4][y]]][20]),
                  COL (w[K[6]][20] | w[w[K[6]][W[3][y]]][20] | w[w[K[6]][W[4][y]]][20]));
                if (B[G[I].g[K[0]]] < 3)
                  printf (" r%dc%d",
                    ROW (w[K[7]][20] | w[w[K[7]][W[3][y]]][20] | w[w[K[7]][W[4][y]]][20]),
                    COL (w[K[7]][20] | w[w[K[7]][W[3][y]]][20] | w[w[K[7]][W[4][y]]][20]));
                printf ("\n");
#endif
                goto START;
              }
            }
          }
        }
      }
    }
    for (X = -1, a = G[I].p; a < q; ++a)
      if (B[G[I].g[r[a]]] < 3)
        continue;            // Skip Bivalue Universal Grave for unsolved Cell values < three digits
      else if (B[G[I].g[r[a]]] == 3 && X < 0)
        X = r[a];            // Backup first unsolved Cell position having Trivalues
      else
        break;
    if (a == q)              // All unsolved Cell positions checked
    {
      if (X + 1)             // One Trivalue Cell position found
      {
        for (Y = G[I].g[X]; y = Y & -Y; Y -= y)
                             // For each digit in Trivalue Cell position
          if ((G[I].g[w[X][0]] & y ? 1 : 0) + (G[I].g[w[X][1]] & y ? 1 : 0) +
            (G[I].g[w[X][2]] & y ? 1 : 0) + (G[I].g[w[X][3]] & y ? 1 : 0) +
            (G[I].g[w[X][4]] & y ? 1 : 0) + (G[I].g[w[X][5]] & y ? 1 : 0) +
            (G[I].g[w[X][6]] & y ? 1 : 0) + (G[I].g[w[X][7]] & y ? 1 : 0) == 2 ||
            (G[I].g[w[X][6]] & y ? 1 : 0) + (G[I].g[w[X][7]] & y ? 1 : 0) +
            (G[I].g[w[X][8]] & y ? 1 : 0) + (G[I].g[w[X][9]] & y ? 1 : 0) +
            (G[I].g[w[X][10]] & y ? 1 : 0) + (G[I].g[w[X][11]] & y ? 1 : 0) +
            (G[I].g[w[X][12]] & y ? 1 : 0) + (G[I].g[w[X][13]] & y ? 1 : 0) == 2 ||
            (G[I].g[w[X][12]] & y ? 1 : 0) + (G[I].g[w[X][13]] & y ? 1 : 0) +
            (G[I].g[w[X][14]] & y ? 1 : 0) + (G[I].g[w[X][15]] & y ? 1 : 0) +
            (G[I].g[w[X][16]] & y ? 1 : 0) + (G[I].g[w[X][17]] & y ? 1 : 0) +
            (G[I].g[w[X][18]] & y ? 1 : 0) + (G[I].g[w[X][19]] & y ? 1 : 0) == 2)
          {                  // Digit found Row, Box or Column wise in two Cell positions
#if RJ > 2
            printf ("%d) BUG+1: %d @ %s => -%d @ %s\n", G[I].p, b[y], S[X], b[G[I].g[X] - y], S[X]);
#endif
            G[I].g[X] = y;   // Remove BUG+1 other digits from Trivalue removal Cell values
            goto START;
          }
      }
#if RJ > 2
      else
        printf ("%d) There might be a BUG in the current state of the Puzzle's pencilmark!\n", G[I].p);
#endif
    }
    y = 2;                   // 2 Represent Guess
    if (++n[3] > n[4])
      ++n[4];
    G[++I] = G[I - 1];
NHSCF:
    if (x > G[I].p)          // Check current Cell position for sorting and removing
    {
      a = r[G[I].p];
      r[G[I].p] = r[x];
      r[x] = a;
    }
    for (++n[y], G[I].s[r[G[I].p]] = z & -z, Y = ~G[I].s[r[G[I].p]], Z = a = 0; a < 20; ++a)
    {                        // Search 20 peer Cell positions
#if RJ > 2
      if (y == 1 && G[I].g[w[r[G[I].p]][a]] & G[I].s[r[G[I].p]])
        Z |= 1 << a;
#endif
      G[I].g[w[r[G[I].p]][a]] &= Y;
    }
#if RJ > 2
    printf ("%d%s) %s: %d @ %s", G[I].p + 1, G[I].p != 10 && !(G[I].p % 10) ? "st" :
      (G[I].p != 11 && G[I].p % 10 == 1 ? "nd" : (G[I].p != 12 && G[I].p % 10 == 2 ? "rd" : "th")),
      y ? (y > 1 ? "Trial & Error" : "Hidden single") : "Naked single", b[G[I].s[r[G[I].p]]], S[r[G[I].p]]);
    if (y)
    {
      printf (" from values %d", b[G[I].g[r[G[I].p]]]);
      if (y < 2)
        printf (" in %s %d", Z & 255 ? (Z >> 12 ? "Box" : "Column") : "Row",
          Z & 255 ? (Z >> 12 ? BOX (r[G[I].p]) : COL (w[r[G[I].p]][20])) : ROW (w[r[G[I].p]][20]));
    }
    printf ("\n");
#endif
    G[I].g[r[G[I].p]] = 0;
    if (G[I].p + 1 < q)      // Check either iteratively solve for next unsolved Cell position; or all Cell positions solved
      ++G[I].p;
    else
      return 1;
  }
}

int main (void)
{
  int a = -1,
      A = -1,
      m,
      i = 0,
      t = 0,
      u = 0,
      v = 0,
      y = 0;

  float c,
        d = 0,
        e = 0,
        f = 0,
        k = 0;

  FILE *o = fopen ("sukaku.txt", "r");

  n[5] = n[6] = n[7] = n[8] = 0;
  if (o == NULL)
    printf ("Error: Unable to open sukaku.txt file for read !!\n");
  else
    do
    {
      if ((m = fgetc (o)) != 10 && m != EOF && a < 728)
      {
        if (++a % 9)
        {
          G[0].g[A] |= (m > 48 && m < 58) << (m - 49);
        }
        else
        {
          G[0].g[++A] = (m > 48 && m < 58) << (m - 49);
          G[0].s[A] = 0;
          r[q++] = A;
        }                    // Assign clue Cell positions
        n[8] += m > 48 && m < 58;
      }
      else if (m == 10 || m == EOF)
      {
#if RJ > 1
        printf ("\n");
#endif
        G[0].p = I = n[0] = n[1] = n[2] = n[3] = n[4] = 0;
        c = clock ();
#if RJ > 4
        for (a = 0; a < 81; ++a)
        {
          if (!(a % 27))
            printf ("+---+---+---+\n|");
          else if (!(a % 3))
            printf ("|");
          if (G[0].s[a])
            printf ("%d", b[G[0].s[a]]);
          else
            printf (".");
          if (a > 0 && !((a + 1) % 9))
            printf ("|\n");
        }
        printf ("+---+---+---+\n");
#endif
        if (solve ())
        {
          c = (clock () - c) / CLOCKS_PER_SEC;
          e += c;
          ++t;
          ++v;
          if (!n[2])
            ++n[5];
          if (n[2] > n[6])
            n[6] = n[2];
          if (n[4] > n[7])
            n[7] = n[4];
#if RJ
          printf ("%ld) ", t);
          for (a = 0; a < 81; ++a)
            printf ("%d", b[G[I].s[a]]);
          printf (" # S%ld", v);
#endif
        }
        else
        {
          c = (clock () - c) / CLOCKS_PER_SEC;
          f += c;
          ++t;
          ++u;
#if RJ
          printf ("%ld) Error: Unsolvable Sudoku! # U%ld", t, u);
#endif
        }
#if RJ
        printf (" # C%d # P%d # N%ld # H%ld # G%ld # D%ld # %f\n", 81 - q, n[8], n[0], n[1], n[2], n[4], c);
#endif
        a = A = -1;
        q = n[8] = 0;
      }
#if RJ > 1
      if (m != 10 && m != 13 && m != EOF)
        printf ("%c", m);
#endif
    }
    while (m != EOF);
  printf ("=======================================\n");
  printf ("Total Sukaku puzzles read  : %ld\n", t);
  printf ("Total time for all puzzles : %f\n", d + k + e + f);
  printf ("Average time per puzzle    : %f\n", t ? (d + k + e + f) / t : 0);
  printf ("Number of valid puzzles    : %ld\n", y);
  printf ("Time for valid puzzles     : %f\n", k);
  printf ("Average time per valid     : %f\n", y ? k / y : 0);
  printf ("Number of invalid puzzles  : %ld\n", i);
  printf ("Time for invalid puzzles   : %f\n", d);
  printf ("Average time per invalid   : %f\n", i ? d / i : 0);
  printf ("Number of solved puzzles   : %ld\n", v);
  printf ("Time for solved puzzles    : %f\n", e);
  printf ("Average time per solved    : %f\n", v ? e / v : 0);
  printf ("Number of unsolved puzzles : %ld\n", u);
  printf ("Time for unsolved puzzles  : %f\n", f);
  printf ("Average time per unsolved  : %f\n", u ? f / u : 0);
  printf ("Total solved without guess : %d\n", n[5]);
  printf ("Total solved with guess    : %d\n", v - n[5]);
  printf ("Maximum number of guess    : %d\n", n[6]);
  printf ("Maximum number of depth    : %d\n", n[7]);
  if (fclose (o) == EOF)
    printf ("Error: Unable to close sukaku.txt file !!");
}
